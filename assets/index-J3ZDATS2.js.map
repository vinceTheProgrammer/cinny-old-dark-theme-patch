{"version":3,"mappings":"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","names":["l","p","r","t","u","v","w","z","A","a","B","D","E","b","e","F","G","H","C","I","J","K","L","d","c","k","g","m","h","N","O","P","escape","n","R","f","S","T","U","V","W","react_production_min","q","M","y","require$$0","La","Oa","Na","Ma","Pa","yf","Af","zf","Bf","Cf","Df","Ef","Ff","Gf","Jf","Hf","If","Kf","bd","Nf","uf","of","Qf","Rf","Wc","Of","Mf","ue","Db","Sf","Tf","Vf","Uf","Yf","$f","Wf","bg","Ra","Xf","dg","eg","gg","hg","ig","fg","jg","ac","fc","mg","ng","pg","qg","rg","sg","kg","lg","ug","og","oc","vg","tg","xg","yg","zg","Bg","Cg","Dg","Lf","Ag","Hg","Fg","Jg","Kg","ua","Lg","Mg","Ng","Pg","Og","Sg","Tg","Ug","Vg","Wg","Xg","Yg","Zg","ah","bh","ch","dh","hh","ih","aa","kh","lh","mh","eh","Ie","nh","sh","th","wh","xh","ya","Ha","uh","yh","va","wa","zh","eb","Ka","Ah","x","Bh","Dh","Fh","Gh","Hh","Ih","Eh","lb","Jh","Lh","Nh","Oh","Ph","Sh","Th","Uh","Vh","Q","He","Xh","$h","ai","bi","ci","di","fi","Rh","gi","hi","ii","ji","ki","ni","mi","oi","pi","qi","ei","ri","si","ti","li","vi","ui","wi","yi","zi","Ai","Bi","Wh","yc","Qh","Fi","Gi","Hi","Ii","Ji","Ei","xi","Ci","Di","Mi","Oi","Pi","Ri","Si","Ti","Ni","Vi","Xi","Yi","Ch","Zi","$i","aj","bj","cj","dj","fj","gj","hj","Zf","ij","cg","jj","ph","rh","qh","$g","classNames","classes","arg","argType","inner","key","module","color","lightTheme","config","pxToRem","px","target","offset","canAlignXCenter","left","canAlignXEnd","anchor","canAlignYCenter","top","canAlignYEnd","alignXEnd","xEnd","alignXAuto","canAlignXStart","align","alignXStart","alignYStart","alignYCenter","yEnd","alignYEnd","canPositionTop","canPositionRight","canPositionBottom","positionBottom","positionAuto","alignOffset","positionRight","alignY","positionLeft","positionTop","alignX","getRelativeFixedPosition","position","canPositionLeft","percent","min","max","value","as","obj","ownKeys","object","enumerableOnly","keys","symbols","_objectSpread2","i","_defineProperty","source","shouldApplyCompound","compoundCheck","_selections$key","selections","defaultVariants","createRuntimeFn","config2","options","className","variantName","_selections$variantNa","selection","variantSelection","selectionClassName","compoundClassName","Avatar$1","AvatarFallback$1","Avatar","radii","ref","jsx","AsAvatarImage","AvatarImage$1","props","AsAvatarFallback","Badge$1","Badge","size","variant","fill","outlined","AsBadge","AsBox","justifyContent","justifySelf","alignContent","alignItems","grow","shrink","basis","Box$1","display","direction","wrap","Button$1","Button","AsButton","before","after","children","jsxs","Icon$1","forwardRef","Icons","filled","Fragment","Checkbox$1","CheckboxIcon","Checkbox","style","CheckboxInput","Icon","Chip$1","Chip","AsChip","Dialog$1","Dialog","AsDialog","Header$1","Header","AsHeader","IconButton","AsIconButton","IconButton$1","Input$1","InputInput","inputSize","Line$1","Line","AsLine","MenuItem$1","MenuItem","AsMenuItem","Menu$1","Menu","AsMenu","Modal$1","Modal","AsModal","flexHeight","Overlay$1","OverlayBackdrop$1","OverlayCenter$1","Portal","container","createPortal","AsOverlay","open","backdrop","AsOverlayBackdrop","OverlayCenter","AsOverlayCenter","PopOut$1","PopOutContainer","PopOut","content","baseRef","useRef","useCallback","baseEl","pCSS","useEffect","positionPopOut","useLayoutEffect","AsPopOut","ProgressBar$1","ProgressBarFill","AsProgressBar","RadioButton$1","Scroll$1","Scroll","AsScroll","visibility","hideTrack","scrollLocalRef","$scroll","yScrollbarWidth","xScrollbarWidth","propRef","Spinner$1","SpinnerOuter","SpinnerSvg$1","SpinnerSvg","SpinnerInner","Spinner","AsSpinner","onChange","handleClick","Switch$1","SwitchThumb","Text$1","Text","AsText","priority","truncate","Tooltip$1","TooltipProvider$1","Tooltip","AsTooltip","useTooltip","delay","triggerRef","setOpen","useState","tooltipCss","timeoutId","evt","closeTooltip","onKeyDown","trigger","openTooltip","positionTooltip","handleTriggerRef","handleBaseRef","element","AsTooltipProvider","tooltip","instance","ReflectApply","receiver","args","ReflectOwnKeys","ProcessEmitWarning","warning","EventEmitter","eventsModule","once","defaultMaxListeners","listener","NumberIsNaN","that","_getMaxListeners","type","events","doError","er","err","handler","len","listeners","arrayClone","checkListener","existing","prepend","_addListener","onceWrapper","_onceWrap","state","wrapped","list","originalListener","spliceOne","evlistener","unwrap","unwrapListeners","_listeners","emitter","listenerCount","arr","copy","index","name","reject","resolve","errorListener","addErrorHandlerIfEventEmitter","flags","eventTargetAgnosticAddListener","wrapListener","condition","_len","_key","error","argIndex","invariant_1","invariant","_proto","callback","id","ids","payload","Dispatcher","Dispatcher_1","cons","getSettings","settings","silverTheme","darkTheme","butterTheme","oldDarkTheme","onLightFontWeight","onDarkFontWeight","themeName","autoThemeIndex","themeIndex","setSettings","appDispatcher","bytesToSize","bytes","sizeIndex","sizes","millisecondsToMinutesAndSeconds","milliseconds","mm","ss","secondsToMinutesAndSeconds","seconds","getFileTypeIcon","fileType","icons","fulfilledPromiseSettledResult","prs","values","pr","promiseFulfilledResult","scaleYDimension","parseGeoUri","data","location","latitude","longitude","START_SLASHES_REG","END_SLASHES_REG","str","trimSlash","trimLeadingSlash","nameInitials","code","define_import_meta_env_default","_extends","opts","DataRouterContext","React.createContext","DataRouterStateContext","NavigationContext","LocationContext","RouteContext","useHref","_temp","relative","useInRouterContext","UNSAFE_invariant","basename","React.useContext","hash","pathname","search","to","joinPaths","joinedPathname","useLocation","useMatch","React.useMemo","matchPath","pattern","useIsomorphicLayoutEffect","React.useLayoutEffect","cb","isDataRoute","useNavigateStable","useNavigateUnstable","navigator","matches","locationPathname","routePathnamesJson","UNSAFE_getResolveToMatches","activeRef","React.useRef","React.useCallback","path","resolveTo","dataRouterContext","OutletContext","useOutlet","context","outlet","React.createElement","useParams","routeMatch","useResolvedPath","_temp2","useRoutesImpl","routes","locationArg","parentMatches","parentParams","parsedLocationArg","parentPathnameBase","_parsedLocationArg$pa","locationFromContext","remainingPathname","match","renderedMatches","Action","DefaultErrorComponent","useRouteError","preStyles","React.Fragment","stack","defaultErrorElement","RenderErrorBoundary","React.Component","errorInfo","RouteErrorContext","RenderedRoute","_ref","routeContext","_renderMatches","dataRouterState","_dataRouterState","errors","_dataRouterState2","errorIndex","errorElement","getChildren","DataRouterHook","DataRouterStateHook","useDataRouterContext","hookName","ctx","useDataRouterState","useRouteContext","route","useCurrentRouteId","thisRoute","_state$errors","routeId","router","Outlet","Route","Router","locationProp","staticProp","_ref5","navigationContext","candidateSelectors","_toPropertyKey","hint","input","prim","res","_toPrimitive","activeFocusTraps","trapStack","trap","activeTrap","trapIndex","isSelectableInput","node","isEscapeEvent","isTabEvent","isKeyBackward","fn","findIndex","idx","params","getActualTarget","event","internalTrapStack","createFocusTrap","elements","userOptions","doc","isKeyForward","getOption","optionName","findContainerIndex","tabbableNodes","optionValue","_len2","_key2","getInitialFocusNode","firstTabbableNode","firstTabbableGroup","getNodeForOption","updateTabbableNodes","tabbable","focusable","focusableNodes","forward","nodeIdx","isTabbable","group","tryFocus","getReturnFocusNode","previousActiveElement","checkPointerDown","valueOrHandler","isFocusable","checkFocusIn","targetContained","checkKeyNav","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","destinationGroup","destinationGroupIndex","_ref3","lastTabbableNode","lastOfGroupIndex","_destinationGroup","_destinationGroupIndex","checkClick","addListeners","removeListeners","checkKey","activateOptions","onPostActivate","checkCanFocusTrap","onActivate","finishActivation","deactivateOptions","onPostDeactivate","returnFocus","onDeactivate","finishDeactivation","checkCanReturnFocus","containerElements","_typeof","_classCallCheck","Constructor","descriptor","_createClass","_defineProperties","staticProps","subClass","superClass","_setPrototypeOf","o","_createSuper","hasNativeReflectConstruct","_isNativeReflectConstruct","Derived","result","_getPrototypeOf","_possibleConstructorReturn","self","call","React","PropTypes","require$$1","_require","require$$2","_require2","require$$3","FocusTrap","_React$Component","_inherits","_super","_this","_this$internalOptions","_this$getDocument","_assertThisInitialized","focusTrapOptions","currentDocument","allowDeactivation","returnFocusNode","_this2","canReturnFocus","_this2$internalOption","preventScroll","nodesExist","prevProps","hasDeactivated","hasActivated","hasPaused","hasUnpaused","child","_this3","childWithRef","ElementType","useDebounce","timeoutIdRef","wait","cbArgs","immediate","lib","IS_MAC","MODIFIERS","ALIASES","CODES","hotkey","string","parseHotkey","check","array","isCodeHotkey","isHotkey","isKeyHotkey","byKey","length","ret","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","optional","toKeyName","modifier","toKeyCode","compareHotkey","expected","actual","isKeyHotkey_1","onTabPress","preventScrollWithArrowKey","stopPropagation","ServerPicker","allowCustomServer","onServerChange","serverInputRef","server","debounceServerSelect","handleServerChange","inputServer","handleKeyDown","handleServerSelect","selectedServer","handleOpenServerMenu","setServerMenuAnchor","Input","serverList","serverMenuAnchor","serverName","errorExt","promise","AutoDiscoveryAction","autoDiscovery","request","host","trimTrailingSlash","autoDiscoveryUrl","response","contentErr","baseUrl","specVersions","fallback","useAsyncCallback","ignoreError","ignoreCallback","load","AsyncStatus","SpecVersionsContext","createContext","useSpecVersions","useContext","versions","AutoDiscoveryInfoProvider","AutoDiscoverInfoContext","useAutoDiscoveryInfo","autoDiscoveryInfo","asyncGeneratorStep","_next","_throw","toPrimitive","toPropertyKey","root","definition","this","noop","isIE","undefinedType","bindMethod","method","methodName","traceForIE","realMethod","logMethods","level","loggerName","enableLoggingWhenConsoleArrives","replaceLoggingMethods","Logger","defaultLevel","storageKey","persistLevelIfPossible","levelName","levelNum","getPersistedLevel","storedLevel","cookie","clearPersistedLevel","currentLevel","persist","initialLevel","logger","_loggersByName","defaultLogger","_log","DEFAULT_NAMESPACE","loglevel","logLevel","supportedByConsole","extendLogger","prefixedLogger","prefix","existingPrefix","getPrefixedLogger","prefixLogger","parent","msg","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","escapeRegexp","replace_fn","unhomoglyph","REPLACE_RE","unhomoglyph_1","timeouts","retry_operation","RetryOperation","currentTime","timeout","timeoutOps","counts","mainError","message","count","exports","random","attempt","methods","original","op","retry","networkErrorMsgs","AbortError","decorateErrorWithCounts","attemptNumber","retriesLeft","isNetworkError","errorMessage","pRetry","operation","pRetryModule","stable","unstable","altName","names","val","included","ServerControlledNamespacedValue","NamespacedValue","preferUnstable","NamespacedMap_1","_createForOfIteratorHelper","it","_unsupportedIterableToArray","allowArrayLike","_e","normalCompletion","step","_e2","didErr","minLen","_arrayLikeToArray","arr2","protoProps","NamespacedMap","initial","InvalidEventError_1","NewTarget","_cache","Class","_isNativeFunction","Wrapper","_construct","_wrapNativeSuper","Parent","InvalidEventError","_Error","ExtensibleEvent_1","ExtensibleEvent","wireFormat","types","isOptionalAString","s","isProvided","NamespacedValue_1","Super","ExtensibleEvents","_message_types","_MMessage","_poll_types","_MPoll","_this$_unknownInterpr","wireEventType","interpreter","tryType","ExtensibleEvents_1","IPartialEvent","MessageMatchers","isEventLike","LegacyMsgType","msgtype","_ExtensibleEvents","_IPartialEvent","_this$thread","eventId","eventDebugString","timeline","_this$thread4","parentEventId","roomState","parentEvent","insertIndex","parentIndex","nextEvent","timelineEvents","RoomEvent","localEvent","oldEventId","existingTimeline","newEventId","eventId1","eventId2","timeline2","timeline1","idx1","evId","difference","tl","EventTimeline","threadId","shouldLiveInThread","shouldLiveInRoom","_this$room2","EventStatus","RoomSummary","roomId","ReEmitter","eventNames","reEmittersByEvent","eventName","forSource","_loop","TypedReEmitter","UNREAD_THREAD_NOTIFICATIONS","matchesWildcard","filterValue","typePrefix","actualValue","FilterComponent","filterJson","_event$getUnsigned","bundledRelationships","_bundledRelationships","THREAD_RELATION_TYPE","relations","FILTER_RELATED_BY_SENDERS","FILTER_RELATED_BY_REL_TYPES","sender","eventType","literalKeys","matchFunc","notName","disallowedValues","allowedValues","containsUrlFilter","containsUrl","relationTypesFilter","relationSendersFilter","setProp","keyNesting","currentObj","nestedKeys","Filter","userId","filter","filterId","jsonObj","roomFilterJson","roomFilterFields","limit","enabled","_this$definition2","_objectSpread","M_TOPIC","UnstableValue","makeHtmlMessage","body","MsgType","htmlBody","makeHtmlNotice","makeTextMessage","uri","assetType","date","assetName","LocationAssetType","description","quotedDescription","text","getTextForLocationEvent","timestamp","timestampEvent","M_TIMESTAMP","M_LOCATION","M_ASSET","M_TEXT","defaultedText","parseLocationEvent","wireEventContent","_location$uri","_asset$type","geoUri","makeLocationContent","makeTopicContent","topic","htmlTopic","renderings","parseTopicContent","_mtopic$find$body","_mtopic$find","_mtopic$find2","mtopic","html","makeBeaconInfoContent","isLive","parseBeaconInfoContent","live","makeBeaconContent","beaconInfoEventId","_M_TIMESTAMP$findIn2","BeaconEvent","isTimestampInDuration","startTimestamp","Beacon","TypedEventEmitter","rootEvent","getBeaconInfoIdentifier","parseBeaconContent","beaconInfoEvent","expiryInMs","beaconLocationEvents","_validLocationEvents$","validLocationEvents","parsed","sortEventsByLatestContentTimestamp","latestLocationEvent","prevLiveness","synthesizeReceipt","receiptType","MatrixEvent","EventType","ReceiptPairRealIndex","ReadReceipt","MapWithDefault","_this$receipts$get$ge","_this$receipts$get","ignoreSynthesized","ReceiptType","realReceipt","syntheticReceipt","_this$getUnfilteredTi","latestReceipt","receipt","_receipt$data","MAIN_ROOM_TIMELINE","eventIsInMainTimeline","inMainTimelineForReceipt","_ref2","publicReadReceipt","comparison","privateReadReceipt","_pair$ReceiptPairSynt2","_pair$ReceiptPairSynt3","pair","receiptTypesMap","existingReceipt","_pair$ReceiptPairSynt","wrappedReceipt","_ordering","ReceiptPairSyntheticIndex","ordering","preferSynthetic","cachedReceipt","synthetic","newCachedReceipt","lastEvent","NotificationCountType","unthreaded","PollEvent","responseEvents","relationEvents","M_POLL_RESPONSE","pollEndTimestamp","matrixClient","room","undecryptableEventIds","previousCount","_this$endEvent","_asyncToGenerator","M_POLL_END","_this$endEvent2","filterResponseRelations","allRelations","responses","Relations","pollEndEvent","pollCloseTimestamp","_this2$endEvent","_allRelations$nextBat","_this$endEvent3","_this$responses","endEvent","endEventSender","roomCurrentState","M_POLL_START","RoomReceipts","danglingReceipts","danglingReceipt","ThreadedReceipts","ReceiptsByUser","DanglingReceipts","receiptContent","_receiptType","eventReceipt","_eventId","_receipt","_userId","DanglingReceipt","threadIdForReceipt","threaded","isAfterOrSame","_this$room$getThread","ts","receiptInfo","_this$synthetic","userReceipts","getOrCreate","UserReceipts","ReceiptInfo","_this$data$get","receiptsByUser","_this$data$get2","createFn","found","created","rightEventId","isAfter","compareEventOrdering","leftEventId","leftEvent","rightEvent","isLeftEventInMainTimeline","compareEventsInMainTimeline","compareEventsInThreads","timelineSet","compareSameTimeline","leftTimeline","rightTimeline","guessOrderBasedOnTimestamp","rightEventThreadId","leftThread","leftTs","rightTs","Method","HTTPError","httpStatus","MatrixError","errorJson","url","ConnectionError","cause","HttpApiEvent","PARAM_REGEXP","QESC_REGEXP","TYPE_REGEXP","parse_1","parse","header","getcontenttype","writer","write","parser","base64Js","byteLength","toByteArray","fromByteArray","lookup","revLookup","getLens","validLen","placeHoldersLen","lens","_byteLength","b64","tmp","Arr","curByte","ieee754","customInspectSymbol","escapes","parseReplyFormattedBody","formattedBody","userLink","getMemberDisplayName","getMemberSearchStr","member","query","mxIdToName","isMembershipChanged","mEvent","mx","decryptionPromises","crypto","shortcode","getEventEdits","RelationType","getLatestEdit","targetEvent","editEvents","eventByTargetSender","rEvent","m1","m2","getEditedEvent","mEventId","edits","canEditEvent","relationType","MessageEvent","getLatestEditableEvt","canEdit","matchMxId","validMxId","getMxIdServer","getMxIdLocalPart","isUserId","isRoomId","alias","getStateEvent","getCanonicalAliasOrRoomId","StateEvent","getImageInfo","info","fileOrBlob","getVideoInfo","video","getThumbnailContent","thumbnailInfo","encInfo","encryptFile","file","dataBuffer","encryptedAttachment","encFile","decryptFile","uploadContent","hideFilename","onProgress","onPromise","onError","uploadPromise","mxc","onSuccess","factoryEventSentBy","senderId","ev","eventWithShortcode","guessDmRoomUserId","myUserId","getOldestMember","members","oldestMemberTs","oldestMember","pickOldestMember","addRoomIdToMDirect","AccountDataEvent","userIdToRoomIds","targetUserId","roomIds","indexOfRoomId","mxcUrlToHttp","mxcUrl","useAuthentication","allowDirectLinks","allowRedirects","width","height","src","decryptContent","encryptedContent","downloadMedia","URL_REG","EMAIL_REGEX","URL_NEG_LB","VARIATION_SELECTOR_PATTERN","EMOJI_PATTERN","JUMBO_EMOJI_REG","accessToken","deviceId","ErrorCode","AFTER_LOGIN_REDIRECT_PATH_KEY","getAfterLoginRedirectPath","deleteAfterLoginRedirectPath","joinPathComponent","withSearchParam","searchParam","encodeSearchParamValueArray","decodeSearchParamValueArray","idsParam","hashRouterConfig","getAppPathFromHref","href","baseHashIndex","appPath","hrefHashIndex","getLoginPath","generatePath","getRegisterPath","REGISTER_PATH","getResetPasswordPath","RESET_PASSWORD_PATH","getHomePath","HOME_PATH","getHomeSearchPath","roomIdOrAlias","HOME_ROOM_PATH","getDirectPath","DIRECT_ROOM_PATH","spaceIdOrAlias","SPACE_PATH","SPACE_LOBBY_PATH","getSpaceSearchPath","SPACE_SEARCH_PATH","getSpaceRoomPath","SPACE_ROOM_PATH","getExplorePath","EXPLORE_PATH","getExploreFeaturedPath","getExploreServerPath","getInboxNotificationsPath","INBOX_NOTIFICATIONS_PATH","getInboxInvitesPath","INBOX_INVITES_PATH","clientAllowedServer","clientConfig","discoveryInfo","discovery","mxIdBaseUrl","LoginError","login","serverBaseUrl","useLoginComplete","navigate","loginBaseUrl","loginRes","afterLoginRedirectUrl","UseStateProvider","paddingRight","visible","FieldError","Box","UsernameHint","handleOpenMenu","defaultEmail","useAuthServer","useClientConfig","loginState","handleUsernameLogin","username","password","handleMxIdLogin","mxId","mxIdUsername","mxIdServer","handleEmailLogin","email","startLogin","handleSubmit","usernameInput","passwordInput","defaultUsername","PasswordInput","Link","Overlay","OverlayBackdrop","SSOLogin","useMemo","createClient","getSSOIdUrl","ssoId","renderAsIcons","providers","provider","saveScreenSpace","buttonTitle","AvatarImage","iconUrl","TokenLogin","token","LoginTokenError","OrDivider","hashRouter","origin","getLoginTokenSearchParam","useLoginSearchParams","searchParams","Login","loginFlows","useAuthFlows","useSearchParams","loginSearchParams","ssoRedirectUrl","absoluteLoginPath","usePathWithOrigin","parsedFlows","PasswordLoginForm","getSupportedUIAFlows","uiaFlows","stage","supportedStages","getUIACompleted","authData","getUIAParams","getUIASession","getUIAErrorCode","getUIAFlowForStages","stages","matchedFlows","flow","AuthType","requiredStageInFlows","getLoginTermUrl","terms","langToPolicy","firstKey","useUIACompleted","useUIAParams","useUIASession","getUIAError","useUIAFlow","uiaFlow","completed","session","errorCode","useUIAErrorCode","useUIAError","getStageToComplete","nextStage","hasStage","stageType","getStageInfo","RegisterError","register","requestData","useNavigate","updateLocalStore","afterLoginRedirectPath","userServer","DummyErrorDialog","title","onCancel","stageData","submitAuthDict","EmailErrorDialog","onRetry","handleFormSubmit","retryEmailInput","EmailStageDialog","clientSecret","emailTokenState","requestEmailToken","sessionId","threepIDCreds","handleEmailSubmit","userEmail","_objectWithoutPropertiesLoose","excluded","sourceKeys","_inheritsLoose","ReCAPTCHA","grecaptcha","wrapper","temporaryNode","_this$props","childProps"],"sources":["../../node_modules/react/cjs/react.production.min.js","../../node_modules/react/index.js","../../node_modules/react/cjs/react-jsx-runtime.production.min.js","../../node_modules/react-dom/cjs/react-dom.production.min.js","../../node_modules/classnames/index.js","../../node_modules/folds/dist/index.js","../../node_modules/events/events.js","../../node_modules/fbjs/lib/invariant.js","../../node_modules/flux/lib/Dispatcher.js","../../node_modules/flux/index.js","../../src/client/dispatcher.js","../../src/client/state/cons.js","../../src/client/state/settings.js","../../src/app/utils/common.ts","../../node_modules/jotai/esm/vanilla.mjs","../../node_modules/jotai/esm/react.mjs","../../node_modules/@remix-run/router/dist/router.js","../../node_modules/react-router/dist/index.js","../../node_modules/react-router-dom/dist/index.js","../../node_modules/tabbable/dist/index.esm.js","../../node_modules/focus-trap/dist/focus-trap.esm.js","../../node_modules/focus-trap-react/dist/focus-trap-react.js","../../src/app/hooks/useDebounce.ts","../../node_modules/is-hotkey/lib/index.js","../../src/app/utils/keyboard.ts","../../src/app/pages/auth/ServerPicker.tsx","../../node_modules/await-to-js/dist/await-to-js.es5.js","../../src/app/cs-api.ts","../../src/app/components/SpecVersionsLoader.tsx","../../src/app/hooks/useSpecVersions.ts","../../src/app/hooks/useAutoDiscoveryInfo.ts","../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../../node_modules/@babel/runtime/helpers/esm/typeof.js","../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../node_modules/loglevel/lib/loglevel.js","../../node_modules/matrix-js-sdk/lib/logger.js","../../node_modules/unhomoglyph/index.js","../../node_modules/retry/lib/retry_operation.js","../../node_modules/retry/lib/retry.js","../../node_modules/retry/index.js","../../node_modules/p-retry/index.js","../../node_modules/matrix-js-sdk/lib/NamespacedValue.js","../../node_modules/matrix-events-sdk/lib/NamespacedMap.js","../../node_modules/matrix-events-sdk/lib/InvalidEventError.js","../../node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js","../../node_modules/matrix-events-sdk/lib/types.js","../../node_modules/matrix-events-sdk/lib/NamespacedValue.js","../../node_modules/matrix-events-sdk/lib/events/PollStartEvent.js","../../node_modules/matrix-events-sdk/lib/ExtensibleEvents.js","../../node_modules/matrix-events-sdk/lib/IPartialEvent.js","../../node_modules/matrix-events-sdk/lib/utility/MessageMatchers.js","../../node_modules/matrix-events-sdk/lib/index.js","../../node_modules/matrix-js-sdk/lib/models/event-timeline-set.js","../../node_modules/matrix-js-sdk/lib/models/event-status.js","../../node_modules/matrix-js-sdk/lib/models/room-summary.js","../../node_modules/matrix-js-sdk/lib/ReEmitter.js","../../node_modules/matrix-js-sdk/lib/@types/sync.js","../../node_modules/matrix-js-sdk/lib/filter-component.js","../../node_modules/matrix-js-sdk/lib/filter.js","../../node_modules/matrix-js-sdk/lib/@types/topic.js","../../node_modules/matrix-js-sdk/lib/content-helpers.js","../../node_modules/matrix-js-sdk/lib/models/beacon.js","../../node_modules/matrix-js-sdk/lib/models/read-receipt.js","../../node_modules/matrix-js-sdk/lib/models/poll.js","../../node_modules/matrix-js-sdk/lib/models/room-receipts.js","../../node_modules/matrix-js-sdk/lib/models/compare-event-ordering.js","../../node_modules/matrix-js-sdk/lib/http-api/method.js","../../node_modules/matrix-js-sdk/lib/http-api/errors.js","../../node_modules/matrix-js-sdk/lib/http-api/interface.js","../../node_modules/content-type/index.js","../../node_modules/sdp-transform/lib/writer.js","../../node_modules/sdp-transform/lib/index.js","../../node_modules/base64-js/index.js","../../node_modules/buffer/index.js","../../node_modules/another-json/another-json.js","../../node_modules/matrix-js-sdk/lib/client.js","../../node_modules/matrix-widget-api/lib/models/WidgetEventCapability.js","../../node_modules/matrix-widget-api/lib/util/SimpleObservable.js","../../node_modules/matrix-widget-api/lib/ClientWidgetApi.js","../../node_modules/matrix-widget-api/lib/models/WidgetParser.js","../../src/app/utils/room.ts","../../src/app/utils/matrix.ts","../../src/app/utils/regex.ts","../../src/client/action/auth.ts","../../src/app/cs-errorcode.ts","../../src/app/pages/afterLoginRedirectPath.ts","../../src/app/pages/pathUtils.ts","../../src/app/pages/auth/login/loginUtil.ts","../../src/app/components/UseStateProvider.tsx","../../src/app/components/password-input/PasswordInput.tsx","../../src/app/pages/auth/FiledError.tsx","../../src/app/pages/auth/login/PasswordLoginForm.tsx","../../src/app/pages/auth/SSOLogin.tsx","../../src/app/pages/auth/login/TokenLogin.tsx","../../src/app/pages/auth/OrDivider.tsx","../../src/app/hooks/usePathWithOrigin.ts","../../src/app/pages/auth/login/Login.tsx","../../src/app/utils/matrix-uia.ts","../../src/app/hooks/useUIAFlows.ts","../../src/app/pages/auth/register/registerUtil.ts","../../src/app/components/uia-stages/DummyStage.tsx","../../src/app/components/uia-stages/EmailStage.tsx","../../node_modules/react-google-recaptcha/lib/esm/recaptcha.js"],"sourcesContent":["/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version=\"18.2.0\";\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n'use strict';var aa=require(\"react\"),ca=require(\"scheduler\");function p(a){for(var b=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=1;c<arguments.length;c++)b+=\"&args[]=\"+encodeURIComponent(arguments[c]);return\"Minified React error #\"+a+\"; visit \"+b+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+\"Capture\",b)}\nfunction ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}\nvar ia=!(\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,la=\n{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case \"function\":case \"symbol\":return!0;case \"boolean\":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return\"data-\"!==a&&\"aria-\"!==a;default:return!1}}\nfunction qa(a,b,c,d){if(null===b||\"undefined\"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};\n\"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[[\"acceptCharset\",\"accept-charset\"],[\"className\",\"class\"],[\"htmlFor\",\"for\"],[\"httpEquiv\",\"http-equiv\"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});[\"contentEditable\",\"draggable\",\"spellCheck\",\"value\"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});\n[\"autoReverse\",\"externalResourcesRequired\",\"focusable\",\"preserveAlpha\"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});\"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});\n[\"checked\",\"multiple\",\"muted\",\"selected\"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});[\"capture\",\"download\"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});[\"cols\",\"rows\",\"size\",\"span\"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});[\"rowSpan\",\"start\"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(a){var b=a.replace(ra,\nsa);z[b]=new v(b,1,!1,a,null,!1,!1)});\"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/1999/xlink\",!1,!1)});[\"xml:base\",\"xml:lang\",\"xml:space\"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/XML/1998/namespace\",!1,!1)});[\"tabIndex\",\"crossOrigin\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});\nz.xlinkHref=new v(\"xlinkHref\",1,!1,\"xlink:href\",\"http://www.w3.org/1999/xlink\",!0,!1);[\"src\",\"href\",\"action\",\"formAction\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||\"o\"!==b[0]&&\"O\"!==b[0]||\"n\"!==b[1]&&\"N\"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,\"\"+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:\"\":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?\"\":\"\"+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}\nvar ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for(\"react.element\"),wa=Symbol.for(\"react.portal\"),ya=Symbol.for(\"react.fragment\"),za=Symbol.for(\"react.strict_mode\"),Aa=Symbol.for(\"react.profiler\"),Ba=Symbol.for(\"react.provider\"),Ca=Symbol.for(\"react.context\"),Da=Symbol.for(\"react.forward_ref\"),Ea=Symbol.for(\"react.suspense\"),Fa=Symbol.for(\"react.suspense_list\"),Ga=Symbol.for(\"react.memo\"),Ha=Symbol.for(\"react.lazy\");Symbol.for(\"react.scope\");Symbol.for(\"react.debug_trace_mode\");\nvar Ia=Symbol.for(\"react.offscreen\");Symbol.for(\"react.legacy_hidden\");Symbol.for(\"react.cache\");Symbol.for(\"react.tracing_marker\");var Ja=Symbol.iterator;function Ka(a){if(null===a||\"object\"!==typeof a)return null;a=Ja&&a[Ja]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);La=b&&b[1]||\"\"}return\"\\n\"+La+a}var Na=!1;\nfunction Oa(a,b){if(!a||Na)return\"\";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,\"props\",{set:function(){throw Error();}}),\"object\"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&\"string\"===typeof l.stack){for(var e=l.stack.split(\"\\n\"),\nf=d.stack.split(\"\\n\"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k=\"\\n\"+e[g].replace(\" at new \",\" at \");a.displayName&&k.includes(\"<anonymous>\")&&(k=k.replace(\"<anonymous>\",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:\"\")?Ma(a):\"\"}\nfunction Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma(\"Lazy\");case 13:return Ma(\"Suspense\");case 19:return Ma(\"SuspenseList\");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return\"\"}}\nfunction Qa(a){if(null==a)return null;if(\"function\"===typeof a)return a.displayName||a.name||null;if(\"string\"===typeof a)return a;switch(a){case ya:return\"Fragment\";case wa:return\"Portal\";case Aa:return\"Profiler\";case za:return\"StrictMode\";case Ea:return\"Suspense\";case Fa:return\"SuspenseList\"}if(\"object\"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||\"Context\")+\".Consumer\";case Ba:return(a._context.displayName||\"Context\")+\".Provider\";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||\nb.name||\"\",a=\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||\"Memo\";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}\nfunction Ra(a){var b=a.type;switch(a.tag){case 24:return\"Cache\";case 9:return(b.displayName||\"Context\")+\".Consumer\";case 10:return(b._context.displayName||\"Context\")+\".Provider\";case 18:return\"DehydratedFragment\";case 11:return a=b.render,a=a.displayName||a.name||\"\",b.displayName||(\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");case 7:return\"Fragment\";case 5:return b;case 4:return\"Portal\";case 3:return\"Root\";case 6:return\"Text\";case 16:return Qa(b);case 8:return b===za?\"StrictMode\":\"Mode\";case 22:return\"Offscreen\";\ncase 12:return\"Profiler\";case 21:return\"Scope\";case 13:return\"Suspense\";case 19:return\"SuspenseList\";case 25:return\"TracingMarker\";case 1:case 0:case 17:case 2:case 14:case 15:if(\"function\"===typeof b)return b.displayName||b.name||null;if(\"string\"===typeof b)return b}return null}function Sa(a){switch(typeof a){case \"boolean\":case \"number\":case \"string\":case \"undefined\":return a;case \"object\":return a;default:return\"\"}}\nfunction Ta(a){var b=a.type;return(a=a.nodeName)&&\"input\"===a.toLowerCase()&&(\"checkbox\"===b||\"radio\"===b)}\nfunction Ua(a){var b=Ta(a)?\"checked\":\"value\",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=\"\"+a[b];if(!a.hasOwnProperty(b)&&\"undefined\"!==typeof c&&\"function\"===typeof c.get&&\"function\"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=\"\"+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=\"\"+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d=\"\";a&&(d=Ta(a)?a.checked?\"true\":\"false\":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||(\"undefined\"!==typeof document?document:void 0);if(\"undefined\"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?\"\":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:\"checkbox\"===b.type||\"radio\"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,\"checked\",b,!1)}\nfunction bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if(\"number\"===d){if(0===c&&\"\"===a.value||a.value!=c)a.value=\"\"+c}else a.value!==\"\"+c&&(a.value=\"\"+c);else if(\"submit\"===d||\"reset\"===d){a.removeAttribute(\"value\");return}b.hasOwnProperty(\"value\")?cb(a,b.type,c):b.hasOwnProperty(\"defaultValue\")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction db(a,b,c){if(b.hasOwnProperty(\"value\")||b.hasOwnProperty(\"defaultValue\")){var d=b.type;if(!(\"submit\"!==d&&\"reset\"!==d||void 0!==b.value&&null!==b.value))return;b=\"\"+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;\"\"!==c&&(a.name=\"\");a.defaultChecked=!!a._wrapperState.initialChecked;\"\"!==c&&(a.name=c)}\nfunction cb(a,b,c){if(\"number\"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=\"\"+a._wrapperState.initialValue:a.defaultValue!==\"\"+c&&(a.defaultValue=\"\"+c)}var eb=Array.isArray;\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b[\"$\"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty(\"$\"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=\"\"+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:\"\"+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b=\"\");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=\"\"+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=\"\"+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&\"\"!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case \"svg\":return\"http://www.w3.org/2000/svg\";case \"math\":return\"http://www.w3.org/1998/Math/MathML\";default:return\"http://www.w3.org/1999/xhtml\"}}\nfunction lb(a,b){return null==a||\"http://www.w3.org/1999/xhtml\"===a?kb(b):\"http://www.w3.org/2000/svg\"===a&&\"foreignObject\"===b?\"http://www.w3.org/1999/xhtml\":a}\nvar mb,nb=function(a){return\"undefined\"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(\"http://www.w3.org/2000/svg\"!==a.namespaceURI||\"innerHTML\"in a)a.innerHTML=b;else{mb=mb||document.createElement(\"div\");mb.innerHTML=\"<svg>\"+b.valueOf().toString()+\"</svg>\";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,\nzoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=[\"Webkit\",\"ms\",\"Moz\",\"O\"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||\"boolean\"===typeof b||\"\"===b?\"\":c||\"number\"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(\"\"+b).trim():b+\"px\"}\nfunction sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf(\"--\"),e=rb(c,b[c],d);\"float\"===c&&(c=\"cssFloat\");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if(\"object\"!==typeof b.dangerouslySetInnerHTML||!(\"__html\"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&\"object\"!==typeof b.style)throw Error(p(62));}}\nfunction vb(a,b){if(-1===a.indexOf(\"-\"))return\"string\"===typeof b.is;switch(a){case \"annotation-xml\":case \"color-profile\":case \"font-face\":case \"font-face-src\":case \"font-face-uri\":case \"font-face-format\":case \"font-face-name\":case \"missing-glyph\":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if(\"function\"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}\nfunction Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case \"onClick\":case \"onClickCapture\":case \"onDoubleClick\":case \"onDoubleClickCapture\":case \"onMouseDown\":case \"onMouseDownCapture\":case \"onMouseMove\":case \"onMouseMoveCapture\":case \"onMouseUp\":case \"onMouseUpCapture\":case \"onMouseEnter\":(d=!d.disabled)||(a=a.type,d=!(\"button\"===a||\"input\"===a||\"select\"===a||\"textarea\"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&\"function\"!==\ntypeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,\"passive\",{get:function(){Lb=!0}});window.addEventListener(\"test\",Mb,Mb);window.removeEventListener(\"test\",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}\nfunction Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}\nfunction Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}\nvar ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&\"function\"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}\nvar oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;\nfunction tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;\ndefault:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}\nfunction wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}\nfunction Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc=\"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit\".split(\" \");\nfunction Sc(a,b){switch(a){case \"focusin\":case \"focusout\":Lc=null;break;case \"dragenter\":case \"dragleave\":Mc=null;break;case \"mouseover\":case \"mouseout\":Nc=null;break;case \"pointerover\":case \"pointerout\":Oc.delete(b.pointerId);break;case \"gotpointercapture\":case \"lostpointercapture\":Pc.delete(b.pointerId)}}\nfunction Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction Uc(a,b,c,d,e){switch(b){case \"focusin\":return Lc=Tc(Lc,a,b,c,d,e),!0;case \"dragenter\":return Mc=Tc(Mc,a,b,c,d,e),!0;case \"mouseover\":return Nc=Tc(Nc,a,b,c,d,e),!0;case \"pointerover\":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case \"gotpointercapture\":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}\nfunction ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}\nfunction bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;\nfunction ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}\nfunction fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;\nfunction Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}\nfunction jd(a){switch(a){case \"cancel\":case \"click\":case \"close\":case \"contextmenu\":case \"copy\":case \"cut\":case \"auxclick\":case \"dblclick\":case \"dragend\":case \"dragstart\":case \"drop\":case \"focusin\":case \"focusout\":case \"input\":case \"invalid\":case \"keydown\":case \"keypress\":case \"keyup\":case \"mousedown\":case \"mouseup\":case \"paste\":case \"pause\":case \"play\":case \"pointercancel\":case \"pointerdown\":case \"pointerup\":case \"ratechange\":case \"reset\":case \"resize\":case \"seeked\":case \"submit\":case \"touchcancel\":case \"touchend\":case \"touchstart\":case \"volumechange\":case \"change\":case \"selectionchange\":case \"textInput\":case \"compositionstart\":case \"compositionend\":case \"compositionupdate\":case \"beforeblur\":case \"afterblur\":case \"beforeinput\":case \"blur\":case \"fullscreenchange\":case \"focus\":case \"hashchange\":case \"popstate\":case \"select\":case \"selectstart\":return 1;case \"drag\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"mousemove\":case \"mouseout\":case \"mouseover\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"scroll\":case \"toggle\":case \"touchmove\":case \"wheel\":case \"mouseenter\":case \"mouseleave\":case \"pointerenter\":case \"pointerleave\":return 4;\ncase \"message\":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e=\"value\"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}\nfunction od(a){var b=a.keyCode;\"charCode\"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():\"unknown\"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():\"unknown\"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if(\"movementX\"in\na)return a.movementX;a!==yd&&(yd&&\"mousemove\"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return\"movementY\"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return\"clipboardData\"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:\"Escape\",\nSpacebar:\" \",Left:\"ArrowLeft\",Up:\"ArrowUp\",Right:\"ArrowRight\",Down:\"ArrowDown\",Del:\"Delete\",Win:\"OS\",Menu:\"ContextMenu\",Apps:\"ContextMenu\",Scroll:\"ScrollLock\",MozPrintableKey:\"Unidentified\"},Nd={8:\"Backspace\",9:\"Tab\",12:\"Clear\",13:\"Enter\",16:\"Shift\",17:\"Control\",18:\"Alt\",19:\"Pause\",20:\"CapsLock\",27:\"Escape\",32:\" \",33:\"PageUp\",34:\"PageDown\",35:\"End\",36:\"Home\",37:\"ArrowLeft\",38:\"ArrowUp\",39:\"ArrowRight\",40:\"ArrowDown\",45:\"Insert\",46:\"Delete\",112:\"F1\",113:\"F2\",114:\"F3\",115:\"F4\",116:\"F5\",117:\"F6\",118:\"F7\",\n119:\"F8\",120:\"F9\",121:\"F10\",122:\"F11\",123:\"F12\",144:\"NumLock\",145:\"ScrollLock\",224:\"Meta\"},Od={Alt:\"altKey\",Control:\"ctrlKey\",Meta:\"metaKey\",Shift:\"shiftKey\"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if(\"Unidentified\"!==b)return b}return\"keypress\"===a.type?(a=od(a),13===a?\"Enter\":String.fromCharCode(a)):\"keydown\"===a.type||\"keyup\"===a.type?Nd[a.keyCode]||\"Unidentified\":\"\"},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return\"keypress\"===a.type?od(a):0},keyCode:function(a){return\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0},which:function(a){return\"keypress\"===\na.type?od(a):\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return\"deltaX\"in a?a.deltaX:\"wheelDeltaX\"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return\"deltaY\"in a?a.deltaY:\"wheelDeltaY\"in a?-a.wheelDeltaY:\"wheelDelta\"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&\"CompositionEvent\"in window,be=null;ia&&\"documentMode\"in document&&(be=document.documentMode);var ce=ia&&\"TextEvent\"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case \"keyup\":return-1!==$d.indexOf(b.keyCode);case \"keydown\":return 229!==b.keyCode;case \"keypress\":case \"mousedown\":case \"focusout\":return!0;default:return!1}}function he(a){a=a.detail;return\"object\"===typeof a&&\"data\"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case \"compositionend\":return he(b);case \"keypress\":if(32!==b.which)return null;fe=!0;return ee;case \"textInput\":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return\"compositionend\"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case \"paste\":return null;case \"keypress\":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case \"compositionend\":return de&&\"ko\"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,\"datetime-local\":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return\"input\"===b?!!le[a.type]:\"textarea\"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,\"onChange\");0<b.length&&(c=new td(\"onChange\",\"change\",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if(\"change\"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye=\"oninput\"in document;if(!ye){var ze=document.createElement(\"div\");ze.setAttribute(\"oninput\",\"return;\");ye=\"function\"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent(\"onpropertychange\",Be),qe=pe=null)}function Be(a){if(\"value\"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}\nfunction Ce(a,b,c){\"focusin\"===a?(Ae(),pe=b,qe=c,pe.attachEvent(\"onpropertychange\",Be)):\"focusout\"===a&&Ae()}function De(a){if(\"selectionchange\"===a||\"keyup\"===a||\"keydown\"===a)return te(qe)}function Ee(a,b){if(\"click\"===a)return te(b)}function Fe(a,b){if(\"input\"===a||\"change\"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He=\"function\"===typeof Object.is?Object.is:Ge;\nfunction Ie(a,b){if(He(a,b))return!0;if(\"object\"!==typeof a||null===a||\"object\"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):\"contains\"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c=\"string\"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&(\"input\"===b&&(\"text\"===a.type||\"search\"===a.type||\"tel\"===a.type||\"url\"===a.type||\"password\"===a.type)||\"textarea\"===b||\"true\"===a.contentEditable)}\nfunction Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),\"selectionStart\"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,\nd);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});\"function\"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}\nvar Pe=ia&&\"documentMode\"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,\"selectionStart\"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,\"onSelect\"),0<d.length&&(b=new td(\"onSelect\",\"select\",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nfunction Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c[\"Webkit\"+a]=\"webkit\"+b;c[\"Moz\"+a]=\"moz\"+b;return c}var We={animationend:Ve(\"Animation\",\"AnimationEnd\"),animationiteration:Ve(\"Animation\",\"AnimationIteration\"),animationstart:Ve(\"Animation\",\"AnimationStart\"),transitionend:Ve(\"Transition\",\"TransitionEnd\")},Xe={},Ye={};\nia&&(Ye=document.createElement(\"div\").style,\"AnimationEvent\"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),\"TransitionEvent\"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze(\"animationend\"),af=Ze(\"animationiteration\"),bf=Ze(\"animationstart\"),cf=Ze(\"transitionend\"),df=new Map,ef=\"abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\" \");\nfunction ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,\"on\"+kf)}ff($e,\"onAnimationEnd\");ff(af,\"onAnimationIteration\");ff(bf,\"onAnimationStart\");ff(\"dblclick\",\"onDoubleClick\");ff(\"focusin\",\"onFocus\");ff(\"focusout\",\"onBlur\");ff(cf,\"onTransitionEnd\");ha(\"onMouseEnter\",[\"mouseout\",\"mouseover\"]);ha(\"onMouseLeave\",[\"mouseout\",\"mouseover\"]);ha(\"onPointerEnter\",[\"pointerout\",\"pointerover\"]);\nha(\"onPointerLeave\",[\"pointerout\",\"pointerover\"]);fa(\"onChange\",\"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));fa(\"onSelect\",\"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));fa(\"onBeforeInput\",[\"compositionend\",\"keypress\",\"textInput\",\"paste\"]);fa(\"onCompositionEnd\",\"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));fa(\"onCompositionStart\",\"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));\nfa(\"onCompositionUpdate\",\"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));var lf=\"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"),mf=new Set(\"cancel close invalid load scroll toggle\".split(\" \").concat(lf));\nfunction nf(a,b,c){var d=a.type||\"unknown-event\";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}\nfunction D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+\"__bubble\";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf=\"_reactListening\"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){\"selectionchange\"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf(\"selectionchange\",!1,b))}}\nfunction pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||\"touchstart\"!==b&&\"touchmove\"!==b&&\"wheel\"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];\na:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case \"keypress\":if(0===od(c))break a;case \"keydown\":case \"keyup\":k=Rd;break;case \"focusin\":n=\"focus\";k=Fd;break;case \"focusout\":n=\"blur\";k=Fd;break;case \"beforeblur\":case \"afterblur\":k=Fd;break;case \"click\":if(2===c.button)break a;case \"auxclick\":case \"dblclick\":case \"mousedown\":case \"mousemove\":case \"mouseup\":case \"mouseout\":case \"mouseover\":case \"contextmenu\":k=Bd;break;case \"drag\":case \"dragend\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"dragstart\":case \"drop\":k=\nDd;break;case \"touchcancel\":case \"touchend\":case \"touchmove\":case \"touchstart\":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case \"scroll\":k=vd;break;case \"wheel\":k=Zd;break;case \"copy\":case \"cut\":case \"paste\":k=Jd;break;case \"gotpointercapture\":case \"lostpointercapture\":case \"pointercancel\":case \"pointerdown\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"pointerup\":k=Td}var t=0!==(b&4),J=!t&&\"scroll\"===a,x=t?null!==h?h+\"Capture\":null:h;t=[];for(var w=d,u;null!==\nw;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h=\"mouseover\"===a||\"pointerover\"===a;k=\"mouseout\"===a||\"pointerout\"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==\nn&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F=\"onMouseLeave\";x=\"onMouseEnter\";w=\"mouse\";if(\"pointerout\"===a||\"pointerover\"===a)t=Td,F=\"onPointerLeave\",x=\"onPointerEnter\",w=\"pointer\";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+\"leave\",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+\"enter\",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=\nvf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if(\"select\"===k||\"input\"===k&&\"file\"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&\"input\"===k.toLowerCase()&&(\"checkbox\"===h.type||\"radio\"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);\"focusout\"===a&&(xa=h._wrapperState)&&\nxa.controlled&&\"number\"===h.type&&cb(h,\"number\",h.value)}xa=d?ue(d):window;switch(a){case \"focusin\":if(me(xa)||\"true\"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case \"focusout\":Se=Re=Qe=null;break;case \"mousedown\":Te=!0;break;case \"contextmenu\":case \"mouseup\":case \"dragend\":Te=!1;Ue(g,c,e);break;case \"selectionchange\":if(Pe)break;case \"keydown\":case \"keyup\":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case \"compositionstart\":var ba=\"onCompositionStart\";break b;case \"compositionend\":ba=\"onCompositionEnd\";\nbreak b;case \"compositionupdate\":ba=\"onCompositionUpdate\";break b}ba=void 0}else ie?ge(a,c)&&(ba=\"onCompositionEnd\"):\"keydown\"===a&&229===c.keyCode&&(ba=\"onCompositionStart\");ba&&(de&&\"ko\"!==c.locale&&(ie||\"onCompositionStart\"!==ba?\"onCompositionEnd\"===ba&&ie&&($a=nd()):(kd=e,ld=\"value\"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,\"onBeforeInput\"),\n0<d.length&&(e=new Ld(\"onBeforeInput\",\"beforeinput\",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+\"Capture\",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\\r\\n?/g,yf=/\\u0000|\\uFFFD/g;function zf(a){return(\"string\"===typeof a?a:\"\"+a).replace(xf,\"\\n\").replace(yf,\"\")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}\nvar Cf=null,Df=null;function Ef(a,b){return\"textarea\"===a||\"noscript\"===a||\"string\"===typeof b.children||\"number\"===typeof b.children||\"object\"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}\nvar Ff=\"function\"===typeof setTimeout?setTimeout:void 0,Gf=\"function\"===typeof clearTimeout?clearTimeout:void 0,Hf=\"function\"===typeof Promise?Promise:void 0,Jf=\"function\"===typeof queueMicrotask?queueMicrotask:\"undefined\"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}\nfunction Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,\"/$\"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else\"$\"!==c&&\"$?\"!==c&&\"$!\"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if(\"$\"===b||\"$!\"===b||\"$?\"===b)break;if(\"/$\"===b)return null}}return a}\nfunction Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(\"$\"===c||\"$!\"===c||\"$?\"===c){if(0===b)return a;b--}else\"/$\"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of=\"__reactFiber$\"+Nf,Pf=\"__reactProps$\"+Nf,uf=\"__reactContainer$\"+Nf,of=\"__reactEvents$\"+Nf,Qf=\"__reactListeners$\"+Nf,Rf=\"__reactHandles$\"+Nf;\nfunction Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}\nfunction E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}\nfunction Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if(\"function\"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||\"Unknown\",e));return A({},c,d)}\nfunction cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}\nfunction jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg=\"\";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}\nfunction ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;\nfunction Ag(a,b){var c=Bg(5,null,null,0);c.elementType=\"DELETED\";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}\nfunction Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=\"\"===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=\nnull,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}\nfunction Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b=\"head\"!==b&&\"body\"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(\"/$\"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else\"$\"!==c&&\"$!\"!==c&&\"$?\"!==c||b++}a=a.nextSibling}yg=\nnull}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;function Lg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var Mg=Uf(null),Ng=null,Og=null,Pg=null;function Qg(){Pg=Og=Ng=null}function Rg(a){var b=Mg.current;E(Mg);a._currentValue=b}\nfunction Sg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function Tg(a,b){Ng=a;Pg=Og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(Ug=!0),a.firstContext=null)}\nfunction Vg(a){var b=a._currentValue;if(Pg!==a)if(a={context:a,memoizedValue:b,next:null},null===Og){if(null===Ng)throw Error(p(308));Og=a;Ng.dependencies={lanes:0,firstContext:a}}else Og=Og.next=a;return b}var Wg=null;function Xg(a){null===Wg?Wg=[a]:Wg.push(a)}function Yg(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,Xg(b)):(c.next=e.next,e.next=c);b.interleaved=c;return Zg(a,d)}\nfunction Zg(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var $g=!1;function ah(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}\nfunction bh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function ch(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}\nfunction dh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return Zg(a,c)}e=d.interleaved;null===e?(b.next=b,Xg(d)):(b.next=e.next,e.next=b);d.interleaved=b;return Zg(a,c)}function eh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nfunction fh(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction gh(a,b,c,d){var e=a.updateQueue;$g=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,\nnext:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if(\"function\"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r=\"function\"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:$g=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;\nh=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);hh|=g;a.lanes=g;a.memoizedState=q}}\nfunction ih(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if(\"function\"!==typeof e)throw Error(p(191,e));e.call(d)}}}var jh=(new aa.Component).refs;function kh(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar nh={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=L(),d=\nlh(a),e=ch(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=dh(a,e,d);null!==b&&(mh(b,a,d,c),eh(b,a,d))}};function oh(a,b,c,d,e,f,g){a=a.stateNode;return\"function\"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}\nfunction ph(a,b,c){var d=!1,e=Vf;var f=b.contextType;\"object\"===typeof f&&null!==f?f=Vg(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=nh;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction qh(a,b,c,d){a=b.state;\"function\"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);\"function\"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&nh.enqueueReplaceState(b,b.state,null)}\nfunction rh(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jh;ah(a);var f=b.contextType;\"object\"===typeof f&&null!==f?e.context=Vg(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;\"function\"===typeof f&&(kh(a,b,f,c),e.state=a.memoizedState);\"function\"===typeof b.getDerivedStateFromProps||\"function\"===typeof e.getSnapshotBeforeUpdate||\"function\"!==typeof e.UNSAFE_componentWillMount&&\"function\"!==typeof e.componentWillMount||(b=e.state,\n\"function\"===typeof e.componentWillMount&&e.componentWillMount(),\"function\"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&nh.enqueueReplaceState(e,e.state,null),gh(a,c,e,d),e.state=a.memoizedState);\"function\"===typeof e.componentDidMount&&(a.flags|=4194308)}\nfunction sh(a,b,c){a=c.ref;if(null!==a&&\"function\"!==typeof a&&\"object\"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=\"\"+a;if(null!==b&&null!==b.ref&&\"function\"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===jh&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if(\"string\"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}\nfunction th(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,\"[object Object]\"===a?\"object with keys {\"+Object.keys(b).join(\", \")+\"}\":a));}function uh(a){var b=a._init;return b(a._payload)}\nfunction vh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=wh(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&\nnull===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=xh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||\"object\"===typeof f&&null!==f&&f.$$typeof===Ha&&uh(f)===b.type))return d=e(b,c.props),d.ref=sh(a,b,c),d.return=a,d;d=yh(c.type,c.key,c.props,null,a.mode,d);d.ref=sh(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||\nb.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=zh(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ah(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if(\"string\"===typeof b&&\"\"!==b||\"number\"===typeof b)return b=xh(\"\"+b,a.mode,c),b.return=a,b;if(\"object\"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=yh(b.type,b.key,b.props,null,a.mode,c),\nc.ref=sh(a,null,b),c.return=a,c;case wa:return b=zh(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Ah(b,a.mode,c,null),b.return=a,b;th(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if(\"string\"===typeof c&&\"\"!==c||\"number\"===typeof c)return null!==e?null:h(a,b,\"\"+c,d);if(\"object\"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,\nb,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);th(a,c)}return null}function y(a,b,c,d,e){if(\"string\"===typeof d&&\"\"!==d||\"number\"===typeof d)return a=a.get(c)||null,h(b,a,\"\"+d,e);if(\"object\"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);th(b,d)}return null}\nfunction n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===\nx.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if(\"function\"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,\nm),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){\"object\"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if(\"object\"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=\nf.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||\"object\"===typeof k&&null!==k&&k.$$typeof===Ha&&uh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=sh(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Ah(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=yh(f.type,f.key,f.props,null,a.mode,h),h.ref=sh(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==\nd;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=zh(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);th(a,f)}return\"string\"===typeof f&&\"\"!==f||\"number\"===typeof f?(f=\"\"+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):\n(c(a,d),d=xh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Bh=vh(!0),Ch=vh(!1),Dh={},Eh=Uf(Dh),Fh=Uf(Dh),Gh=Uf(Dh);function Hh(a){if(a===Dh)throw Error(p(174));return a}function Ih(a,b){G(Gh,b);G(Fh,a);G(Eh,Dh);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,\"\");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(Eh);G(Eh,b)}function Jh(){E(Eh);E(Fh);E(Gh)}\nfunction Kh(a){Hh(Gh.current);var b=Hh(Eh.current);var c=lb(b,a.type);b!==c&&(G(Fh,a),G(Eh,c))}function Lh(a){Fh.current===a&&(E(Eh),E(Fh))}var M=Uf(0);\nfunction Mh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||\"$?\"===c.data||\"$!\"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Nh=[];\nfunction Oh(){for(var a=0;a<Nh.length;a++)Nh[a]._workInProgressVersionPrimary=null;Nh.length=0}var Ph=ua.ReactCurrentDispatcher,Qh=ua.ReactCurrentBatchConfig,Rh=0,N=null,O=null,P=null,Sh=!1,Th=!1,Uh=0,Vh=0;function Q(){throw Error(p(321));}function Wh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Xh(a,b,c,d,e,f){Rh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Ph.current=null===a||null===a.memoizedState?Yh:Zh;a=c(d,e);if(Th){f=0;do{Th=!1;Uh=0;if(25<=f)throw Error(p(301));f+=1;P=O=null;b.updateQueue=null;Ph.current=$h;a=c(d,e)}while(Th)}Ph.current=ai;b=null!==O&&null!==O.next;Rh=0;P=O=N=null;Sh=!1;if(b)throw Error(p(300));return a}function bi(){var a=0!==Uh;Uh=0;return a}\nfunction ci(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function di(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(p(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}\nfunction ei(a,b){return\"function\"===typeof b?b(a):b}\nfunction fi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Rh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,\neagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;N.lanes|=m;hh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(Ug=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,N.lanes|=f,hh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}\nfunction gi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(Ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function hi(){}\nfunction ii(a,b){var c=N,d=di(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,Ug=!0);d=d.queue;ji(ki.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==P&&P.memoizedState.tag&1){c.flags|=2048;li(9,mi.bind(null,c,d,e,b),void 0,null);if(null===R)throw Error(p(349));0!==(Rh&30)||ni(c,b,e)}return e}function ni(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}\nfunction mi(a,b,c,d){b.value=c;b.getSnapshot=d;oi(b)&&pi(a)}function ki(a,b,c){return c(function(){oi(b)&&pi(a)})}function oi(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function pi(a){var b=Zg(a,1);null!==b&&mh(b,a,1,-1)}\nfunction qi(a){var b=ci();\"function\"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ei,lastRenderedState:a};b.queue=a;a=a.dispatch=ri.bind(null,N,a);return[b.memoizedState,a]}\nfunction li(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function si(){return di().memoizedState}function ti(a,b,c,d){var e=ci();N.flags|=a;e.memoizedState=li(1|b,c,void 0,void 0===d?null:d)}\nfunction ui(a,b,c,d){var e=di();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&Wh(d,g.deps)){e.memoizedState=li(b,c,f,d);return}}N.flags|=a;e.memoizedState=li(1|b,c,f,d)}function vi(a,b){return ti(8390656,8,a,b)}function ji(a,b){return ui(2048,8,a,b)}function wi(a,b){return ui(4,2,a,b)}function xi(a,b){return ui(4,4,a,b)}\nfunction yi(a,b){if(\"function\"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function zi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ui(4,4,yi.bind(null,b,a),c)}function Ai(){}function Bi(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction Ci(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Di(a,b,c){if(0===(Rh&21))return a.baseState&&(a.baseState=!1,Ug=!0),a.memoizedState=c;He(c,b)||(c=yc(),N.lanes|=c,hh|=c,a.baseState=!0);return b}function Ei(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Qh.transition;Qh.transition={};try{a(!1),b()}finally{C=c,Qh.transition=d}}function Fi(){return di().memoizedState}\nfunction Gi(a,b,c){var d=lh(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,c);else if(c=Yg(a,b,c,d),null!==c){var e=L();mh(c,a,d,e);Ji(c,b,d)}}\nfunction ri(a,b,c){var d=lh(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,Xg(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=Yg(a,b,e,d);null!==c&&(e=L(),mh(c,a,d,e),Ji(c,b,d))}}\nfunction Hi(a){var b=a.alternate;return a===N||null!==b&&b===N}function Ii(a,b){Th=Sh=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Ji(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nvar ai={readContext:Vg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useInsertionEffect:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useDeferredValue:Q,useTransition:Q,useMutableSource:Q,useSyncExternalStore:Q,useId:Q,unstable_isNewReconciler:!1},Yh={readContext:Vg,useCallback:function(a,b){ci().memoizedState=[a,void 0===b?null:b];return a},useContext:Vg,useEffect:vi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ti(4194308,\n4,yi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ti(4194308,4,a,b)},useInsertionEffect:function(a,b){return ti(4,2,a,b)},useMemo:function(a,b){var c=ci();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=ci();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=Gi.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=\nci();a={current:a};return b.memoizedState=a},useState:qi,useDebugValue:Ai,useDeferredValue:function(a){return ci().memoizedState=a},useTransition:function(){var a=qi(!1),b=a[0];a=Ei.bind(null,a[1]);ci().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=N,e=ci();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===R)throw Error(p(349));0!==(Rh&30)||ni(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;vi(ki.bind(null,d,\nf,a),[a]);d.flags|=2048;li(9,mi.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=ci(),b=R.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=\":\"+b+\"R\"+c;c=Uh++;0<c&&(b+=\"H\"+c.toString(32));b+=\":\"}else c=Vh++,b=\":\"+b+\"r\"+c.toString(32)+\":\";return a.memoizedState=b},unstable_isNewReconciler:!1},Zh={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:fi,useRef:si,useState:function(){return fi(ei)},\nuseDebugValue:Ai,useDeferredValue:function(a){var b=di();return Di(b,O.memoizedState,a)},useTransition:function(){var a=fi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1},$h={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:gi,useRef:si,useState:function(){return gi(ei)},useDebugValue:Ai,useDeferredValue:function(a){var b=di();return null===\nO?b.memoizedState=a:Di(b,O.memoizedState,a)},useTransition:function(){var a=gi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1};function Ki(a,b){try{var c=\"\",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e=\"\\nError generating stack: \"+f.message+\"\\n\"+f.stack}return{value:a,source:b,stack:e,digest:null}}function Li(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}\nfunction Mi(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Ni=\"function\"===typeof WeakMap?WeakMap:Map;function Oi(a,b,c){c=ch(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Pi||(Pi=!0,Qi=d);Mi(a,b)};return c}\nfunction Ri(a,b,c){c=ch(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if(\"function\"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Mi(a,b)}}var f=a.stateNode;null!==f&&\"function\"===typeof f.componentDidCatch&&(c.callback=function(){Mi(a,b);\"function\"!==typeof d&&(null===Si?Si=new Set([this]):Si.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:\"\"})});return c}\nfunction Ti(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Ni;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ui.bind(null,a,b,c),b.then(a,a))}function Vi(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}\nfunction Wi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=ch(-1,1),b.tag=2,dh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Xi=ua.ReactCurrentOwner,Ug=!1;function Yi(a,b,c,d){b.child=null===a?Ch(b,null,c,d):Bh(b,a.child,c,d)}\nfunction Zi(a,b,c,d,e){c=c.render;var f=b.ref;Tg(b,e);d=Xh(a,b,c,d,f,e);c=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&c&&vg(b);b.flags|=1;Yi(a,b,d,e);return b.child}\nfunction aj(a,b,c,d,e){if(null===a){var f=c.type;if(\"function\"===typeof f&&!bj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,cj(a,b,f,d,e);a=yh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return $i(a,b,e)}b.flags|=1;a=wh(f,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction cj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(Ug=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(Ug=!0);else return b.lanes=a.lanes,$i(a,b,e)}return dj(a,b,c,d,e)}\nfunction ej(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if(\"hidden\"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(fj,gj),gj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(fj,gj),gj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(fj,gj);gj|=d}else null!==\nf?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(fj,gj),gj|=d;Yi(a,b,e,c);return b.child}function hj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function dj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);Tg(b,e);c=Xh(a,b,c,d,f,e);d=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&d&&vg(b);b.flags|=1;Yi(a,b,c,e);return b.child}\nfunction ij(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;Tg(b,e);if(null===b.stateNode)jj(a,b),ph(b,c,d),rh(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;\"object\"===typeof l&&null!==l?l=Vg(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q=\"function\"===typeof m||\"function\"===typeof g.getSnapshotBeforeUpdate;q||\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||\n(h!==d||k!==l)&&qh(b,g,d,l);$g=!1;var r=b.memoizedState;g.state=r;gh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||$g?(\"function\"===typeof m&&(kh(b,c,m,d),k=b.memoizedState),(h=$g||oh(b,c,h,d,r,k,l))?(q||\"function\"!==typeof g.UNSAFE_componentWillMount&&\"function\"!==typeof g.componentWillMount||(\"function\"===typeof g.componentWillMount&&g.componentWillMount(),\"function\"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),\"function\"===typeof g.componentDidMount&&(b.flags|=4194308)):\n(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;bh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Lg(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;\"object\"===typeof k&&null!==k?k=Vg(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m=\"function\"===typeof y||\"function\"===typeof g.getSnapshotBeforeUpdate)||\n\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&qh(b,g,d,k);$g=!1;r=b.memoizedState;g.state=r;gh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||$g?(\"function\"===typeof y&&(kh(b,c,y,d),n=b.memoizedState),(l=$g||oh(b,c,l,d,r,n,k)||!1)?(m||\"function\"!==typeof g.UNSAFE_componentWillUpdate&&\"function\"!==typeof g.componentWillUpdate||(\"function\"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),\"function\"===typeof g.UNSAFE_componentWillUpdate&&\ng.UNSAFE_componentWillUpdate(d,n,k)),\"function\"===typeof g.componentDidUpdate&&(b.flags|=4),\"function\"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===\na.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return kj(a,b,c,d,f,e)}\nfunction kj(a,b,c,d,e,f){hj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),$i(a,b,f);d=b.stateNode;Xi.current=b;var h=g&&\"function\"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Bh(b,a.child,null,f),b.child=Bh(b,null,h,f)):Yi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function lj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);Ih(a,b.containerInfo)}\nfunction mj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Yi(a,b,c,d);return b.child}var nj={dehydrated:null,treeContext:null,retryLane:0};function oj(a){return{baseLanes:a,cachePool:null,transitions:null}}\nfunction pj(a,b,c){var d=b.pendingProps,e=M.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(M,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:\"$!\"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:\"hidden\",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=\ng):f=qj(g,d,0,null),a=Ah(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=oj(c),b.memoizedState=nj,a):rj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return sj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:\"hidden\",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=wh(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=wh(h,f):(f=Ah(f,g,c,null),f.flags|=2);f.return=\nb;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?oj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=nj;return d}f=a.child;a=f.sibling;d=wh(f,{mode:\"visible\",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}\nfunction rj(a,b){b=qj({mode:\"visible\",children:b},a.mode,0,null);b.return=a;return a.child=b}function tj(a,b,c,d){null!==d&&Jg(d);Bh(b,a.child,null,c);a=rj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}\nfunction sj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Li(Error(p(422))),tj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=qj({mode:\"visible\",children:d.children},e,0,null);f=Ah(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Bh(b,a.child,null,g);b.child.memoizedState=oj(g);b.memoizedState=nj;return f}if(0===(b.mode&1))return tj(a,b,g,null);if(\"$!\"===e.data){d=e.nextSibling&&e.nextSibling.dataset;\nif(d)var h=d.dgst;d=h;f=Error(p(419));d=Li(f,d,void 0);return tj(a,b,g,d)}h=0!==(g&a.childLanes);if(Ug||h){d=R;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;\n0!==e&&e!==f.retryLane&&(f.retryLane=e,Zg(a,e),mh(d,a,e,-1))}uj();d=Li(Error(p(421)));return tj(a,b,g,d)}if(\"$?\"===e.data)return b.flags|=128,b.child=a.child,b=vj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=rj(b,d.children);b.flags|=4096;return b}function wj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);Sg(a.return,b,c)}\nfunction xj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}\nfunction yj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Yi(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&wj(a,c,b);else if(19===a.tag)wj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(M,d);if(0===(b.mode&1))b.memoizedState=\nnull;else switch(e){case \"forwards\":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Mh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);xj(b,!1,e,c,f);break;case \"backwards\":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Mh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}xj(b,!0,c,null,f);break;case \"together\":xj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}\nfunction jj(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function $i(a,b,c){null!==a&&(b.dependencies=a.dependencies);hh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=wh(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=wh(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}\nfunction zj(a,b,c){switch(b.tag){case 3:lj(b);Ig();break;case 5:Kh(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:Ih(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Mg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(M,M.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return pj(a,b,c);G(M,M.current&1);a=$i(a,b,c);return null!==a?a.sibling:null}G(M,M.current&1);break;case 19:d=0!==(c&\nb.childLanes);if(0!==(a.flags&128)){if(d)return yj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(M,M.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,ej(a,b,c)}return $i(a,b,c)}var Aj,Bj,Cj,Dj;\nAj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Bj=function(){};\nCj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;Hh(Eh.current);var f=null;switch(c){case \"input\":e=Ya(a,e);d=Ya(a,d);f=[];break;case \"select\":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case \"textarea\":e=gb(a,e);d=gb(a,d);f=[];break;default:\"function\"!==typeof e.onClick&&\"function\"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if(\"style\"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&\n(c||(c={}),c[g]=\"\")}else\"dangerouslySetInnerHTML\"!==l&&\"children\"!==l&&\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&\"autoFocus\"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if(\"style\"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]=\"\");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,\nc)),c=k;else\"dangerouslySetInnerHTML\"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):\"children\"===l?\"string\"!==typeof k&&\"number\"!==typeof k||(f=f||[]).push(l,\"\"+k):\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&(ea.hasOwnProperty(l)?(null!=k&&\"onScroll\"===l&&D(\"scroll\",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push(\"style\",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Dj=function(a,b,c,d){c!==d&&(b.flags|=4)};\nfunction Ej(a,b){if(!I)switch(a.tailMode){case \"hidden\":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case \"collapsed\":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}\nfunction Fj(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;Jh();E(Wf);E(H);Oh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Gj(zg),zg=null));Bj(a,b);S(b);return null;case 5:Lh(b);var e=Hh(Gh.current);\nc=b.type;if(null!==a&&null!=b.stateNode)Cj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case \"dialog\":D(\"cancel\",d);D(\"close\",d);break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",d);break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],d);break;case \"source\":D(\"error\",d);break;case \"img\":case \"image\":case \"link\":D(\"error\",\nd);D(\"load\",d);break;case \"details\":D(\"toggle\",d);break;case \"input\":Za(d,f);D(\"invalid\",d);break;case \"select\":d._wrapperState={wasMultiple:!!f.multiple};D(\"invalid\",d);break;case \"textarea\":hb(d,f),D(\"invalid\",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];\"children\"===g?\"string\"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=[\"children\",h]):\"number\"===typeof h&&d.textContent!==\"\"+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,\nh,a),e=[\"children\",\"\"+h]):ea.hasOwnProperty(g)&&null!=h&&\"onScroll\"===g&&D(\"scroll\",d)}switch(c){case \"input\":Va(d);db(d,f,!0);break;case \"textarea\":Va(d);jb(d);break;case \"select\":case \"option\":break;default:\"function\"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;\"http://www.w3.org/1999/xhtml\"===a&&(a=kb(c));\"http://www.w3.org/1999/xhtml\"===a?\"script\"===c?(a=g.createElement(\"div\"),a.innerHTML=\"<script>\\x3c/script>\",a=a.removeChild(a.firstChild)):\n\"string\"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),\"select\"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;Aj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case \"dialog\":D(\"cancel\",a);D(\"close\",a);e=d;break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",a);e=d;break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case \"source\":D(\"error\",a);e=d;break;case \"img\":case \"image\":case \"link\":D(\"error\",\na);D(\"load\",a);e=d;break;case \"details\":D(\"toggle\",a);e=d;break;case \"input\":Za(a,d);e=Ya(a,d);D(\"invalid\",a);break;case \"option\":e=d;break;case \"select\":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D(\"invalid\",a);break;case \"textarea\":hb(a,d);e=gb(a,d);D(\"invalid\",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];\"style\"===f?sb(a,k):\"dangerouslySetInnerHTML\"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):\"children\"===f?\"string\"===typeof k?(\"textarea\"!==\nc||\"\"!==k)&&ob(a,k):\"number\"===typeof k&&ob(a,\"\"+k):\"suppressContentEditableWarning\"!==f&&\"suppressHydrationWarning\"!==f&&\"autoFocus\"!==f&&(ea.hasOwnProperty(f)?null!=k&&\"onScroll\"===f&&D(\"scroll\",a):null!=k&&ta(a,f,k,g))}switch(c){case \"input\":Va(a);db(a,d,!1);break;case \"textarea\":Va(a);jb(a);break;case \"option\":null!=d.value&&a.setAttribute(\"value\",\"\"+Sa(d.value));break;case \"select\":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,\n!0);break;default:\"function\"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case \"button\":case \"input\":case \"select\":case \"textarea\":d=!!d.autoFocus;break a;case \"img\":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Dj(a,b,a.memoizedProps,d);else{if(\"string\"!==typeof d&&null===b.stateNode)throw Error(p(166));c=Hh(Gh.current);Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=\nxg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(M);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===\na){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Gj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(M.current&1)?0===T&&(T=3):uj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return Jh(),\nBj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return Rg(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(M);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Ej(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Mh(a);if(null!==g){b.flags|=128;Ej(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,\ng=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(M,M.current&1|2);return b.child}a=\na.sibling}null!==f.tail&&B()>Hj&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304)}else{if(!d)if(a=Mh(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Ej(f,!0),null===f.tail&&\"hidden\"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Hj&&1073741824!==c&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=\nb,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=M.current,G(M,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Ij(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(gj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}\nfunction Jj(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Jh(),E(Wf),E(H),Oh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Lh(b),null;case 13:E(M);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(M),null;case 4:return Jh(),null;case 10:return Rg(b.type._context),null;case 22:case 23:return Ij(),\nnull;case 24:return null;default:return null}}var Kj=!1,U=!1,Lj=\"function\"===typeof WeakSet?WeakSet:Set,V=null;function Mj(a,b){var c=a.ref;if(null!==c)if(\"function\"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Nj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Oj=!1;\nfunction Pj(a,b){Cf=dd;a=Me();if(Ne(a)){if(\"selectionStart\"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=\nq.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;\ncase 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Lg(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent=\"\":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Oj;Oj=!1;return n}\nfunction Qj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Nj(b,c,f)}e=e.next}while(e!==d)}}function Rj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Sj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}\"function\"===typeof b?b(a):b.current=a}}\nfunction Tj(a){var b=a.alternate;null!==b&&(a.alternate=null,Tj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Uj(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction Vj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Uj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}\nfunction Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}\nfunction Xj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Xj(a,b,c),a=a.sibling;null!==a;)Xj(a,b,c),a=a.sibling}var X=null,Yj=!1;function Zj(a,b,c){for(c=c.child;null!==c;)ak(a,b,c),c=c.sibling}\nfunction ak(a,b,c){if(lc&&\"function\"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Mj(c,b);case 6:var d=X,e=Yj;X=null;Zj(a,b,c);X=d;Yj=e;null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Yj;X=c.stateNode.containerInfo;Yj=!0;\nZj(a,b,c);X=d;Yj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Nj(c,b,g):0!==(f&4)&&Nj(c,b,g));e=e.next}while(e!==d)}Zj(a,b,c);break;case 1:if(!U&&(Mj(c,b),d=c.stateNode,\"function\"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Zj(a,b,c);break;case 21:Zj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==\nc.memoizedState,Zj(a,b,c),U=d):Zj(a,b,c);break;default:Zj(a,b,c)}}function bk(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Lj);b.forEach(function(b){var d=ck.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction dk(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Yj=!1;break a;case 3:X=h.stateNode.containerInfo;Yj=!0;break a;case 4:X=h.stateNode.containerInfo;Yj=!0;break a}h=h.return}if(null===X)throw Error(p(160));ak(f,g,e);X=null;Yj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)ek(b,a),b=b.sibling}\nfunction ek(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:dk(b,a);fk(a);if(d&4){try{Qj(3,a,a.return),Rj(3,a)}catch(t){W(a,a.return,t)}try{Qj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);break;case 5:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,\"\")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;\na.updateQueue=null;if(null!==k)try{\"input\"===h&&\"radio\"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];\"style\"===m?sb(e,q):\"dangerouslySetInnerHTML\"===m?nb(e,q):\"children\"===m?ob(e,q):ta(e,m,q,l)}switch(h){case \"input\":bb(e,f);break;case \"textarea\":ib(e,f);break;case \"select\":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,\nf.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:\"\",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:dk(b,a);fk(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:dk(b,a);fk(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:dk(b,a);fk(a);break;case 13:dk(b,a);fk(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||\nnull!==e.alternate&&null!==e.alternate.memoizedState||(gk=B()));d&4&&bk(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,dk(b,a),U=l):dk(b,a);fk(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Qj(4,r,r.return);break;case 1:Mj(r,r.return);var n=r.stateNode;if(\"function\"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=\nb.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Mj(r,r.return);break;case 22:if(null!==r.memoizedState){hk(q);continue}}null!==y?(y.return=r,V=y):hk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,\"function\"===typeof f.setProperty?f.setProperty(\"display\",\"none\",\"important\"):f.display=\"none\"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty(\"display\")?k.display:null,h.style.display=\nrb(\"display\",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?\"\":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:dk(b,a);fk(a);d&4&&bk(a);break;case 21:break;default:dk(b,\na),fk(a)}}function fk(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Uj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,\"\"),d.flags&=-33);var f=Vj(a);Xj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Vj(a);Wj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function ik(a,b,c){V=a;jk(a,b,c)}\nfunction jk(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Kj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Kj;var l=U;Kj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?kk(e):null!==k?(k.return=g,V=k):kk(e);for(;null!==f;)V=f,jk(f,b,c),f=f.sibling;V=e;Kj=h;U=l}lk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):lk(a,b,c)}}\nfunction lk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Rj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Lg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&ih(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=\nb.child.stateNode;break;case 1:c=b.child.stateNode}ih(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case \"button\":case \"input\":case \"select\":case \"textarea\":k.autoFocus&&c.focus();break;case \"img\":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;\ndefault:throw Error(p(163));}U||b.flags&512&&Sj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function hk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}\nfunction kk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Rj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if(\"function\"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Sj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Sj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}\nvar mk=Math.ceil,nk=ua.ReactCurrentDispatcher,ok=ua.ReactCurrentOwner,pk=ua.ReactCurrentBatchConfig,K=0,R=null,Y=null,Z=0,gj=0,fj=Uf(0),T=0,qk=null,hh=0,rk=0,sk=0,tk=null,uk=null,gk=0,Hj=Infinity,vk=null,Pi=!1,Qi=null,Si=null,wk=!1,xk=null,yk=0,zk=0,Ak=null,Bk=-1,Ck=0;function L(){return 0!==(K&6)?B():-1!==Bk?Bk:Bk=B()}\nfunction lh(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Ck&&(Ck=yc()),Ck;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function mh(a,b,c,d){if(50<zk)throw zk=0,Ak=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==R)a===R&&(0===(K&2)&&(rk|=c),4===T&&Dk(a,Z)),Ek(a,d),1===c&&0===K&&0===(b.mode&1)&&(Hj=B()+500,fg&&jg())}\nfunction Ek(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===R?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Fk.bind(null,a)):hg(Fk.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Gk(c,Hk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}\nfunction Hk(a,b){Bk=-1;Ck=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Ik()&&a.callbackNode!==c)return null;var d=uc(a,a===R?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Jk(a,d);else{b=d;var e=K;K|=2;var f=Kk();if(R!==a||Z!==b)vk=null,Hj=B()+500,Lk(a,b);do try{Mk();break}catch(h){Nk(a,h)}while(1);Qg();nk.current=f;K=e;null!==Y?b=0:(R=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Ok(a,e)));if(1===b)throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;if(6===b)Dk(a,d);\nelse{e=a.current.alternate;if(0===(d&30)&&!Pk(e)&&(b=Jk(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Ok(a,f))),1===b))throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Qk(a,uk,vk);break;case 3:Dk(a,d);if((d&130023424)===d&&(b=gk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){L();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),b);break}Qk(a,uk,vk);break;case 4:Dk(a,d);if((d&4194240)===\nd)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*mk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),d);break}Qk(a,uk,vk);break;case 5:Qk(a,uk,vk);break;default:throw Error(p(329));}}}Ek(a,B());return a.callbackNode===c?Hk.bind(null,a):null}\nfunction Ok(a,b){var c=tk;a.current.memoizedState.isDehydrated&&(Lk(a,b).flags|=256);a=Jk(a,b);2!==a&&(b=uk,uk=c,null!==b&&Gj(b));return a}function Gj(a){null===uk?uk=a:uk.push.apply(uk,a)}\nfunction Pk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}\nfunction Dk(a,b){b&=~sk;b&=~rk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Fk(a){if(0!==(K&6))throw Error(p(327));Ik();var b=uc(a,0);if(0===(b&1))return Ek(a,B()),null;var c=Jk(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Ok(a,d))}if(1===c)throw c=qk,Lk(a,0),Dk(a,b),Ek(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Qk(a,uk,vk);Ek(a,B());return null}\nfunction Rk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Hj=B()+500,fg&&jg())}}function Sk(a){null!==xk&&0===xk.tag&&0===(K&6)&&Ik();var b=K;K|=1;var c=pk.transition,d=C;try{if(pk.transition=null,C=1,a)return a()}finally{C=d,pk.transition=c,K=b,0===(K&6)&&jg()}}function Ij(){gj=fj.current;E(fj)}\nfunction Lk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:Jh();E(Wf);E(H);Oh();break;case 5:Lh(d);break;case 4:Jh();break;case 13:E(M);break;case 19:E(M);break;case 10:Rg(d.type._context);break;case 22:case 23:Ij()}c=c.return}R=a;Y=a=wh(a.current,null);Z=gj=b;T=0;qk=null;sk=rk=hh=0;uk=tk=null;if(null!==Wg){for(b=\n0;b<Wg.length;b++)if(c=Wg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}Wg=null}return a}\nfunction Nk(a,b){do{var c=Y;try{Qg();Ph.current=ai;if(Sh){for(var d=N.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Sh=!1}Rh=0;P=O=N=null;Th=!1;Uh=0;ok.current=null;if(null===c||null===c.return){T=1;qk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&\"object\"===typeof k&&\"function\"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,\nm.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Vi(g);if(null!==y){y.flags&=-257;Wi(y,g,h,f,b);y.mode&1&&Ti(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Ti(f,l,b);uj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Vi(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Wi(J,g,h,f,b);Jg(Ki(k,h));break a}}f=k=Ki(k,h);4!==T&&(T=2);null===tk?tk=[f]:tk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;\nb&=-b;f.lanes|=b;var x=Oi(f,k,b);fh(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&(\"function\"===typeof w.getDerivedStateFromError||null!==u&&\"function\"===typeof u.componentDidCatch&&(null===Si||!Si.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Ri(f,h,b);fh(f,F);break a}}f=f.return}while(null!==f)}Tk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Kk(){var a=nk.current;nk.current=ai;return null===a?ai:a}\nfunction uj(){if(0===T||3===T||2===T)T=4;null===R||0===(hh&268435455)&&0===(rk&268435455)||Dk(R,Z)}function Jk(a,b){var c=K;K|=2;var d=Kk();if(R!==a||Z!==b)vk=null,Lk(a,b);do try{Uk();break}catch(e){Nk(a,e)}while(1);Qg();K=c;nk.current=d;if(null!==Y)throw Error(p(261));R=null;Z=0;return T}function Uk(){for(;null!==Y;)Vk(Y)}function Mk(){for(;null!==Y&&!cc();)Vk(Y)}function Vk(a){var b=Wk(a.alternate,a,gj);a.memoizedProps=a.pendingProps;null===b?Tk(a):Y=b;ok.current=null}\nfunction Tk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Fj(c,b,gj),null!==c){Y=c;return}}else{c=Jj(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Qk(a,b,c){var d=C,e=pk.transition;try{pk.transition=null,C=1,Xk(a,b,c,d)}finally{pk.transition=e,C=d}return null}\nfunction Xk(a,b,c,d){do Ik();while(null!==xk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===R&&(Y=R=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||wk||(wk=!0,Gk(hc,function(){Ik();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=pk.transition;pk.transition=null;\nvar g=C;C=1;var h=K;K|=4;ok.current=null;Pj(a,c);ek(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;ik(c,a,e);dc();K=h;C=g;pk.transition=f}else a.current=c;wk&&(wk=!1,xk=a,yk=e);f=a.pendingLanes;0===f&&(Si=null);mc(c.stateNode,d);Ek(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Pi)throw Pi=!1,a=Qi,Qi=null,a;0!==(yk&1)&&0!==a.tag&&Ik();f=a.pendingLanes;0!==(f&1)?a===Ak?zk++:(zk=0,Ak=a):zk=0;jg();return null}\nfunction Ik(){if(null!==xk){var a=Dc(yk),b=pk.transition,c=C;try{pk.transition=null;C=16>a?16:a;if(null===xk)var d=!1;else{a=xk;xk=null;yk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Qj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Tj(m);if(m===\nl){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Qj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==\nu)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Rj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&\"function\"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,pk.transition=b}}return!1}function Yk(a,b,c){b=Ki(c,b);b=Oi(a,b,1);a=dh(a,b,1);b=L();null!==a&&(Ac(a,1,b),Ek(a,b))}\nfunction W(a,b,c){if(3===a.tag)Yk(a,a,c);else for(;null!==b;){if(3===b.tag){Yk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if(\"function\"===typeof b.type.getDerivedStateFromError||\"function\"===typeof d.componentDidCatch&&(null===Si||!Si.has(d))){a=Ki(c,a);a=Ri(b,a,1);b=dh(b,a,1);a=L();null!==b&&(Ac(b,1,a),Ek(b,a));break}}b=b.return}}\nfunction Ui(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=L();a.pingedLanes|=a.suspendedLanes&c;R===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-gk?Lk(a,0):sk|=c);Ek(a,b)}function Zk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=L();a=Zg(a,b);null!==a&&(Ac(a,b,c),Ek(a,c))}function vj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Zk(a,c)}\nfunction ck(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Zk(a,c)}var Wk;\nWk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)Ug=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return Ug=!1,zj(a,b,c);Ug=0!==(a.flags&131072)?!0:!1}else Ug=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;jj(a,b);a=b.pendingProps;var e=Yf(b,H.current);Tg(b,c);e=Xh(null,b,d,a,e,c);var f=bi();b.flags|=1;\"object\"===typeof e&&null!==e&&\"function\"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=\nnull,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,ah(b),e.updater=nh,b.stateNode=e,e._reactInternals=b,rh(b,d,a,c),b=kj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Yi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{jj(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=$k(d);a=Lg(d,a);switch(e){case 0:b=dj(null,b,d,a,c);break a;case 1:b=ij(null,b,d,a,c);break a;case 11:b=Zi(null,b,d,a,c);break a;case 14:b=aj(null,b,d,Lg(d.type,a),c);break a}throw Error(p(306,\nd,\"\"));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),dj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),ij(a,b,d,e,c);case 3:a:{lj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;bh(a,b);gh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=\nf,b.memoizedState=f,b.flags&256){e=Ki(Error(p(423)),b);b=mj(a,b,d,c,e);break a}else if(d!==e){e=Ki(Error(p(424)),b);b=mj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Ch(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=$i(a,b,c);break a}Yi(a,b,d,c)}b=b.child}return b;case 5:return Kh(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),\nhj(a,b),Yi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return pj(a,b,c);case 4:return Ih(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Bh(b,null,d,c):Yi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),Zi(a,b,d,e,c);case 7:return Yi(a,b,b.pendingProps,c),b.child;case 8:return Yi(a,b,b.pendingProps.children,c),b.child;case 12:return Yi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;\ng=e.value;G(Mg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=$i(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=ch(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);Sg(f.return,\nc,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);Sg(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Yi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,Tg(b,c),e=Vg(e),d=d(e),b.flags|=1,Yi(a,b,d,c),\nb.child;case 14:return d=b.type,e=Lg(d,b.pendingProps),e=Lg(d.type,e),aj(a,b,d,e,c);case 15:return cj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),jj(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,Tg(b,c),ph(b,d,e),rh(b,d,e,c),kj(null,b,d,!0,a,c);case 19:return yj(a,b,c);case 22:return ej(a,b,c)}throw Error(p(156,b.tag));};function Gk(a,b){return ac(a,b)}\nfunction al(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new al(a,b,c,d)}function bj(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction $k(a){if(\"function\"===typeof a)return bj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}\nfunction wh(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction yh(a,b,c,d,e,f){var g=2;d=a;if(\"function\"===typeof a)bj(a)&&(g=1);else if(\"string\"===typeof a)g=5;else a:switch(a){case ya:return Ah(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return qj(c,e,f,b);default:if(\"object\"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;\nbreak a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,\"\"));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Ah(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function qj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function xh(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}\nfunction zh(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction bl(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=\nnull}function cl(a,b,c,d,e,f,g,h,k){a=new bl(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};ah(f);return a}function dl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:\"\"+d,children:a,containerInfo:b,implementation:c}}\nfunction el(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}\nfunction fl(a,b,c,d,e,f,g,h,k){a=cl(c,d,!0,a,e,f,g,h,k);a.context=el(null);c=a.current;d=L();e=lh(c);f=ch(d,e);f.callback=void 0!==b&&null!==b?b:null;dh(c,f,e);a.current.lanes=e;Ac(a,e,d);Ek(a,d);return a}function gl(a,b,c,d){var e=b.current,f=L(),g=lh(e);c=el(c);null===b.context?b.context=c:b.pendingContext=c;b=ch(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=dh(e,b,g);null!==a&&(mh(a,e,g,f),eh(a,e,g));return g}\nfunction hl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function il(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function jl(a,b){il(a,b);(a=a.alternate)&&il(a,b)}function kl(){return null}var ll=\"function\"===typeof reportError?reportError:function(a){console.error(a)};function ml(a){this._internalRoot=a}\nnl.prototype.render=ml.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));gl(a,b,null,null)};nl.prototype.unmount=ml.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Sk(function(){gl(null,a,null,null)});b[uf]=null}};function nl(a){this._internalRoot=a}\nnl.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function pl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||\" react-mount-point-unstable \"!==a.nodeValue))}function ql(){}\nfunction rl(a,b,c,d,e){if(e){if(\"function\"===typeof d){var f=d;d=function(){var a=hl(g);f.call(a)}}var g=fl(b,d,a,0,null,!1,!1,\"\",ql);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Sk();return g}for(;e=a.lastChild;)a.removeChild(e);if(\"function\"===typeof d){var h=d;d=function(){var a=hl(k);h.call(a)}}var k=cl(a,0,!1,null,null,!1,!1,\"\",ql);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Sk(function(){gl(b,k,c,d)});return k}\nfunction sl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if(\"function\"===typeof e){var h=e;e=function(){var a=hl(g);h.call(a)}}gl(b,g,a,e)}else g=rl(c,b,a,e,d);return hl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Ek(b,B()),0===(K&6)&&(Hj=B()+500,jg()))}break;case 13:Sk(function(){var b=Zg(a,1);if(null!==b){var c=L();mh(b,a,1,c)}}),jl(a,1)}};\nFc=function(a){if(13===a.tag){var b=Zg(a,134217728);if(null!==b){var c=L();mh(b,a,134217728,c)}jl(a,134217728)}};Gc=function(a){if(13===a.tag){var b=lh(a),c=Zg(a,b);if(null!==c){var d=L();mh(c,a,b,d)}jl(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};\nyb=function(a,b,c){switch(b){case \"input\":bb(a,c);b=c.name;if(\"radio\"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll(\"input[name=\"+JSON.stringify(\"\"+b)+'][type=\"radio\"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case \"textarea\":ib(a,c);break;case \"select\":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Rk;Hb=Sk;\nvar tl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Rk]},ul={findFiberByHostInstance:Wc,bundleType:0,version:\"18.2.0\",rendererPackageName:\"react-dom\"};\nvar vl={bundleType:ul.bundleType,version:ul.version,rendererPackageName:ul.rendererPackageName,rendererConfig:ul.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:ul.findFiberByHostInstance||\nkl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:\"18.2.0-next-9e3b772b8-20220608\"};if(\"undefined\"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var wl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wl.isDisabled&&wl.supportsFiber)try{kc=wl.inject(vl),lc=wl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tl;\nexports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!ol(b))throw Error(p(200));return dl(a,b,null,c)};exports.createRoot=function(a,b){if(!ol(a))throw Error(p(299));var c=!1,d=\"\",e=ll;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=cl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ml(b)};\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if(\"function\"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(\",\");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Sk(a)};exports.hydrate=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!0,c)};\nexports.hydrateRoot=function(a,b,c){if(!ol(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f=\"\",g=ll;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=fl(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,\ne);return new nl(b)};exports.render=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!pl(a))throw Error(p(40));return a._reactRootContainer?(Sk(function(){sl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Rk;\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!pl(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return sl(a,b,c,!1,d)};exports.version=\"18.2.0-next-9e3b772b8-20220608\";\n","/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\tvar nativeCodeString = '[native code]';\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import { forwardRef, useRef, useCallback, useEffect, useLayoutEffect, useState } from \"react\";\nimport { jsx, jsxs, Fragment } from \"react/jsx-runtime\";\nimport classNames from \"classnames\";\nimport { createPortal } from \"react-dom\";\nconst color_css_ts_vanilla = \"\";\nvar color = { Background: { Container: \"var(--oq6d070)\", ContainerHover: \"var(--oq6d071)\", ContainerActive: \"var(--oq6d072)\", ContainerLine: \"var(--oq6d073)\", OnContainer: \"var(--oq6d074)\" }, Surface: { Container: \"var(--oq6d075)\", ContainerHover: \"var(--oq6d076)\", ContainerActive: \"var(--oq6d077)\", ContainerLine: \"var(--oq6d078)\", OnContainer: \"var(--oq6d079)\" }, SurfaceVariant: { Container: \"var(--oq6d07a)\", ContainerHover: \"var(--oq6d07b)\", ContainerActive: \"var(--oq6d07c)\", ContainerLine: \"var(--oq6d07d)\", OnContainer: \"var(--oq6d07e)\" }, Primary: { Main: \"var(--oq6d07f)\", MainHover: \"var(--oq6d07g)\", MainActive: \"var(--oq6d07h)\", MainLine: \"var(--oq6d07i)\", OnMain: \"var(--oq6d07j)\", Container: \"var(--oq6d07k)\", ContainerHover: \"var(--oq6d07l)\", ContainerActive: \"var(--oq6d07m)\", ContainerLine: \"var(--oq6d07n)\", OnContainer: \"var(--oq6d07o)\" }, Secondary: { Main: \"var(--oq6d07p)\", MainHover: \"var(--oq6d07q)\", MainActive: \"var(--oq6d07r)\", MainLine: \"var(--oq6d07s)\", OnMain: \"var(--oq6d07t)\", Container: \"var(--oq6d07u)\", ContainerHover: \"var(--oq6d07v)\", ContainerActive: \"var(--oq6d07w)\", ContainerLine: \"var(--oq6d07x)\", OnContainer: \"var(--oq6d07y)\" }, Success: { Main: \"var(--oq6d07z)\", MainHover: \"var(--oq6d0710)\", MainActive: \"var(--oq6d0711)\", MainLine: \"var(--oq6d0712)\", OnMain: \"var(--oq6d0713)\", Container: \"var(--oq6d0714)\", ContainerHover: \"var(--oq6d0715)\", ContainerActive: \"var(--oq6d0716)\", ContainerLine: \"var(--oq6d0717)\", OnContainer: \"var(--oq6d0718)\" }, Warning: { Main: \"var(--oq6d0719)\", MainHover: \"var(--oq6d071a)\", MainActive: \"var(--oq6d071b)\", MainLine: \"var(--oq6d071c)\", OnMain: \"var(--oq6d071d)\", Container: \"var(--oq6d071e)\", ContainerHover: \"var(--oq6d071f)\", ContainerActive: \"var(--oq6d071g)\", ContainerLine: \"var(--oq6d071h)\", OnContainer: \"var(--oq6d071i)\" }, Critical: { Main: \"var(--oq6d071j)\", MainHover: \"var(--oq6d071k)\", MainActive: \"var(--oq6d071l)\", MainLine: \"var(--oq6d071m)\", OnMain: \"var(--oq6d071n)\", Container: \"var(--oq6d071o)\", ContainerHover: \"var(--oq6d071p)\", ContainerActive: \"var(--oq6d071q)\", ContainerLine: \"var(--oq6d071r)\", OnContainer: \"var(--oq6d071s)\" }, Other: { FocusRing: \"var(--oq6d071t)\", Shadow: \"var(--oq6d071u)\", Overlay: \"var(--oq6d071v)\" } };\nvar lightTheme = \"oq6d071w\";\nconst config_css_ts_vanilla = \"\";\nvar config = { font: { Inter: \"var(--_164xfge1)\" }, fontSize: { D400: \"var(--_164xfge2)\", H1: \"var(--_164xfge3)\", H2: \"var(--_164xfge4)\", H3: \"var(--_164xfge5)\", H4: \"var(--_164xfge6)\", H5: \"var(--_164xfge7)\", H6: \"var(--_164xfge8)\", T500: \"var(--_164xfge9)\", T400: \"var(--_164xfgea)\", T300: \"var(--_164xfgeb)\", T200: \"var(--_164xfgec)\", B500: \"var(--_164xfged)\", B400: \"var(--_164xfgee)\", B300: \"var(--_164xfgef)\", L400: \"var(--_164xfgeg)\", O400: \"var(--_164xfgeh)\", C400: \"var(--_164xfgei)\" }, lineHeight: { D400: \"var(--_164xfgej)\", H1: \"var(--_164xfgek)\", H2: \"var(--_164xfgel)\", H3: \"var(--_164xfgem)\", H4: \"var(--_164xfgen)\", H5: \"var(--_164xfgeo)\", H6: \"var(--_164xfgep)\", T500: \"var(--_164xfgeq)\", T400: \"var(--_164xfger)\", T300: \"var(--_164xfges)\", T200: \"var(--_164xfget)\", B500: \"var(--_164xfgeu)\", B400: \"var(--_164xfgev)\", B300: \"var(--_164xfgew)\", L400: \"var(--_164xfgex)\", O400: \"var(--_164xfgey)\", C400: \"var(--_164xfgez)\" }, letterSpacing: { D400: \"var(--_164xfge10)\", H1: \"var(--_164xfge11)\", H2: \"var(--_164xfge12)\", H3: \"var(--_164xfge13)\", H4: \"var(--_164xfge14)\", H5: \"var(--_164xfge15)\", H6: \"var(--_164xfge16)\", T500: \"var(--_164xfge17)\", T400: \"var(--_164xfge18)\", T300: \"var(--_164xfge19)\", T200: \"var(--_164xfge1a)\", B500: \"var(--_164xfge1b)\", B400: \"var(--_164xfge1c)\", B300: \"var(--_164xfge1d)\", L400: \"var(--_164xfge1e)\", O400: \"var(--_164xfge1f)\", C400: \"var(--_164xfge1g)\" }, fontWeight: { W100: \"var(--_164xfge1h)\", W200: \"var(--_164xfge1i)\", W300: \"var(--_164xfge1j)\", W400: \"var(--_164xfge1k)\", W500: \"var(--_164xfge1l)\", W600: \"var(--_164xfge1m)\", W700: \"var(--_164xfge1n)\", W800: \"var(--_164xfge1o)\", W900: \"var(--_164xfge1p)\" }, space: { S0: \"var(--_164xfge1q)\", S100: \"var(--_164xfge1r)\", S200: \"var(--_164xfge1s)\", S300: \"var(--_164xfge1t)\", S400: \"var(--_164xfge1u)\", S500: \"var(--_164xfge1v)\", S600: \"var(--_164xfge1w)\", S700: \"var(--_164xfge1x)\" }, radii: { R0: \"var(--_164xfge1y)\", R300: \"var(--_164xfge1z)\", R400: \"var(--_164xfge20)\", R500: \"var(--_164xfge21)\", Round: \"var(--_164xfge22)\", Pill: \"var(--_164xfge23)\" }, borderWidth: { B0: \"var(--_164xfge24)\", B300: \"var(--_164xfge25)\", B400: \"var(--_164xfge26)\", B500: \"var(--_164xfge27)\", B600: \"var(--_164xfge28)\", B700: \"var(--_164xfge29)\" }, zIndex: { Z100: \"var(--_164xfge2a)\", Z200: \"var(--_164xfge2b)\", Z300: \"var(--_164xfge2c)\", Z400: \"var(--_164xfge2d)\", Max: \"var(--_164xfge2e)\" }, shadow: { E100: \"var(--_164xfge2f)\", E200: \"var(--_164xfge2g)\", E300: \"var(--_164xfge2h)\", E400: \"var(--_164xfge2i)\" }, size: { XInherit: \"var(--_164xfge2j)\", X50: \"var(--_164xfge2k)\", X100: \"var(--_164xfge2l)\", X200: \"var(--_164xfge2m)\", X300: \"var(--_164xfge2n)\", X400: \"var(--_164xfge2o)\", X500: \"var(--_164xfge2p)\", X600: \"var(--_164xfge2q)\", DialogWidth: \"var(--_164xfge2r)\", ModalHeight300: \"var(--_164xfge2s)\", ModalHeight400: \"var(--_164xfge2t)\", ModalHeight500: \"var(--_164xfge2u)\", ModalWidth300: \"var(--_164xfge2v)\", ModalWidth400: \"var(--_164xfge2w)\", ModalWidth500: \"var(--_164xfge2x)\", ModalDrawerWidth: \"var(--_164xfge2y)\" }, transition: {}, opacity: { P500: \"var(--_164xfge2z)\", P400: \"var(--_164xfge30)\", P300: \"var(--_164xfge31)\", Placeholder: \"var(--_164xfge32)\", Disabled: \"var(--_164xfge33)\" } };\nvar configClass = \"_164xfge0\";\nconst vars_css_ts_vanilla = \"\";\nvar vars = { outline: { FocusRing: \"var(--dw378b1)\" } };\nvar varsClass = \"dw378b0\";\nconst pxToRem = (px) => parseFloat((px / 16).toFixed(4));\nconst toRem = (px) => `${pxToRem(px)}rem`;\nconst canAlignXStart = (anchor, target, offset) => anchor.x + offset + target.width <= document.documentElement.clientWidth;\nconst canAlignXCenter = (anchor, target, offset) => {\n  const xCenter = anchor.x + anchor.width / 2;\n  const left = xCenter - target.width / 2;\n  if (left < 0)\n    return false;\n  return left + offset + target.width <= document.documentElement.clientWidth;\n};\nconst canAlignXEnd = (anchor, target, offset) => {\n  const xEnd = anchor.x + anchor.width;\n  return xEnd - (target.width + offset) >= 0;\n};\nconst canAlignYStart = (anchor, target, offset) => anchor.y + offset + target.height <= document.documentElement.clientHeight;\nconst canAlignYCenter = (anchor, target, offset) => {\n  const yCenter = anchor.y + anchor.height / 2;\n  const top = yCenter - target.height / 2;\n  if (top < 0)\n    return false;\n  return top + offset + target.height <= document.documentElement.clientHeight;\n};\nconst canAlignYEnd = (anchor, target, offset) => {\n  const yEnd = anchor.y + anchor.height;\n  return yEnd - (target.height + offset) >= 0;\n};\nconst alignXStart = (anchor, offset) => ({\n  left: `${anchor.x + offset}px`\n});\nconst alignXCenter = (anchor, target, offset) => {\n  const xCenter = anchor.x + anchor.width / 2;\n  const left = xCenter - target.width / 2;\n  return {\n    left: `${left + offset}px`\n  };\n};\nconst alignXEnd = (anchor, offset) => {\n  const xEnd = anchor.x + anchor.width;\n  const right = document.documentElement.clientWidth - xEnd;\n  return {\n    right: `${right + offset}px`\n  };\n};\nconst alignXAuto = (anchor, target, offset) => {\n  if (canAlignXCenter(anchor, target, offset)) {\n    return alignXCenter(anchor, target, offset);\n  }\n  if (canAlignXStart(anchor, target, offset)) {\n    return alignXStart(anchor, offset);\n  }\n  if (canAlignXEnd(anchor, target, offset)) {\n    return alignXEnd(anchor, offset);\n  }\n  return void 0;\n};\nconst alignX = (align, anchor, target, offset) => {\n  if (align === \"Start\" && canAlignXStart(anchor, target, offset)) {\n    return alignXStart(anchor, offset);\n  }\n  if (align === \"Center\" && canAlignXCenter(anchor, target, offset)) {\n    return alignXCenter(anchor, target, offset);\n  }\n  if (align === \"End\" && canAlignXEnd(anchor, target, offset)) {\n    return alignXEnd(anchor, offset);\n  }\n  return alignXAuto(anchor, target, offset);\n};\nconst alignYStart = (anchor, offset) => ({\n  top: `${anchor.y + offset}px`\n});\nconst alignYCenter = (anchor, target, offset) => {\n  const yCenter = anchor.y + anchor.height / 2;\n  const top = yCenter - target.height / 2;\n  return {\n    top: `${top + offset}px`\n  };\n};\nconst alignYEnd = (anchor, offset) => {\n  const yEnd = anchor.y + anchor.height;\n  const bottom = document.documentElement.clientHeight - yEnd;\n  return {\n    bottom: `${bottom + offset}px`\n  };\n};\nconst alignYAuto = (anchor, target, offset) => {\n  if (canAlignYCenter(anchor, target, offset)) {\n    return alignYCenter(anchor, target, offset);\n  }\n  if (canAlignYStart(anchor, target, offset)) {\n    return alignYStart(anchor, offset);\n  }\n  if (canAlignYEnd(anchor, target, offset)) {\n    return alignYEnd(anchor, offset);\n  }\n  return void 0;\n};\nconst alignY = (align, anchor, target, offset) => {\n  if (align === \"Start\" && canAlignYStart(anchor, target, offset)) {\n    return alignYStart(anchor, offset);\n  }\n  if (align === \"Center\" && canAlignYCenter(anchor, target, offset)) {\n    return alignYCenter(anchor, target, offset);\n  }\n  if (align === \"End\" && canAlignYEnd(anchor, target, offset)) {\n    return alignYEnd(anchor, offset);\n  }\n  return alignYAuto(anchor, target, offset);\n};\nconst canPositionTop = (anchor, target, offset) => target.height + offset <= anchor.y;\nconst canPositionRight = (anchor, target, offset) => anchor.x + anchor.width + offset + target.width <= document.documentElement.clientWidth;\nconst canPositionBottom = (anchor, target, offset) => anchor.y + anchor.height + offset + target.height <= document.documentElement.clientHeight;\nconst canPositionLeft = (anchor, target, offset) => target.width + offset <= anchor.x;\nconst positionTop = (anchor, offset) => {\n  const bottom = document.documentElement.clientHeight - anchor.y;\n  return {\n    bottom: `${bottom + offset}px`\n  };\n};\nconst positionRight = (anchor, offset) => {\n  const left = anchor.x + anchor.width;\n  return {\n    left: `${left + offset}px`\n  };\n};\nconst positionBottom = (anchor, offset) => {\n  const top = anchor.y + anchor.height;\n  return {\n    top: `${top + offset}px`\n  };\n};\nconst positionLeft = (anchor, offset) => {\n  const right = document.documentElement.clientWidth - anchor.x;\n  return {\n    right: `${right + offset}px`\n  };\n};\nconst positionAuto = (align, anchor, target, offset, alignOffset) => {\n  if (canPositionRight(anchor, target, offset)) {\n    return {\n      ...positionRight(anchor, offset),\n      ...alignY(align, anchor, target, alignOffset)\n    };\n  }\n  if (canPositionBottom(anchor, target, offset)) {\n    return {\n      ...positionBottom(anchor, offset),\n      ...alignX(align, anchor, target, alignOffset)\n    };\n  }\n  if (canPositionLeft(anchor, target, offset)) {\n    return {\n      ...positionLeft(anchor, offset),\n      ...alignY(align, anchor, target, alignOffset)\n    };\n  }\n  if (canPositionTop(anchor, target, offset)) {\n    return {\n      ...positionTop(anchor, offset),\n      ...alignX(align, anchor, target, alignOffset)\n    };\n  }\n  return {\n    ...alignX(align, anchor, target, alignOffset)\n  };\n};\nconst getRelativeFixedPosition = (anchor, target, position, align, offset, alignOffset) => {\n  if (position === \"Top\" && canPositionTop(anchor, target, offset)) {\n    return {\n      ...positionTop(anchor, offset),\n      ...alignX(align, anchor, target, alignOffset)\n    };\n  }\n  if (position === \"Right\" && canPositionRight(anchor, target, offset)) {\n    return {\n      ...positionRight(anchor, offset),\n      ...alignY(align, anchor, target, alignOffset)\n    };\n  }\n  if (position === \"Bottom\" && canPositionBottom(anchor, target, offset)) {\n    return {\n      ...positionBottom(anchor, offset),\n      ...alignX(align, anchor, target, alignOffset)\n    };\n  }\n  if (position === \"Left\" && canPositionLeft(anchor, target, offset)) {\n    return {\n      ...positionLeft(anchor, offset),\n      ...alignY(align, anchor, target, alignOffset)\n    };\n  }\n  return positionAuto(align, anchor, target, offset, alignOffset);\n};\nconst percent = (min, max, value) => (value - min) / (max - min) * 100;\nconst as = (fc) => forwardRef(fc);\nconst reset_css_ts_vanilla = \"\";\nvar DefaultReset = \"_1mqalmd1 _1mqalmd0\";\nvar TextReset = \"_1mqalmd0\";\nconst selectorPreset_css_ts_vanilla = \"\";\nvar Disabled = \"_1bugis91\";\nvar FocusOutline = \"_1bugis90\";\nconst variant_css_ts_vanilla = \"\";\nvar CrossSizeVariant = { \"50\": \"cpipac7\", \"100\": \"cpipac8\", \"200\": \"cpipac9\", \"300\": \"cpipaca\", \"400\": \"cpipacb\", \"500\": \"cpipacc\", \"600\": \"cpipacd\", Inherit: \"cpipac6\" };\nvar RadiiVariant = { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" };\nconst Avatar_css_ts_vanilla = \"\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function(sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {\n  for (var key of Object.keys(compoundCheck)) {\n    var _selections$key;\n    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {\n      return false;\n    }\n  }\n  return true;\n};\nvar createRuntimeFn = (config2) => (options) => {\n  var className = config2.defaultClassName;\n  var selections = _objectSpread2(_objectSpread2({}, config2.defaultVariants), options);\n  for (var variantName in selections) {\n    var _selections$variantNa;\n    var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config2.defaultVariants[variantName];\n    if (variantSelection != null) {\n      var selection = variantSelection;\n      if (typeof selection === \"boolean\") {\n        selection = selection === true ? \"true\" : \"false\";\n      }\n      var selectionClassName = (\n        // @ts-expect-error\n        config2.variantClassNames[variantName][selection]\n      );\n      if (selectionClassName) {\n        className += \" \" + selectionClassName;\n      }\n    }\n  }\n  for (var [compoundCheck, compoundClassName] of config2.compoundVariants) {\n    if (shouldApplyCompound(compoundCheck, selections, config2.defaultVariants)) {\n      className += \" \" + compoundClassName;\n    }\n  }\n  return className;\n};\nvar Avatar$1 = createRuntimeFn({ defaultClassName: \"_1684mq51 _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\", variantClassNames: { size: { \"200\": \"_1684mq52\", \"300\": \"_1684mq53\", \"400\": \"_1684mq54\", \"500\": \"_1684mq55\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { size: \"400\", radii: \"400\" }, compoundVariants: [] });\nvar AvatarFallback$1 = \"_1684mq5d _1mqalmd1 _1mqalmd0\";\nvar AvatarImage$1 = \"_1684mq5c _1mqalmd1 _1mqalmd0\";\nconst Avatar = as(\n  ({ as: AsAvatar = \"span\", size, radii, className, ...props }, ref) => /* @__PURE__ */ jsx(AsAvatar, { className: classNames(Avatar$1({ size, radii }), className), ...props, ref })\n);\nconst AvatarImage = as(({ as: AsAvatarImage = \"img\", className, ...props }, ref) => /* @__PURE__ */ jsx(AsAvatarImage, { className: classNames(AvatarImage$1, className), ...props, ref }));\nconst AvatarFallback = as(\n  ({ as: AsAvatarFallback = \"span\", className, ...props }, ref) => /* @__PURE__ */ jsx(AsAvatarFallback, { className: classNames(AvatarFallback$1, className), ...props, ref })\n);\nconst Badge_css_ts_vanilla = \"\";\nvar Badge$1 = createRuntimeFn({ defaultClassName: \"_13qe89m6 _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\", variantClassNames: { size: { \"200\": \"_13qe89m7\", \"300\": \"_13qe89m8\", \"400\": \"_13qe89m9\", \"500\": \"_13qe89ma\" }, variant: { Primary: \"_13qe89mb\", Secondary: \"_13qe89mc\", Success: \"_13qe89md\", Warning: \"_13qe89me\", Critical: \"_13qe89mf\" }, fill: { Solid: \"_13qe89mg\", Soft: \"_13qe89mh\", None: \"_13qe89mi\" }, outlined: { true: \"_13qe89mj\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { size: \"400\", variant: \"Primary\", fill: \"Soft\", radii: \"300\" }, compoundVariants: [] });\nconst Badge = as(\n  ({ as: AsBadge = \"span\", className, size, variant, fill, radii, outlined, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsBadge,\n    {\n      className: classNames(Badge$1({ size, variant, fill, radii, outlined }), className),\n      ...props,\n      ref\n    }\n  )\n);\nconst Box_css_ts_vanilla = \"\";\nvar Box$1 = createRuntimeFn({ defaultClassName: \"prxiv40 _1mqalmd1 _1mqalmd0\", variantClassNames: { display: { Flex: \"prxiv41\", InlineFlex: \"prxiv42\" }, direction: { Inherit: \"prxiv43\", Row: \"prxiv44\", RowReverse: \"prxiv45\", Column: \"prxiv46\", ColumnReverse: \"prxiv47\" }, wrap: { Inherit: \"prxiv48\", NoWrap: \"prxiv49\", Wrap: \"prxiv4a\", WrapReverse: \"prxiv4b\" }, justifyContent: { Inherit: \"prxiv4c\", Start: \"prxiv4d\", End: \"prxiv4e\", Stretch: \"prxiv4f\", Center: \"prxiv4g\", Baseline: \"prxiv4h\", SpaceBetween: \"prxiv4i\", SpaceAround: \"prxiv4j\", SpaceEvenly: \"prxiv4k\" }, justifyItems: { Inherit: \"prxiv4l\", Start: \"prxiv4m\", End: \"prxiv4n\", Stretch: \"prxiv4o\", Center: \"prxiv4p\", Baseline: \"prxiv4q\" }, justifySelf: { Inherit: \"prxiv4r\", Start: \"prxiv4s\", End: \"prxiv4t\", Stretch: \"prxiv4u\", Center: \"prxiv4v\", Baseline: \"prxiv4w\" }, alignContent: { Inherit: \"prxiv4x\", Start: \"prxiv4y\", End: \"prxiv4z\", Stretch: \"prxiv410\", Center: \"prxiv411\", Baseline: \"prxiv412\", SpaceBetween: \"prxiv413\", SpaceAround: \"prxiv414\", SpaceEvenly: \"prxiv415\" }, alignItems: { Inherit: \"prxiv416\", Start: \"prxiv417\", End: \"prxiv418\", Stretch: \"prxiv419\", Center: \"prxiv41a\", Baseline: \"prxiv41b\" }, alignSelf: { Inherit: \"prxiv41c\", Start: \"prxiv41d\", End: \"prxiv41e\", Stretch: \"prxiv41f\", Center: \"prxiv41g\", Baseline: \"prxiv41h\" }, gap: { \"0\": \"prxiv41i\", \"100\": \"prxiv41j\", \"200\": \"prxiv41k\", \"300\": \"prxiv41l\", \"400\": \"prxiv41m\", \"500\": \"prxiv41n\", \"600\": \"prxiv41o\", \"700\": \"prxiv41p\", Inherit: \"prxiv41q\" }, grow: { No: \"prxiv41r\", Yes: \"prxiv41s\" }, shrink: { No: \"prxiv41t\", Yes: \"prxiv41u\" }, basis: { No: \"prxiv41v\", Yes: \"prxiv41w\" } }, defaultVariants: { display: \"Flex\" }, compoundVariants: [] });\nconst Box = as(\n  ({\n    as: AsBox = \"div\",\n    className,\n    display,\n    direction,\n    wrap,\n    justifyContent,\n    justifyItems,\n    justifySelf,\n    alignContent,\n    alignItems,\n    alignSelf,\n    gap,\n    grow,\n    shrink,\n    basis,\n    ...props\n  }, ref) => /* @__PURE__ */ jsx(\n    AsBox,\n    {\n      className: classNames(\n        Box$1({\n          display,\n          direction,\n          wrap,\n          justifyContent,\n          justifyItems,\n          justifySelf,\n          alignContent,\n          alignItems,\n          alignSelf,\n          gap,\n          grow,\n          shrink,\n          basis\n        }),\n        className\n      ),\n      ...props,\n      ref\n    }\n  )\n);\nconst Button_css_ts_vanilla = \"\";\nvar Button$1 = createRuntimeFn({ defaultClassName: \"epr39zd _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\", variantClassNames: { size: { \"300\": \"epr39ze\", \"400\": \"epr39zf\", \"500\": \"epr39zg\" }, variant: { Primary: \"epr39zh\", Secondary: \"epr39zi\", Success: \"epr39zj\", Warning: \"epr39zk\", Critical: \"epr39zl\" }, fill: { Solid: \"epr39zm\", Soft: \"epr39zn\", None: \"epr39zo\" }, outlined: { true: \"epr39zp\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { size: \"400\", variant: \"Primary\", fill: \"Solid\", radii: \"400\" }, compoundVariants: [] });\nconst Button = as(\n  ({\n    as: AsButton = \"button\",\n    className,\n    size,\n    variant,\n    fill,\n    outlined,\n    radii,\n    before,\n    after,\n    children,\n    ...props\n  }, ref) => /* @__PURE__ */ jsxs(\n    AsButton,\n    {\n      className: classNames(Button$1({ size, variant, fill, outlined, radii }), className),\n      \"data-ui-before\": before ? true : void 0,\n      \"data-ui-after\": after ? true : void 0,\n      ...props,\n      ref,\n      children: [\n        before,\n        children,\n        after\n      ]\n    }\n  )\n);\nconst Icon_css_ts_vanilla = \"\";\nvar Icon$1 = createRuntimeFn({ defaultClassName: \"_19nrl2w0 _1mqalmd1 _1mqalmd0\", variantClassNames: { size: { \"50\": \"cpipac7\", \"100\": \"cpipac8\", \"200\": \"cpipac9\", \"300\": \"cpipaca\", \"400\": \"cpipacb\", \"500\": \"cpipacc\", \"600\": \"cpipacd\", Inherit: \"cpipac6\" } }, defaultVariants: { size: \"400\" }, compoundVariants: [] });\nconst Icon = forwardRef(\n  ({ className, size, filled = false, src, ...props }, ref) => /* @__PURE__ */ jsx(\n    \"svg\",\n    {\n      className: classNames(Icon$1({ size }), className),\n      focusable: \"false\",\n      viewBox: \"0 0 24 24\",\n      fill: \"none\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      ...props,\n      ref,\n      children: src(filled)\n    }\n  )\n);\nconst Icons = {\n  Home: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M3 10V21H9V18.5C9 16.8431 10.3431 15.5 12 15.5C13.6569 15.5 15 16.8431 15 18.5V21H21V10L12 2L3 10Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M4.5 10.6736V19.5H8.5V17.5C8.5 15.567 10.067 14 12 14C13.933 14 15.5 15.567 15.5 17.5V19.5H19.5V10.6736L12 4.00693L4.5 10.6736ZM3 10V21H10V17.5C10 16.3954 10.8954 15.5 12 15.5C13.1046 15.5 14 16.3954 14 17.5V21H21V10L12 2L3 10Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  User: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"12\", cy: \"7\", r: \"4\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M4 18C4 15.2386 6.23858 13 9 13H15C17.7614 13 20 15.2386 20 18V21H4V18Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 9.5C13.3807 9.5 14.5 8.38071 14.5 7C14.5 5.61929 13.3807 4.5 12 4.5C10.6193 4.5 9.5 5.61929 9.5 7C9.5 8.38071 10.6193 9.5 12 9.5ZM12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M15 14.5H9C7.067 14.5 5.5 16.067 5.5 18V19.5H18.5V18C18.5 16.067 16.933 14.5 15 14.5ZM9 13C6.23858 13 4 15.2386 4 18V21H20V18C20 15.2386 17.7614 13 15 13H9Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  UserPlus: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"14\", cy: \"7\", r: \"4\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M5 3H3V6H0V8H3V11H5V8H8V6H5V3Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M6 18C6 15.2386 8.23858 13 11 13H17C19.7614 13 22 15.2386 22 18V21H6V18Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M14 9.5C15.3807 9.5 16.5 8.38071 16.5 7C16.5 5.61929 15.3807 4.5 14 4.5C12.6193 4.5 11.5 5.61929 11.5 7C11.5 8.38071 12.6193 9.5 14 9.5ZM14 11C16.2091 11 18 9.20914 18 7C18 4.79086 16.2091 3 14 3C11.7909 3 10 4.79086 10 7C10 9.20914 11.7909 11 14 11Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M17 14.5H11C9.067 14.5 7.5 16.067 7.5 18V19.5H20.5V18C20.5 16.067 18.933 14.5 17 14.5ZM11 13C8.23858 13 6 15.2386 6 18V21H22V18C22 15.2386 19.7614 13 17 13H11Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M5 3H3V6H0V8H3V11H5V8H8V6H5V3Z\", fill: \"currentColor\" })\n  ] }),\n  Mail: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M22 6.76393V4H2V6.76393L12 11.7639L22 6.76393Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M2 9V20H22V9L12 14L2 9Z\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M2 4H22V20H2V4ZM3.5 8.07295L12 12.3229L20.5 8.07295V5.5H3.5V8.07295ZM20.5 9.75L12 14L3.5 9.75V18.5H20.5V9.75Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  MailPlus: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M22 6.76393V4H2V6.76393L12 11.7639L22 6.76393Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M2 9V20H14C14 16.6863 16.6863 14 20 14C20.7013 14 21.3744 14.1203 22 14.3414V9L12 14L2 9Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M19 16H21V24H19V16Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M24 19L24 21L16 21L16 19L24 19Z\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M19 16H21V24H19V16Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M24 19L24 21L16 21L16 19L24 19Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M22 4H2V20H14V18.5H3.5V9.75L12 14L20.5 9.75V14H22V4ZM12 12.3229L3.5 8.07295V5.5H20.5V8.07295L12 12.3229Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Star: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12 2L14.9095 8.99537L22.4616 9.60081L16.7077 14.5296L18.4656 21.8992L12 17.95L5.53437 21.8992L7.29228 14.5296L1.53839 9.60081L9.09048 8.99537L12 2Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M14.9095 8.99537L12 2L9.09048 8.99537L1.53839 9.60081L7.29228 14.5296L5.53437 21.8992L12 17.95L18.4656 21.8992L16.7077 14.5296L22.4616 9.60081L14.9095 8.99537ZM18.7469 10.8078L13.8764 10.4174L12 5.90594L10.1236 10.4174L5.25316 10.8078L8.96393 13.9865L7.83023 18.7392L12 16.1923L16.1698 18.7392L15.0361 13.9865L18.7469 10.8078Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  PlusCircle: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C17.5 22 22 17.5 22 12C22 6.5 17.5 2 12 2ZM11 7H13V11H17V13H13V17H11V13H7V11H11V7Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 3.5C7.32843 3.5 3.5 7.32843 3.5 12C3.5 16.6716 7.32843 20.5 12 20.5C16.6716 20.5 20.5 16.6716 20.5 12C20.5 7.32843 16.6716 3.5 12 3.5ZM2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"11\", y: \"7\", width: \"2\", height: \"10\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"7\", y: \"11\", width: \"10\", height: \"2\", fill: \"currentColor\" })\n  ] }),\n  Explore: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12ZM9.87866 9.87866L7.05023 16.9497L14.1213 14.1213L16.9497 7.05023L9.87866 9.87866ZM13 12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12C11 11.4477 11.4477 11 12 11C12.5523 11 13 11.4477 13 12Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 3.5C7.32843 3.5 3.5 7.32843 3.5 12C3.5 16.6716 7.32843 20.5 12 20.5C16.6716 20.5 20.5 16.6716 20.5 12C20.5 7.32843 16.6716 3.5 12 3.5ZM2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M7.05023 16.9497L9.87866 9.87866L16.9497 7.05023L14.1213 14.1213L7.05023 16.9497ZM12 13C12.5523 13 13 12.5523 13 12C13 11.4477 12.5523 11 12 11C11.4477 11 11 11.4477 11 12C11 12.5523 11.4477 13 12 13Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Smile: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12ZM8.5 11C9.32843 11 10 10.3284 10 9.5C10 8.67157 9.32843 8 8.5 8C7.67157 8 7 8.67157 7 9.5C7 10.3284 7.67157 11 8.5 11ZM15.5 11C16.3284 11 17 10.3284 17 9.5C17 8.67157 16.3284 8 15.5 8C14.6716 8 14 8.67157 14 9.5C14 10.3284 14.6716 11 15.5 11ZM7 14C7 16.2 9.25 18 12 18C14.75 18 17 16.2 17 14H7Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 3.5C7.32843 3.5 3.5 7.32843 3.5 12C3.5 16.6716 7.32843 20.5 12 20.5C16.6716 20.5 20.5 16.6716 20.5 12C20.5 7.32843 16.6716 3.5 12 3.5ZM2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M8.5 11C9.32843 11 10 10.3284 10 9.5C10 8.67157 9.32843 8 8.5 8C7.67157 8 7 8.67157 7 9.5C7 10.3284 7.67157 11 8.5 11Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M15.5 11C16.3284 11 17 10.3284 17 9.5C17 8.67157 16.3284 8 15.5 8C14.6716 8 14 8.67157 14 9.5C14 10.3284 14.6716 11 15.5 11Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M17 14H7C7 16.2 9.25 18 12 18C14.75 18 17 16.2 17 14Z\", fill: \"currentColor\" })\n  ] }),\n  SmilePlus: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M14.2566 2.25849C14.0897 2.80965 14 3.39435 14 4C14 5.53683 14.5778 6.93872 15.528 8.00026C15.5187 8.00009 15.5094 8 15.5 8C14.6716 8 14 8.67157 14 9.5C14 10.3284 14.6716 11 15.5 11C16.3284 11 17 10.3284 17 9.5C17 9.3891 16.988 9.28102 16.9651 9.17698C17.8555 9.70005 18.8927 10 20 10C20.6057 10 21.1903 9.91026 21.7415 9.74336C21.9106 10.4692 22 11.2246 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12C2 6.5 6.5 2 12 2C12.7754 2 13.5308 2.08943 14.2566 2.25849ZM10 9.5C10 10.3284 9.32843 11 8.5 11C7.67157 11 7 10.3284 7 9.5C7 8.67157 7.67157 8 8.5 8C9.32843 8 10 8.67157 10 9.5ZM12 18C9.25 18 7 16.2 7 14H17C17 16.2 14.75 18 12 18Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M19 0H21V8H19V0Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M24 3L24 5L16 5L16 3L24 3Z\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M14 2.2023C13.3533 2.06968 12.6844 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C17.5 22 22 17.5 22 12C22 11.3156 21.9303 10.6467 21.7977 10H20.2603C20.4169 10.642 20.5 11.3119 20.5 12C20.5 16.6716 16.6716 20.5 12 20.5C7.32843 20.5 3.5 16.6716 3.5 12C3.5 7.32843 7.32843 3.5 12 3.5C12.6881 3.5 13.358 3.58307 14 3.73967V2.2023Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M8.5 11C9.32843 11 10 10.3284 10 9.5C10 8.67157 9.32843 8 8.5 8C7.67157 8 7 8.67157 7 9.5C7 10.3284 7.67157 11 8.5 11Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M15.5 11C16.3284 11 17 10.3284 17 9.5C17 8.67157 16.3284 8 15.5 8C14.6716 8 14 8.67157 14 9.5C14 10.3284 14.6716 11 15.5 11Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M17 14H7C7 16.2 9.25 18 12 18C14.75 18 17 16.2 17 14Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M19 0H21V8H19V0Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M24 3L24 5L16 5L16 3L24 3Z\", fill: \"currentColor\" })\n  ] }),\n  Leaf: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M4 15V18.9393L2.46967 20.4697L3.53033 21.5303L5.06065 20H9C15.6274 20 21 14.6274 21 8V3H16C9.37258 3 4 8.37258 4 15ZM7.53033 17.5303L16.5303 8.53033L15.4697 7.46967L6.46967 16.4697L7.53033 17.5303Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M4 18.9393V15C4 8.37258 9.37258 3 16 3H21V8C21 14.6274 15.6274 20 9 20H5.06065L3.53033 21.5303L2.46967 20.4697L4 18.9393ZM5.5 17.4393V15C5.5 9.20101 10.201 4.5 16 4.5H19.5V8C19.5 13.799 14.799 18.5 9 18.5H6.56065L16.5303 8.53033L15.4697 7.46967L5.5 17.4393Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Sticker: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M14 3H3V21H21V10H14V3ZM15 13C15 14.1046 13.6569 15 12 15C10.3431 15 9 14.1046 9 13H7C7 15.2091 9.23858 17 12 17C14.7614 17 17 15.2091 17 13H15Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M21 8L16 8V3L21 8Z\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M17 13H15C15 14.1046 13.6569 15 12 15C10.3431 15 9 14.1046 9 13H7C7 15.2091 9.23858 17 12 17C14.7614 17 17 15.2091 17 13Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M16 3L21 8V21H3V3H16ZM19.5 9H15V4.5H4.5V19.5H19.5V9Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Delete: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M16 2H8V4H3V5.5H5V22H19V5.5H21V4H16V2ZM11 9H9V17H11V9ZM15 9H13V17H15V9Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"rect\", { x: \"9\", y: \"9\", width: \"2\", height: \"8\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"13\", y: \"9\", width: \"2\", height: \"8\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M16 2H8V4H3V5.5H5V22H19V5.5H21V4H16V2ZM17.5 5.5V20.5H6.5V5.5H17.5Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Phone: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M2 5L5 2L12 9L9 12L12 15L15 12L22 19L19 22V22C9.61116 22 2 14.3888 2 5V5Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12 9L5 2L2 5C2 14.3888 9.61116 22 19 22L22 19L15 12L12 15L9 12L12 9ZM15 14.1213L12 17.1213L6.87868 12L9.87868 9.00001L5 4.12132L3.51177 5.60955C3.82406 13.6852 10.3148 20.176 18.3904 20.4883L19.8787 19L15 14.1213Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Headphone: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M19.5 12C19.5 7.85786 16.1421 4.5 12 4.5C7.85786 4.5 4.5 7.85786 4.5 12V13H10V21H3V12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12V21H14V13H19.5V12Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M19.5 12C19.5 7.85786 16.1421 4.5 12 4.5C7.85786 4.5 4.5 7.85786 4.5 12V13H10V21H3V12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12V21H14V13H19.5V12ZM4.5 14.5H8.5V19.5H4.5V14.5ZM19.5 14.5V19.5H15.5V14.5H19.5Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Send: (filled) => filled ? /* @__PURE__ */ jsx(\"path\", { d: \"M3 22L23 12L3 2V11H11V13H3V22Z\", fill: \"currentColor\" }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M23 12L3 2V22L23 12ZM19.6459 12L4.5 4.42705V19.5729L19.6459 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"3\", y: \"11\", width: \"8\", height: \"2\", fill: \"currentColor\" })\n  ] }),\n  Bell: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M6 9C6 5.68629 8.68629 3 12 3C15.3137 3 18 5.68629 18 9V16.5H20V18H4V16.5H6V9Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20H14C14 21.1046 13.1046 22 12 22C10.8954 22 10 21.1046 10 20Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6 16.5H4V18H20V16.5H18V9C18 5.68629 15.3137 3 12 3C8.68629 3 6 5.68629 6 9V16.5ZM16.5 16.5V9C16.5 6.51472 14.4853 4.5 12 4.5C9.51472 4.5 7.5 6.51472 7.5 9V16.5H16.5Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20H14C14 21.1046 13.1046 22 12 22C10.8954 22 10 21.1046 10 20Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  BellRing: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6 16.571H4V18.071H20V16.571H18V9.07104C18 5.75734 15.3137 3.07104 12 3.07104C8.68629 3.07104 6 5.75734 6 9.07104V16.571Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20.071H14C14 21.1756 13.1046 22.071 12 22.071C10.8954 22.071 10 21.1756 10 20.071Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M5.98959 3.06066C4.4514 4.59886 3.5 6.72386 3.5 9.07107H2C2 6.30964 3.11929 3.80964 4.92893 2L5.98959 3.06066Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M18.0104 3.06066C19.5486 4.59886 20.5 6.72386 20.5 9.07107H22C22 6.30964 20.8807 3.80964 19.0711 2L18.0104 3.06066Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6 16.571H4V18.071H20V16.571H18V9.07104C18 5.75734 15.3137 3.07104 12 3.07104C8.68629 3.07104 6 5.75734 6 9.07104V16.571ZM16.5 16.571V9.07104C16.5 6.58576 14.4853 4.57104 12 4.57104C9.51472 4.57104 7.5 6.58576 7.5 9.07104V16.571H16.5Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20.071H14C14 21.1756 13.1046 22.071 12 22.071C10.8954 22.071 10 21.1756 10 20.071Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M5.98959 3.06066C4.4514 4.59886 3.5 6.72386 3.5 9.07107H2C2 6.30964 3.11929 3.80964 4.92893 2L5.98959 3.06066Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M18.0104 3.06066C19.5486 4.59886 20.5 6.72386 20.5 9.07107H22C22 6.30964 20.8807 3.80964 19.0711 2L18.0104 3.06066Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  BellPing: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20.071H14C14 21.1756 13.1046 22.071 12 22.071C10.8954 22.071 10 21.1756 10 20.071Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M5.98959 3.06066C4.4514 4.59886 3.5 6.72386 3.5 9.07107H2C2 6.30964 3.11929 3.80964 4.92893 2L5.98959 3.06066Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M21 6C21 7.65685 19.6569 9 18 9C16.3431 9 15 7.65685 15 6C15 4.34315 16.3431 3 18 3C19.6569 3 21 4.34315 21 6Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M13.7681 3.33582C13.2092 3.1637 12.6154 3.07104 12 3.07104C8.68629 3.07104 6 5.75734 6 9.07104V16.571H4V18.071H20V16.571H18V11C15.2386 11 13 8.76142 13 6C13 5.02067 13.2816 4.1071 13.7681 3.33582Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20H14C14 21.1046 13.1046 22 12 22C10.8954 22 10 21.1046 10 20Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M5.98959 2.98962C4.4514 4.52781 3.5 6.65281 3.5 9.00002H2C2 6.2386 3.11929 3.7386 4.92893 1.92896L5.98959 2.98962Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M21 6C21 7.65685 19.6569 9 18 9C16.3431 9 15 7.65685 15 6C15 4.34315 16.3431 3 18 3C19.6569 3 21 4.34315 21 6Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M13.8061 3.2766C13.2361 3.0969 12.6294 3 12 3C8.68629 3 6 5.68629 6 9V16.5H4V18H20V16.5H18V11C17.4774 11 16.9735 10.9198 16.5 10.7711V16.5H7.5V9C7.5 6.51472 9.51472 4.5 12 4.5C12.4092 4.5 12.8056 4.55462 13.1824 4.65696C13.3202 4.16162 13.5324 3.69724 13.8061 3.2766Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  BellMute: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20H14C14 21.1046 13.1046 22 12 22C10.8954 22 10 21.1046 10 20Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M18 9V14.111L8.22509 4.33605C9.25608 3.50055 10.5696 3 12 3C15.3137 3 18 5.68629 18 9Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M20.3085 19.2479L19.2478 20.3085L16.9393 18H4V16.5H6V9C6 8.41093 6.08489 7.84169 6.24311 7.30384L3.69147 4.7522L4.75213 3.69154L20.3085 19.2479Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 20H14C14 21.1046 13.1046 22 12 22C10.8954 22 10 21.1046 10 20Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M16.5 9V12.611L18 14.111V9C18 5.68629 15.3137 3 12 3C10.5696 3 9.25608 3.50055 8.22509 4.33605L9.29356 5.40452C10.0468 4.83667 10.9841 4.5 12 4.5C14.4853 4.5 16.5 6.51472 16.5 9Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M20.3085 19.2479L19.2478 20.3085L16.9393 18H4V16.5H6V9C6 8.41093 6.08489 7.84169 6.24311 7.30384L3.69147 4.7522L4.75213 3.69154L20.3085 19.2479ZM7.51934 8.58007C7.50654 8.71833 7.5 8.8584 7.5 9V16.5H15.4393L7.51934 8.58007Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Message: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M3 4V18H16L21 21V4H3ZM7 8H17V10H7V8ZM7 12H17V14H7V12Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M16.4155 16.5L19.5 18.3507V5.5H4.5V16.5H16.4155ZM3 18V4H21V21L16 18H3Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"7\", y: \"8\", width: \"10\", height: \"2\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"7\", y: \"12\", width: \"10\", height: \"2\", fill: \"currentColor\" })\n  ] }),\n  MessageUnread: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M13.416 4H3V18H16L21 21V10.0004C20.1643 10.6281 19.1256 11 18 11C16.8742 11 15.8353 10.6279 14.9995 10H7V8H13.416C13.1484 7.38754 13 6.7111 13 6C13 5.2889 13.1484 4.61246 13.416 4ZM17 12H7V14H17V12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"18\", cy: \"6\", r: \"3\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M21 10.0004V21L16 18H3V4H13.416C13.2119 4.46712 13.0772 4.97145 13.0247 5.5H4.5V16.5H16.4155L19.5 18.3507V10.7711C20.0464 10.5995 20.5523 10.3366 21 10.0004Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M13.416 8C13.7639 8.79625 14.3132 9.48438 14.9995 10H7V8H13.416Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M17 12H7V14H17V12Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"18\", cy: \"6\", r: \"3\", fill: \"currentColor\" })\n  ] }),\n  Setting: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M9.00001 2H15V4.58152C15.6948 4.86278 16.3411 5.23882 16.9229 5.69361L19.1603 4.40186L22.1603 9.59801L19.9235 10.8894C19.9739 11.2524 20 11.6231 20 12C20 12.3768 19.9739 12.7475 19.9235 13.1105L22.1603 14.4019L19.1603 19.598L16.923 18.3063C16.3412 18.7611 15.6949 19.1372 15 19.4185V22H9.00001V19.4185C8.30516 19.1372 7.65881 18.7612 7.07702 18.3063L4.83978 19.598L1.83978 14.4019L4.07646 13.1105C4.02605 12.7476 4 12.3768 4 12C4 11.6231 4.02606 11.2524 4.07647 10.8894L1.83978 9.59801L4.83978 4.40186L7.07712 5.69358C7.65889 5.2388 8.3052 4.86276 9.00001 4.58151V2ZM12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M15 4.58152V2H9.00001V4.58151C8.3052 4.86276 7.65889 5.2388 7.07712 5.69358L4.83978 4.40186L1.83978 9.59801L4.07647 10.8894C4.02606 11.2524 4 11.6231 4 12C4 12.3768 4.02605 12.7476 4.07646 13.1105L1.83978 14.4019L4.83978 19.598L7.07702 18.3063C7.65881 18.7612 8.30516 19.1372 9.00001 19.4185V22H15V19.4185C15.6949 19.1372 16.3412 18.7611 16.923 18.3063L19.1603 19.598L22.1603 14.4019L19.9235 13.1105C19.9739 12.7475 20 12.3768 20 12C20 11.6231 19.9739 11.2524 19.9235 10.8894L22.1603 9.59801L19.1603 4.40186L16.9229 5.69361C16.3411 5.23882 15.6948 4.86278 15 4.58152ZM18.6113 6.45089L16.7964 7.49868L15.9991 6.87537C15.5259 6.50544 15.0008 6.20008 14.4372 5.97193L13.5 5.59257V3.5H10.5V5.59256L9.56283 5.97192C8.99921 6.20007 8.47415 6.50542 8.00093 6.87535L7.20358 7.49865L5.38882 6.4509L3.88882 9.04897L5.70115 10.0953L5.56221 11.0957C5.52127 11.3905 5.5 11.6924 5.5 12C5.5 12.3076 5.52126 12.6094 5.5622 12.9042L5.70112 13.9046L3.88882 14.9509L5.38882 17.549L7.2035 16.5013L8.00085 17.1246C8.47409 17.4945 8.99918 17.7999 9.56283 18.0281L10.5 18.4074V20.5H13.5V18.4074L14.4372 18.0281C15.0008 17.7999 15.5259 17.4945 15.9992 17.1246L16.7965 16.5012L18.6113 17.549L20.1113 14.9509L18.2989 13.9045L18.4378 12.9042C18.4787 12.6094 18.5 12.3076 18.5 12C18.5 11.6924 18.4787 11.3906 18.4378 11.0957L18.2989 10.0954L20.1113 9.04897L18.6113 6.45089Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"12\", cy: \"12\", r: \"3\", fill: \"currentColor\" })\n  ] }),\n  Search: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"10\", cy: \"10\", r: \"4\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M10 16.5C13.5899 16.5 16.5 13.5899 16.5 10C16.5 6.41015 13.5899 3.5 10 3.5C6.41015 3.5 3.5 6.41015 3.5 10C3.5 13.5899 6.41015 16.5 10 16.5ZM10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 14.4183 5.58172 18 10 18Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: \"15.4142\",\n        y: \"14\",\n        width: \"9\",\n        height: \"1.5\",\n        transform: \"rotate(45 15.4142 14)\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M10 16.5C13.5899 16.5 16.5 13.5899 16.5 10C16.5 6.41015 13.5899 3.5 10 3.5C6.41015 3.5 3.5 6.41015 3.5 10C3.5 13.5899 6.41015 16.5 10 16.5ZM10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 14.4183 5.58172 18 10 18Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: \"15.4142\",\n        y: \"14\",\n        width: \"9\",\n        height: \"1.5\",\n        transform: \"rotate(45 15.4142 14)\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Heart: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12.0208 5.48522L11.6673 5.13166C9.5194 2.98378 6.03699 2.98378 3.88911 5.13166C1.74123 7.27955 1.74123 10.762 3.88911 12.9098L12.0208 21.0416L20.1526 12.9098C22.3005 10.762 22.3005 7.27955 20.1526 5.13166C18.0047 2.98378 14.5223 2.98378 12.3744 5.13166L12.0208 5.48522Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12.0208 7.60654L10.6066 6.19232C9.04453 4.63023 6.51187 4.63023 4.94977 6.19232C3.38767 7.75442 3.38767 10.2871 4.94977 11.8492L12.0208 18.9202L19.0919 11.8492C20.654 10.2871 20.654 7.75442 19.0919 6.19232C17.5298 4.63023 14.9971 4.63023 13.4351 6.19232L12.0208 7.60654ZM11.6673 5.13166C9.5194 2.98378 6.03699 2.98378 3.88911 5.13166C1.74123 7.27955 1.74123 10.762 3.88911 12.9098L12.0208 21.0416L20.1526 12.9098C22.3005 10.762 22.3005 7.27955 20.1526 5.13166C18.0047 2.98378 14.5223 2.98378 12.3744 5.13166L12.0208 5.48522L11.6673 5.13166Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Play: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12ZM16 12L10 8V16L16 12Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 3.5C7.32843 3.5 3.5 7.32843 3.5 12C3.5 16.6716 7.32843 20.5 12 20.5C16.6716 20.5 20.5 16.6716 20.5 12C20.5 7.32843 16.6716 3.5 12 3.5ZM2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M10 16V8L16 12L10 16Z\", fill: \"currentColor\" })\n  ] }),\n  Pause: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12ZM9 8H11V16H9V8ZM13 8H15V16H13V8Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 3.5C7.32843 3.5 3.5 7.32843 3.5 12C3.5 16.6716 7.32843 20.5 12 20.5C16.6716 20.5 20.5 16.6716 20.5 12C20.5 7.32843 16.6716 3.5 12 3.5ZM2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"9\", y: \"8\", width: \"2\", height: \"8\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"13\", y: \"8\", width: \"2\", height: \"8\", fill: \"currentColor\" })\n  ] }),\n  Sun: (filled) => /* @__PURE__ */ jsxs(Fragment, { children: [\n    filled ? /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 7C9.2 7 7 9.2 7 12C7 14.8 9.2 17 12 17C14.8 17 17 14.8 17 12C17 9.2 14.8 7 12 7Z\",\n        fill: \"currentColor\"\n      }\n    ) : /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 8.5C10.0284 8.5 8.5 10.0284 8.5 12C8.5 13.9716 10.0284 15.5 12 15.5C13.9716 15.5 15.5 13.9716 15.5 12C15.5 10.0284 13.9716 8.5 12 8.5ZM7 12C7 9.2 9.2 7 12 7C14.8 7 17 9.2 17 12C17 14.8 14.8 17 12 17C9.2 17 7 14.8 7 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M11 2H13V5H11V2Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M19 11H22V13H19V11Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M13 19H11V22H13V19Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M2 11H5V13H2V11Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M7.58059 6.52L5.45927 4.39868L4.39861 5.45934L6.51992 7.58066L7.58059 6.52Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M6.51996 16.4195L4.39856 18.5409L5.45922 19.6016L7.58062 17.4802L6.51996 16.4195Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M16.4194 17.4802L18.5407 19.6015L19.6014 18.5408L17.4801 16.4195L16.4194 17.4802Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M17.4801 7.5807L19.6014 5.45946L18.5407 4.3988L16.4195 6.52004L17.4801 7.5807Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Photo: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"14.5\", cy: \"8.5\", r: \"1.5\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M3 3H21V21H3V3ZM4.5 4.5H19.5V19.5L10.5 10.5L4.5 16.5V4.5Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"circle\", { cx: \"14.5\", cy: \"8.5\", r: \"1.5\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M3 3H21V21H3V3ZM4.5 4.5H19.5V19.5L10.5 10.5L4.5 16.5V4.5ZM4.5 18.6213V19.5H17.3787L10.5 12.6213L4.5 18.6213Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Lock: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M7 9V7C7 4.23858 9.23858 2 12 2C14.7614 2 17 4.23858 17 7V9H20V21H4V9H7ZM15.5 7V9H8.5V7C8.5 5.067 10.067 3.5 12 3.5C13.933 3.5 15.5 5.067 15.5 7ZM12 17C13.1046 17 14 16.1046 14 15C14 13.8954 13.1046 13 12 13C10.8954 13 10 13.8954 10 15C10 16.1046 10.8954 17 12 17Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M7 9V7C7 4.23858 9.23858 2 12 2C14.7614 2 17 4.23858 17 7V9H20V21H4V9H7ZM15.5 7V9H8.5V7C8.5 5.067 10.067 3.5 12 3.5C13.933 3.5 15.5 5.067 15.5 7ZM5.5 10.5V19.5H18.5V10.5H5.5Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 17C13.1046 17 14 16.1046 14 15C14 13.8954 13.1046 13 12 13C10.8954 13 10 13.8954 10 15C10 16.1046 10.8954 17 12 17Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Vlc: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M2 20.5V22H22V20.5H20L18.8649 17H5.13514L4 20.5H2Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M5.78378 15H18.2162L17.2432 12H6.75676L5.78378 15Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M7.40541 10H16.5946L14 2H10L7.40541 10Z\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M14 2L20 20.5H22V22H2V20.5H4L10 2H14ZM18.4231 20.5H5.57692L6.71205 17H17.2879L18.4231 20.5ZM16.6393 15H7.3607L8.33367 12H15.6663L16.6393 15ZM11.0904 3.5L8.98232 10H15.0177L12.9096 3.5H11.0904Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Flag: (filled) => filled ? /* @__PURE__ */ jsx(\"path\", { d: \"M3 3H21V5L17 9L21 13V15H4.5V21H3V3Z\", fill: \"currentColor\" }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M21 5V3H3V21H4.5V15H21V13L17 9L21 5ZM19.3787 13.5L14.8787 9L19.3787 4.5H4.5V13.5H19.3787Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Ball: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M5.5 19.5996C7.64233 17.7655 9 15.0413 9 12C9 8.9587 7.64233 6.2345 5.5 4.40041C7.24803 2.9039 9.51846 2 12 2C14.4815 2 16.752 2.9039 18.5 4.40041C16.3577 6.2345 15 8.9587 15 12C15 15.0413 16.3577 17.7655 18.5 19.5996C16.752 21.0961 14.4815 22 12 22C9.51846 22 7.24803 21.0961 5.5 19.5996Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M4.11517 5.84871C2.78981 7.54518 2 9.68035 2 12C2 14.3196 2.78981 16.4548 4.11517 18.1513C5.87794 16.6838 7 14.4729 7 12C7 9.52705 5.87794 7.31618 4.11517 5.84871Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M19.8848 5.84871C21.2102 7.54518 22 9.68035 22 12C22 14.3196 21.2102 16.4548 19.8848 18.1513C18.1221 16.6838 17 14.4729 17 12C17 9.52705 18.1221 7.31618 19.8848 5.84871Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22ZM18.5 17.4775C19.7479 15.9982 20.5 14.0869 20.5 12C20.5 9.91309 19.7479 8.00184 18.5 6.5225C17.2521 8.00184 16.5 9.9131 16.5 12C16.5 14.0869 17.2521 15.9982 18.5 17.4775ZM17.4327 18.5375C15.9597 19.763 14.0659 20.5 12 20.5C9.93412 20.5 8.04038 19.763 6.56736 18.5376C8.08313 16.7846 9.00003 14.4994 9.00003 12.0001C9.00003 9.50072 8.08309 7.21551 6.56725 5.46249C8.0403 4.23703 9.93408 3.5 12 3.5C14.0659 3.5 15.9597 4.23702 17.4327 5.46248C15.9169 7.21548 15 9.50067 15 12C15 14.4994 15.9169 16.7845 17.4327 18.5375ZM3.5 12C3.5 9.9131 4.25207 8.00186 5.49997 6.52252C6.74792 8.00187 7.50003 9.91316 7.50003 12.0001C7.50003 14.087 6.74796 15.9982 5.50006 17.4776C4.25211 15.9982 3.5 14.0869 3.5 12Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Bulb: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M20 10C20 12.9611 18.3912 15.5465 16 16.9297V22H8V16.9297C5.60879 15.5465 4 12.9611 4 10C4 5.58172 7.58172 2 12 2C16.4183 2 20 5.58172 20 10ZM9.91421 8.08569L8.5 9.49991L11 11.9999V13.9999H13V12.071L15.5711 9.49991L14.1569 8.08569L12.0355 10.207L9.91421 8.08569Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M14.5 16.0646L15.2489 15.6313C17.1957 14.5052 18.5 12.404 18.5 10C18.5 6.41015 15.5899 3.5 12 3.5C8.41015 3.5 5.5 6.41015 5.5 10C5.5 12.404 6.80432 14.5052 8.75109 15.6313L9.5 16.0646V20.5H14.5V16.0646ZM16 16.9297C18.3912 15.5465 20 12.9611 20 10C20 5.58172 16.4183 2 12 2C7.58172 2 4 5.58172 4 10C4 12.9611 5.60879 15.5465 8 16.9297V22H16V16.9297Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M8.5 9.49991L9.91421 8.08569L12.0355 10.207L14.1569 8.08569L15.5711 9.49991L13 12.071V13.9999H11V11.9999L8.5 9.49991Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Terminal: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M22 4H2V20H22V4ZM7.74264 7.75732L6.32843 9.17154L9.15686 12L6.32843 14.8284L7.74264 16.2426L11.9853 12L7.74264 7.75732ZM13 14H18V16H13V14Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M20.5 5.5H3.5V18.5H20.5V5.5ZM2 4V20H22V4H2Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M13 14H18V16H13V14Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M7.74264 7.75736L6.32843 9.17157L9.15685 12L6.32843 14.8284L7.74264 16.2426L11.9853 12L7.74264 7.75736Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Pencil: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 17V21H7L17.2929 10.7071L13.2929 6.70709L3 17Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M14.7071 5.29288L18.7071 9.29288L22.5 5.5L18.5 1.5L14.7071 5.29288Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M3 16V21H8L23 6L18 1L3 16ZM16.7322 10.1465L7.37868 19.5H4.5V16.6213L13.8535 7.26781L16.7322 10.1465ZM18.1464 8.73228L20.8787 6L18 3.12132L15.2677 5.8536L18.1464 8.73228Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Info: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12ZM11 8V6H13V8H11ZM13 15V10H10V11.5H11V15H9.5V17H14.5L14.5 15H13Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 3.5C7.32843 3.5 3.5 7.32843 3.5 12C3.5 16.6716 7.32843 20.5 12 20.5C16.6716 20.5 20.5 16.6716 20.5 12C20.5 7.32843 16.6716 3.5 12 3.5ZM2 12C2 6.5 6.5 2 12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M13 15.5V10H10V11.5H11V15.5H9.5V17H14.5L14.5 15.5H13Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"11\", y: \"6\", width: \"2\", height: \"2\", fill: \"currentColor\" })\n  ] }),\n  Shield: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12 2L3 7V13C3 17.9706 7.02944 22 12 22C16.9706 22 21 17.9706 21 13V7L12 2Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M4.5 7.88261V13C4.5 17.1421 7.85786 20.5 12 20.5C16.1421 20.5 19.5 17.1421 19.5 13V7.88261L12 3.71594L4.5 7.88261ZM12 2L3 7V13C3 17.9706 7.02944 22 12 22C16.9706 22 21 17.9706 21 13V7L12 2Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ShieldLock: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M3 7L12 2L21 7V13C21 17.9706 16.9706 22 12 22C7.02944 22 3 17.9706 3 13V7ZM11 12.7C10.4 12.4 10 11.7 10 11C10 9.9 10.9 9 12 9C13.1 9 14 9.9 14 11C14 11.7 13.6 12.4 13 12.7V16H11V12.7Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M4.5 7.88261V13C4.5 17.1421 7.85786 20.5 12 20.5C16.1421 20.5 19.5 17.1421 19.5 13V7.88261L12 3.71594L4.5 7.88261ZM12 2L3 7V13C3 17.9706 7.02944 22 12 22C16.9706 22 21 17.9706 21 13V7L12 2Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 11C10 11.7 10.4 12.4 11 12.7V16H13V12.7C13.6 12.4 14 11.7 14 11C14 9.9 13.1 9 12 9C10.9 9 10 9.9 10 11Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  ShieldUser: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M3 7L12 2L21 7V13C21 17.9706 16.9706 22 12 22C7.02944 22 3 17.9706 3 13V7ZM12 12C13.1046 12 14 11.1046 14 10C14 8.89543 13.1046 8 12 8C10.8954 8 10 8.89543 10 10C10 11.1046 10.8954 12 12 12ZM9 16C9 14.3431 10.3431 13 12 13C13.6569 13 15 14.3431 15 16V17H9V16Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 12C13.1046 12 14 11.1046 14 10C14 8.89543 13.1046 8 12 8C10.8954 8 10 8.89543 10 10C10 11.1046 10.8954 12 12 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M4.5 7.88261V13C4.5 17.1421 7.85786 20.5 12 20.5C16.1421 20.5 19.5 17.1421 19.5 13V7.88261L12 3.71594L4.5 7.88261ZM12 2L3 7V13C3 17.9706 7.02944 22 12 22C16.9706 22 21 17.9706 21 13V7L12 2Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M9 16C9 14.3431 10.3431 13 12 13C13.6569 13 15 14.3431 15 16V17H9V16Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Cup: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M19 3H3V15C3 18.3137 5.68629 21 9 21H13C16.3137 21 19 18.3137 19 15C21.2091 15 23 13.2091 23 11V7H19V3ZM19 8.5V13.5C20.3807 13.5 21.5 12.3807 21.5 11V8.5H19Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M19 15C19 18.3137 16.3137 21 13 21H9C5.68629 21 3 18.3137 3 15V3H19V7H23V11C23 13.2091 21.2091 15 19 15ZM4.5 4.5H17.5V15C17.5 17.4853 15.4853 19.5 13 19.5H9C6.51472 19.5 4.5 17.4853 4.5 15V4.5ZM19 8.5V13.5C20.3807 13.5 21.5 12.3807 21.5 11V8.5H19Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Pin: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M9.05547 13.884L5.34316 10.1717L6.40382 9.11099L7.11093 9.8181L12.0607 8.40389L15.2427 5.22191L14.182 4.16125L15.2427 3.10059L20.8995 8.75744L19.8389 9.8181L18.7782 8.75744L15.5962 11.9394L14.182 16.8892L14.8891 17.5963L13.8284 18.6569L10.1161 14.9446L4.45928 20.6015L3.39862 19.5408L9.05547 13.884Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12.9686 15.6758L14.2607 11.1536L17.7175 7.69678L16.3033 6.28257L12.8465 9.73939L8.32428 11.0315L12.9686 15.6758ZM20.8995 8.75744L19.8389 9.8181L18.7782 8.75744L15.5962 11.9394L14.182 16.8892L14.8891 17.5963L13.8284 18.6569L10.1161 14.9446L4.45928 20.6015L3.39862 19.5408L9.05547 13.884L5.34316 10.1717L6.40382 9.11099L7.11093 9.8181L12.0607 8.40389L15.2427 5.22191L14.182 4.16125L15.2427 3.10059L20.8995 8.75744Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  VolumeHigh: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M2 16V8H6L12 3V21L6 16H2Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M14 16C16.2091 16 18 14.2091 18 12C18 9.79086 16.2091 8 14 8V9.5C15.3807 9.5 16.5 10.6193 16.5 12C16.5 13.3807 15.3807 14.5 14 14.5V16Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M14 20C18.4183 20 22 16.4183 22 12C22 7.58172 18.4183 4 14 4V5.5C17.5899 5.5 20.5 8.41015 20.5 12C20.5 15.5899 17.5899 18.5 14 18.5V20Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6 8H2V16H6L12 21V3L6 8ZM10.5 6.20256L6.54308 9.5H3.5V14.5H6.54308L10.5 17.7974V6.20256Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M14 16C16.2091 16 18 14.2091 18 12C18 9.79086 16.2091 8 14 8V9.5C15.3807 9.5 16.5 10.6193 16.5 12C16.5 13.3807 15.3807 14.5 14 14.5V16Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M14 20C18.4183 20 22 16.4183 22 12C22 7.58172 18.4183 4 14 4V5.5C17.5899 5.5 20.5 8.41015 20.5 12C20.5 15.5899 17.5899 18.5 14 18.5V20Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  VolumeMute: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M2 16V8H6L12 3V21L6 16H2Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: \"20.2981\",\n        y: \"8.64111\",\n        width: \"1.5\",\n        height: \"8\",\n        transform: \"rotate(45 20.2981 8.64111)\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: \"21.3588\",\n        y: \"14.2983\",\n        width: \"1.5\",\n        height: \"8\",\n        transform: \"rotate(135 21.3588 14.2983)\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M6 8H2V16H6L12 21V3L6 8ZM10.5 6.20256L6.54308 9.5H3.5V14.5H6.54308L10.5 17.7974V6.20256Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: \"20.2981\",\n        y: \"8.64111\",\n        width: \"1.5\",\n        height: \"8\",\n        transform: \"rotate(45 20.2981 8.64111)\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: \"21.3588\",\n        y: \"14.2983\",\n        width: \"1.5\",\n        height: \"8\",\n        transform: \"rotate(135 21.3588 14.2983)\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  File: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M12 2H4V22H20V10H12V2Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M20 8L14 8V2L20 8Z\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M14 2L20 8V22H4V2H14ZM18.5 10H12V3.5H5.5V20.5H18.5V10Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Category: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"rect\", { x: \"3\", y: \"3\", width: \"8\", height: \"8\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"3\", y: \"13\", width: \"8\", height: \"8\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"13\", y: \"3\", width: \"8\", height: \"8\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"13\", y: \"13\", width: \"8\", height: \"8\", fill: \"currentColor\" })\n  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M9.5 4.5H4.5V9.5H9.5V4.5ZM3 3V11H11V3H3Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M9.5 14.5H4.5V19.5H9.5V14.5ZM3 13V21H11V13H3Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M19.5 4.5H14.5V9.5H19.5V4.5ZM13 3V11H21V3H13Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M19.5 14.5H14.5V19.5H19.5V14.5ZM13 13V21H21V13H13Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Peace: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M11.25 2.02783C6.07745 2.41136 2 6.72957 2 12.0001C2 14.236 2.73379 16.3005 3.97368 17.9659L11.25 10.6896V2.02783Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M4.95939 19.1015C6.60053 20.7287 8.8027 21.791 11.25 21.9724V12.8109L4.95939 19.1015Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12.75 21.9724C15.1973 21.791 17.3995 20.7287 19.0406 19.1015L12.75 12.8109V21.9724Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M20.0263 17.9659L12.75 10.6896V2.02783C17.9226 2.41136 22 6.72958 22 12.0001C22 14.236 21.2662 16.3005 20.0263 17.9659Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22ZM11.25 12.8108V20.4674C9.2171 20.2896 7.38933 19.3963 6.02005 18.0407L11.25 12.8108ZM11.25 10.6894L5.04777 16.8917C4.07268 15.5084 3.5 13.8211 3.5 12C3.5 7.55831 6.90686 3.91233 11.25 3.53263V10.6894ZM12.75 12.8108V20.4674C14.7829 20.2896 16.6107 19.3963 17.9799 18.0407L12.75 12.8108ZM18.9522 16.8917L12.75 10.6895V3.53263C17.0931 3.91233 20.5 7.55831 20.5 12C20.5 13.8211 19.9273 15.5084 18.9522 16.8917Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Eye: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12 19C18.0751 19 23 12 23 12C23 12 18.0751 5 12 5C5.92487 5 1 12 1 12C1 12 5.92487 19 12 19ZM12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3431 10.3431 9 12 9C13.6569 9 15 10.3431 15 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M1 12C1 12 5.92487 19 12 19C18.0751 19 23 12 23 12C23 12 18.0751 5 12 5C5.92487 5 1 12 1 12ZM2.90443 12C2.93793 12.0401 2.97258 12.0813 3.00836 12.1235C3.53083 12.7395 4.28523 13.5585 5.21221 14.3734C7.11461 16.0459 9.51515 17.5 12 17.5C14.4849 17.5 16.8854 16.0459 18.7878 14.3734C19.7148 13.5585 20.4692 12.7395 20.9916 12.1235C21.0274 12.0813 21.0621 12.0401 21.0956 12C21.0621 11.9599 21.0274 11.9187 20.9916 11.8765C20.4692 11.2605 19.7148 10.4415 18.7878 9.62656C16.8854 7.9541 14.4849 6.5 12 6.5C9.51515 6.5 7.11461 7.9541 5.21221 9.62656C4.28523 10.4415 3.53083 11.2605 3.00836 11.8765C2.97258 11.9187 2.93793 11.9599 2.90443 12ZM2.22578 11.1354C2.22576 11.1354 2.22572 11.1354 2.22578 11.1354Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  EyeBlind: (filled) => filled ? /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M4.75213 3.69141L3.69147 4.75207L6.02989 7.09048C3.00297 9.15318 1 12.0001 1 12.0001C1 12.0001 5.92487 19.0001 12 19.0001C13.663 19.0001 15.2399 18.4756 16.6531 17.7137L19.2478 20.3084L20.3085 19.2478L4.75213 3.69141ZM13.5241 14.5847L9.41543 10.476C9.15147 10.9227 9 11.4437 9 12.0001C9 13.657 10.3431 15.0001 12 15.0001C12.5564 15.0001 13.0774 14.8486 13.5241 14.5847Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M13.0954 9.2064C13.8712 9.5108 14.4893 10.129 14.7937 10.9047L19.5699 15.6808C21.6825 13.8727 23 12.0001 23 12.0001C23 12.0001 18.0751 5.00011 12 5.00011C11.0772 5.00011 10.181 5.16161 9.32458 5.43554L13.0954 9.2064Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M4.75213 3.69141L3.69147 4.75207L6.02989 7.09049C3.00297 9.15318 1 12.0001 1 12.0001C1 12.0001 5.92487 19.0001 12 19.0001C13.663 19.0001 15.2399 18.4756 16.6531 17.7137L19.2478 20.3084L20.3085 19.2478L4.75213 3.69141ZM15.5394 16.6L13.5242 14.5848C13.0775 14.8488 12.5565 15.0003 12 15.0003C10.3431 15.0003 9 13.6572 9 12.0003C9 11.4439 9.1515 10.9228 9.4155 10.4761L7.11135 8.17195C6.4387 8.61141 5.80156 9.10856 5.21221 9.62667C4.28523 10.4416 3.53083 11.2607 3.00836 11.8766C2.97258 11.9188 2.93793 11.96 2.90443 12.0001C2.93793 12.0402 2.97258 12.0814 3.00836 12.1236C3.53083 12.7396 4.28523 13.5586 5.21221 14.3736C7.11461 16.046 9.51515 17.5001 12 17.5001C13.2162 17.5001 14.4122 17.1518 15.5394 16.6ZM18.5058 14.6167C18.6009 14.5363 18.6949 14.4552 18.7878 14.3736C19.7148 13.5586 20.4692 12.7396 20.9916 12.1236C21.0274 12.0814 21.0621 12.0402 21.0956 12.0001C21.0621 11.96 21.0274 11.9188 20.9916 11.8766C20.4692 11.2607 19.7148 10.4416 18.7878 9.62667C16.8854 7.95422 14.4849 6.50011 12 6.50011C11.5118 6.50011 11.0268 6.55625 10.5482 6.65915L9.32458 5.43554C10.181 5.16161 11.0772 5.00011 12 5.00011C18.0751 5.00011 23 12.0001 23 12.0001C23 12.0001 21.6825 13.8727 19.5699 15.6808L18.5058 14.6167Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Warning: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22ZM11 14V6H13V14H11ZM11 18V16H13V18H11Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M12 20.5C16.6944 20.5 20.5 16.6944 20.5 12C20.5 7.30558 16.6944 3.5 12 3.5C7.30558 3.5 3.5 7.30558 3.5 12C3.5 16.6944 7.30558 20.5 12 20.5ZM12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"11\", y: \"6\", width: \"2\", height: \"8\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"11\", y: \"16\", width: \"2\", height: \"2\", fill: \"currentColor\" })\n  ] }),\n  Funnel: (filled) => filled ? /* @__PURE__ */ jsx(\"path\", { d: \"M2 4H22V5.5L14 13.5V21H10V13.5L2 5.5V4Z\", fill: \"currentColor\" }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M15 12.5L22 5.5V4H2V5.5L9 12.5V21H15V12.5ZM13.5 19.5V11.8787L19.8787 5.5H4.12132L10.5 11.8787V19.5H13.5Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Bookmark: (filled) => filled ? /* @__PURE__ */ jsx(\"path\", { d: \"M6 3H18V21L12 15L6 21V3Z\", fill: \"currentColor\" }) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M18 21V3H6V21L12 15L18 21ZM7.5 17.3787L12 12.8787L16.5 17.3787V4.5H7.5V17.3787Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Inbox: (filled) => filled ? /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M19 3V14H21V21H3V14H5V3H19ZM6.5 14V4.5H17.5V14H15C15 15.6569 13.6569 17 12 17C10.3431 17 9 15.6569 9 14H6.5Z\",\n      fill: \"currentColor\"\n    }\n  ) : /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M19 3V14H21V21H3V14H5V3H19ZM6.5 14V4.5H17.5V14H14C14 15.1046 13.1046 16 12 16C10.8954 16 10 15.1046 10 14H6.5ZM19.5 15.5V19.5H4.5V15.5H6.5L8.83682 15.5C9.39855 16.6825 10.6038 17.5 12 17.5C13.3962 17.5 14.6015 16.6825 15.1632 15.5L17.5 15.5H19.5Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Hash: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M9.5 3H8V8L3 8V9.5H8V14.5H3V16H8V21H9.5V16L14.5 16V21H16V16H21V14.5H16V9.5H21V8L16 8V3H14.5V8H9.5V3ZM14.5 14.5V9.5L9.5 9.5V14.5L14.5 14.5Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  HashLock: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 8L9.5 8V3H8V8L3 8V9.5H8V14.5H3V16H8V21H9.5V16L14.5 16V21H16V16H21V14.5H16V12H14.5V14.5L9.5 14.5V9.5L12 9.5V8Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M15 4V3C15 1.34315 16.3431 0 18 0C19.6569 0 21 1.34315 21 3V4H22V10H14V4H15ZM19.5 3V4H16.5V3C16.5 2.17157 17.1716 1.5 18 1.5C18.8284 1.5 19.5 2.17157 19.5 3Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  HashGlobe: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M24 5C24 7.76142 21.7614 10 19 10C16.2386 10 14 7.76142 14 5C14 2.23858 16.2386 0 19 0C21.7614 0 24 2.23858 24 5ZM17 7.87266V5L15.7354 3.73543C15.5834 4.12764 15.5 4.55408 15.5 5C15.5 6.18937 16.0933 7.24018 17 7.87266ZM22.5 5C22.5 6.18937 21.9067 7.24018 21 7.87266V6.5H19V5H20V3.5H21V2.12734C21.9067 2.75982 22.5 3.81063 22.5 5Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 8L9.5 8V3H8V8L3 8V9.5H8V14.5H3V16H8V21H9.5V16L14.5 16V21H16V16H21V14.5H16V12H14.5V14.5L9.5 14.5V9.5L12 9.5V8Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  HashSearch: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 8L9.5 8V3H8V8L3 8V9.5H8V14.5H3V16H8V21H9.5V16L14.5 16V21H16V16H21V14.5H16V12H14.5V14.5L9.5 14.5V9.5L12 9.5V8Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M20.0322 7.44642C18.4983 8.35236 16.4895 8.14636 15.1716 6.82843C13.6095 5.26633 13.6095 2.73367 15.1716 1.17157C16.7337 -0.390524 19.2663 -0.390524 20.8284 1.17157C22.2708 2.61393 22.3813 4.88377 21.1601 6.45299L23.3033 8.59619L22.2427 9.65685L20.0322 7.44642ZM19.7678 5.76777C18.7915 6.74408 17.2085 6.74408 16.2322 5.76777C15.2559 4.79146 15.2559 3.20854 16.2322 2.23223C17.2085 1.25592 18.7915 1.25592 19.7678 2.23223C20.7441 3.20854 20.7441 4.79146 19.7678 5.76777Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  HashPlus: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 8L9.5 8V3H8V8L3 8V9.5H8V14.5H3V16H8V21H9.5V16L14.5 16V21H16V16H21V14.5H16V12H14.5V14.5L9.5 14.5V9.5L12 9.5V8Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M19 2H17V5H14V7H17V10H19V7H22V5H19V2Z\", fill: \"currentColor\" })\n  ] }),\n  Space: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M14.4055 9.59452L14.2338 8.5223C13.9568 6.79272 13.4927 5.41447 12.9703 4.51403C12.4033 3.53675 12.013 3.5 12 3.5C11.987 3.5 11.5967 3.53675 11.0297 4.51403C10.5073 5.41447 10.0432 6.79272 9.76623 8.5223L9.59452 9.59452L8.5223 9.76623C6.79272 10.0432 5.41447 10.5073 4.51403 11.0297C3.53675 11.5967 3.5 11.987 3.5 12C3.5 12.013 3.53675 12.4033 4.51403 12.9703C5.41447 13.4927 6.79272 13.9568 8.5223 14.2338L9.59452 14.4055L9.76623 15.4777C10.0432 17.2073 10.5073 18.5855 11.0297 19.486C11.5967 20.4633 11.987 20.5 12 20.5C12.013 20.5 12.4033 20.4633 12.9703 19.486C13.4927 18.5855 13.9568 17.2073 14.2338 15.4777L14.4055 14.4055L15.4777 14.2338C17.2073 13.9568 18.5855 13.4927 19.486 12.9703C20.4633 12.4033 20.5 12.013 20.5 12C20.5 11.987 20.4633 11.5967 19.486 11.0297C18.5855 10.5073 17.2073 10.0432 15.4777 9.76623L14.4055 9.59452ZM15.7149 15.7149C19.3983 15.125 22 13.684 22 12C22 10.316 19.3983 8.87498 15.7149 8.28511C15.125 4.60173 13.684 2 12 2C10.316 2 8.87498 4.60173 8.28511 8.28511C4.60173 8.87498 2 10.316 2 12C2 13.684 4.60173 15.125 8.28511 15.7149C8.87498 19.3983 10.316 22 12 22C13.684 22 15.125 19.3983 15.7149 15.7149Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  SpaceLock: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 2C10.316 2 8.87498 4.60173 8.28511 8.28511C4.60173 8.87498 2 10.316 2 12C2 13.684 4.60173 15.125 8.28511 15.7149C8.87498 19.3983 10.316 22 12 22C13.684 22 15.125 19.3983 15.7149 15.7149C19.3983 15.125 22 13.684 22 12H20.5C20.5 12.013 20.4633 12.4033 19.486 12.9703C18.5855 13.4927 17.2073 13.9568 15.4777 14.2338L14.4055 14.4055L14.2338 15.4777C13.9568 17.2073 13.4927 18.5855 12.9703 19.486C12.4033 20.4633 12.013 20.5 12 20.5C11.987 20.5 11.5967 20.4633 11.0297 19.486C10.5073 18.5855 10.0432 17.2073 9.76623 15.4777L9.59452 14.4055L8.5223 14.2338C6.79272 13.9568 5.41447 13.4927 4.51403 12.9703C3.53675 12.4033 3.5 12.013 3.5 12C3.5 11.987 3.53675 11.5967 4.51403 11.0297C5.41447 10.5073 6.79272 10.0432 8.5223 9.76623L9.59452 9.59452L9.76623 8.5223C10.0432 6.79272 10.5073 5.41447 11.0297 4.51403C11.5967 3.53675 11.987 3.5 12 3.5V2Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M15 4V3C15 1.34315 16.3431 0 18 0C19.6569 0 21 1.34315 21 3V4H22V10H14V4H15ZM19.5 3V4H16.5V3C16.5 2.17157 17.1716 1.5 18 1.5C18.8284 1.5 19.5 2.17157 19.5 3Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  SpaceGlobe: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M24 5C24 7.76142 21.7614 10 19 10C16.2386 10 14 7.76142 14 5C14 2.23858 16.2386 0 19 0C21.7614 0 24 2.23858 24 5ZM17 7.87266V5L15.7354 3.73543C15.5834 4.12764 15.5 4.55408 15.5 5C15.5 6.18937 16.0933 7.24018 17 7.87266ZM22.5 5C22.5 6.18937 21.9067 7.24018 21 7.87266V6.5H19V5H20V3.5H21V2.12734C21.9067 2.75982 22.5 3.81063 22.5 5Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 2C10.316 2 8.87498 4.60173 8.28511 8.28511C4.60173 8.87498 2 10.316 2 12C2 13.684 4.60173 15.125 8.28511 15.7149C8.87498 19.3983 10.316 22 12 22C13.684 22 15.125 19.3983 15.7149 15.7149C19.3983 15.125 22 13.684 22 12H20.5C20.5 12.013 20.4633 12.4033 19.486 12.9703C18.5855 13.4927 17.2073 13.9568 15.4777 14.2338L14.4055 14.4055L14.2338 15.4777C13.9568 17.2073 13.4927 18.5855 12.9703 19.486C12.4033 20.4633 12.013 20.5 12 20.5C11.987 20.5 11.5967 20.4633 11.0297 19.486C10.5073 18.5855 10.0432 17.2073 9.76623 15.4777L9.59452 14.4055L8.5223 14.2338C6.79272 13.9568 5.41447 13.4927 4.51403 12.9703C3.53675 12.4033 3.5 12.013 3.5 12C3.5 11.987 3.53675 11.5967 4.51403 11.0297C5.41447 10.5073 6.79272 10.0432 8.5223 9.76623L9.59452 9.59452L9.76623 8.5223C10.0432 6.79272 10.5073 5.41447 11.0297 4.51403C11.5967 3.53675 11.987 3.5 12 3.5V2Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  SpaceSearch: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 2C10.316 2 8.87498 4.60173 8.28511 8.28511C4.60173 8.87498 2 10.316 2 12C2 13.684 4.60173 15.125 8.28511 15.7149C8.87498 19.3983 10.316 22 12 22C13.684 22 15.125 19.3983 15.7149 15.7149C19.3983 15.125 22 13.684 22 12H20.5C20.5 12.013 20.4633 12.4033 19.486 12.9703C18.5855 13.4927 17.2073 13.9568 15.4777 14.2338L14.4055 14.4055L14.2338 15.4777C13.9568 17.2073 13.4927 18.5855 12.9703 19.486C12.4033 20.4633 12.013 20.5 12 20.5C11.987 20.5 11.5967 20.4633 11.0297 19.486C10.5073 18.5855 10.0432 17.2073 9.76623 15.4777L9.59452 14.4055L8.5223 14.2338C6.79272 13.9568 5.41447 13.4927 4.51403 12.9703C3.53675 12.4033 3.5 12.013 3.5 12C3.5 11.987 3.53675 11.5967 4.51403 11.0297C5.41447 10.5073 6.79272 10.0432 8.5223 9.76623L9.59452 9.59452L9.76623 8.5223C10.0432 6.79272 10.5073 5.41447 11.0297 4.51403C11.5967 3.53675 11.987 3.5 12 3.5V2Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M20.0322 7.44642C18.4983 8.35236 16.4895 8.14636 15.1716 6.82843C13.6095 5.26633 13.6095 2.73367 15.1716 1.17157C16.7337 -0.390524 19.2663 -0.390524 20.8284 1.17157C22.2708 2.61393 22.3813 4.88377 21.1601 6.45299L23.3033 8.59619L22.2427 9.65685L20.0322 7.44642ZM19.7678 5.76777C18.7915 6.74408 17.2085 6.74408 16.2322 5.76777C15.2559 4.79146 15.2559 3.20854 16.2322 2.23223C17.2085 1.25592 18.7915 1.25592 19.7678 2.23223C20.7441 3.20854 20.7441 4.79146 19.7678 5.76777Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  SpacePlus: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12 2C10.316 2 8.87498 4.60173 8.28511 8.28511C4.60173 8.87498 2 10.316 2 12C2 13.684 4.60173 15.125 8.28511 15.7149C8.87498 19.3983 10.316 22 12 22C13.684 22 15.125 19.3983 15.7149 15.7149C19.3983 15.125 22 13.684 22 12H20.5C20.5 12.013 20.4633 12.4033 19.486 12.9703C18.5855 13.4927 17.2073 13.9568 15.4777 14.2338L14.4055 14.4055L14.2338 15.4777C13.9568 17.2073 13.4927 18.5855 12.9703 19.486C12.4033 20.4633 12.013 20.5 12 20.5C11.987 20.5 11.5967 20.4633 11.0297 19.486C10.5073 18.5855 10.0432 17.2073 9.76623 15.4777L9.59452 14.4055L8.5223 14.2338C6.79272 13.9568 5.41447 13.4927 4.51403 12.9703C3.53675 12.4033 3.5 12.013 3.5 12C3.5 11.987 3.53675 11.5967 4.51403 11.0297C5.41447 10.5073 6.79272 10.0432 8.5223 9.76623L9.59452 9.59452L9.76623 8.5223C10.0432 6.79272 10.5073 5.41447 11.0297 4.51403C11.5967 3.53675 11.987 3.5 12 3.5V2Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M19 2H17V5H14V7H17V10H19V7H22V5H19V2Z\", fill: \"currentColor\" })\n  ] }),\n  ChevronRight: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M16.1421 12L9.07107 4.92893L8.01041 5.98959L14.0208 12L8.01041 18.0104L9.07107 19.0711L16.1421 12Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ChevronLeft: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M6.85786 12L13.9289 19.0711L14.9896 18.0104L8.97918 12L14.9896 5.98959L13.9289 4.92893L6.85786 12Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ChevronTop: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12 6.85786L4.92893 13.9289L5.98959 14.9896L12 8.97918L18.0104 14.9896L19.0711 13.9289L12 6.85786Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ChevronBottom: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12 17.1421L19.0711 10.0711L18.0104 9.01041L12 15.0208L5.98959 9.01041L4.92893 10.0711L12 17.1421Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Plus: () => /* @__PURE__ */ jsx(\"path\", { d: \"M13 5H11V11H5V13H11V19H13V13H19V11H13V5Z\", fill: \"currentColor\" }),\n  Minus: () => /* @__PURE__ */ jsx(\"rect\", { x: \"5\", y: \"11\", width: \"14\", height: \"2\", fill: \"currentColor\" }),\n  Cross: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M7.58056 6.51993L6.5199 7.58059L10.9393 12L6.5199 16.4194L7.58056 17.4801L12 13.0607L16.4194 17.4801L17.4801 16.4194L13.0606 12L17.4801 7.58059L16.4194 6.51993L12 10.9393L7.58056 6.51993Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  VerticalDots: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"rect\", { x: \"10\", y: \"3\", width: \"4\", height: \"4\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"10\", y: \"10\", width: \"4\", height: \"4\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"10\", y: \"17\", width: \"4\", height: \"4\", fill: \"currentColor\" })\n  ] }),\n  HorizontalDots: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"rect\", { x: \"3\", y: \"10\", width: \"4\", height: \"4\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"10\", y: \"10\", width: \"4\", height: \"4\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"17\", y: \"10\", width: \"4\", height: \"4\", fill: \"currentColor\" })\n  ] }),\n  Check: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M9.52513 17.9246L4.57538 12.9749L5.63604 11.9142L9.52513 15.8033L18.364 6.96448L19.4246 8.02514L9.52513 17.9246Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  CheckTwice: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M2.95404 12.4749L7.90379 17.4246L8.96445 16.364L4.0147 11.4142L2.95404 12.4749Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M11.0858 12.1213L12.1464 13.182L17.8033 7.52514L16.7426 6.46448L11.0858 12.1213Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M12.1465 17.4246L7.19672 12.4749L8.25738 11.4142L12.1465 15.3033L20.9853 6.46448L22.046 7.52514L12.1465 17.4246Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Download: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 14H4.5V19.5H19.5V14H21V21H3V14Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M11.25 3H12.75V15H11.25V3Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M8.82067 11.6993L7.76001 12.76L12.0027 17.0027L16.2453 12.76L15.1846 11.6993L12.0027 14.8813L8.82067 11.6993Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  External: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M12 3H3V21H21V12H19.5V19.5H4.5V4.5H12V3Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M14 4.5V3H21V10L19.5 10V4.5H14Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: \"11.9341\",\n        y: \"11.0052\",\n        width: \"10\",\n        height: \"1.5\",\n        transform: \"rotate(-45 11.9341 11.0052)\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  RecentClock: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M20.5 12C20.5 16.6944 16.6944 20.5 12 20.5C7.30558 20.5 3.5 16.6944 3.5 12H2C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C8.29859 2 5.06687 4.01099 3.33782 7H5.1254C6.67093 4.87867 9.17446 3.5 12 3.5C16.6944 3.5 20.5 7.30558 20.5 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M4.5 3H3V8H8V6.5H4.5V3Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M11 7L13 6.99997L13 11.5858L16.9498 15.5355L15.5355 16.9497L11 12.4142L11 7Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Power: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M17.3033 6.69671C18.6605 8.05394 19.5 9.92894 19.5 12C19.5 16.1421 16.1421 19.5 12 19.5C7.85786 19.5 4.5 16.1421 4.5 12C4.5 9.92894 5.33947 8.05394 6.6967 6.69671L5.63604 5.63605C4.00736 7.26473 3 9.51473 3 12C3 16.9706 7.02944 21 12 21C16.9706 21 21 16.9706 21 12C21 9.51473 19.9926 7.26473 18.364 5.63605L17.3033 6.69671Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"11\", y: \"2\", width: \"2\", height: \"10\", fill: \"currentColor\" })\n  ] }),\n  ReplyArrow: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M21 9.5V8H7V16H8.5V9.5H21Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M4.56066 12.6993L3.5 13.76L7.74264 18.0027L11.9853 13.76L10.9246 12.6993L7.74264 15.8813L4.56066 12.6993Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  ArrowGoRight: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M18.124 13H8C5.23858 13 3 10.7614 3 8C3 5.23858 5.23858 3 8 3V4.5C6.067 4.5 4.5 6.067 4.5 8C4.5 9.933 6.067 11.5 8 11.5H18.1387L15.6993 9.06067L16.76 8.00001L21.0027 12.2427L16.76 16.4853L15.6993 15.4246L18.124 13Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ArrowGoRightPlus: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M18.124 13H8C5.23858 13 3 10.7614 3 8C3 5.23858 5.23858 3 8 3V4.5C6.067 4.5 4.5 6.067 4.5 8C4.5 9.933 6.067 11.5 8 11.5H18.1387L15.6993 9.06067L16.76 8.00001L21.0027 12.2427L16.76 16.4853L15.6993 15.4246L18.124 13Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M4 15H6V23H4V15Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M9 18L9 20L1 20L1 18L9 18Z\", fill: \"currentColor\" })\n  ] }),\n  ArrowGoRightCross: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M2.7019 14.6412L1.64124 15.7019L3.93933 18L1.64124 20.2981L2.7019 21.3587L4.99999 19.0607L7.29809 21.3587L8.35875 20.2981L6.06065 18L8.35875 15.7019L7.29809 14.6412L4.99999 16.9393L2.7019 14.6412Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M18.124 13H8C5.23858 13 3 10.7614 3 8C3 5.23858 5.23858 3 8 3V4.5C6.067 4.5 4.5 6.067 4.5 8C4.5 9.933 6.067 11.5 8 11.5H18.1387L15.6993 9.06067L16.76 8.00001L21.0027 12.2427L16.76 16.4853L15.6993 15.4246L18.124 13Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  ArrowGoLeft: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M5.87871 13H16.0027C18.7641 13 21.0027 10.7614 21.0027 8C21.0027 5.23858 18.7641 3 16.0027 3V4.5C17.9357 4.5 19.5027 6.067 19.5027 8C19.5027 9.933 17.9357 11.5 16.0027 11.5H5.86401L8.30334 9.06067L7.24268 8.00001L3.00003 12.2427L7.24268 16.4853L8.30334 15.4246L5.87871 13Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Markdown: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M17.25 13V8H15.75V13H14L16.5 15.5L19 13H17.25Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M20.5 5.5H3.5V18.5H20.5V5.5ZM2 4V20H22V4H2Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M6.5 11L9 12.875L11.5 11V15.5H13V8L9 11L5 8V15.5H6.5V11Z\", fill: \"currentColor\" })\n  ] }),\n  Attachment: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M9.17158 4.92891L2.80762 11.2929L3.86828 12.3535L10.2322 5.98957C12.3801 3.84169 15.8625 3.84169 18.0104 5.98957C20.1583 8.13746 20.1583 11.6199 18.0104 13.7677L12.3536 19.4246C10.9867 20.7914 8.77065 20.7914 7.40381 19.4246C6.03698 18.0578 6.03698 15.8417 7.40381 14.4749L13.0607 8.818C13.6465 8.23222 14.5962 8.23222 15.182 8.818C15.7678 9.40379 15.7678 10.3535 15.182 10.9393L9.52513 16.5962L10.5858 17.6568L16.2426 12C17.4142 10.8284 17.4142 8.92892 16.2426 7.75734C15.0711 6.58577 13.1716 6.58577 12 7.75734L6.34315 13.4142C4.39053 15.3668 4.39053 18.5326 6.34315 20.4853C8.29577 22.4379 11.4616 22.4379 13.4142 20.4853L19.0711 14.8284C21.8047 12.0947 21.8047 7.66258 19.0711 4.92891C16.3374 2.19524 11.9052 2.19524 9.17158 4.92891Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Alphabet: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M3 18L7 5H9L13 18H11.5L10.4348 14.5H5.56522L4.5 18H3ZM6.02174 13H9.97826L8 6.5L6.02174 13Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M16.9773 18.0455C16.4242 18.0455 15.9223 17.9413 15.4716 17.733C15.0208 17.5208 14.6629 17.2159 14.3977 16.8182C14.1326 16.4167 14 15.9318 14 15.3636C14 14.8636 14.0985 14.4583 14.2955 14.1477C14.4924 13.8333 14.7557 13.5871 15.0852 13.4091C15.4148 13.2311 15.7784 13.0985 16.1761 13.0114C16.5777 12.9205 16.9811 12.8485 17.3864 12.7955C17.9167 12.7273 18.3466 12.6761 18.6761 12.642C19.0095 12.6042 19.2519 12.5417 19.4034 12.4545C19.5587 12.3674 19.6364 12.2159 19.6364 12V11.9545C19.6364 11.3939 19.483 10.9583 19.1761 10.6477C18.8731 10.3371 18.4129 10.1818 17.7955 10.1818C17.1553 10.1818 16.6534 10.322 16.2898 10.6023C15.9261 10.8826 15.6705 11.1818 15.5227 11.5L14.25 11.0455C14.4773 10.5152 14.7803 10.1023 15.1591 9.80682C15.5417 9.50758 15.9583 9.29924 16.4091 9.18182C16.8636 9.06061 17.3106 9 17.75 9C18.0303 9 18.3523 9.03409 18.7159 9.10227C19.0833 9.16667 19.4375 9.30114 19.7784 9.50568C20.1231 9.71023 20.4091 10.0189 20.6364 10.4318C20.8636 10.8447 20.9773 11.3977 20.9773 12.0909V17.8409H19.6364V16.6591H19.5682C19.4773 16.8485 19.3258 17.0511 19.1136 17.267C18.9015 17.483 18.6193 17.6667 18.267 17.8182C17.9148 17.9697 17.4848 18.0455 16.9773 18.0455ZM17.1818 16.8409C17.7121 16.8409 18.1591 16.7367 18.5227 16.5284C18.8902 16.3201 19.1667 16.0511 19.3523 15.7216C19.5417 15.392 19.6364 15.0455 19.6364 14.6818V13.4545C19.5795 13.5227 19.4545 13.5852 19.2614 13.642C19.072 13.6951 18.8523 13.7424 18.6023 13.7841C18.3561 13.822 18.1155 13.8561 17.8807 13.8864C17.6496 13.9129 17.4621 13.9356 17.3182 13.9545C16.9697 14 16.6439 14.0739 16.3409 14.1761C16.0417 14.2746 15.7992 14.4242 15.6136 14.625C15.4318 14.822 15.3409 15.0909 15.3409 15.4318C15.3409 15.8977 15.5133 16.25 15.858 16.4886C16.2064 16.7235 16.6477 16.8409 17.1818 16.8409Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  AlphabetUnderline: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M3 17L7 4H9L13 17H11.5L10.4348 13.5H5.56522L4.5 17H3ZM6.02174 12H9.97826L8 5.5L6.02174 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M16.9773 17.0455C16.4242 17.0455 15.9223 16.9413 15.4716 16.733C15.0208 16.5208 14.6629 16.2159 14.3977 15.8182C14.1326 15.4167 14 14.9318 14 14.3636C14 13.8636 14.0985 13.4583 14.2955 13.1477C14.4924 12.8333 14.7557 12.5871 15.0852 12.4091C15.4148 12.2311 15.7784 12.0985 16.1761 12.0114C16.5777 11.9205 16.9811 11.8485 17.3864 11.7955C17.9167 11.7273 18.3466 11.6761 18.6761 11.642C19.0095 11.6042 19.2519 11.5417 19.4034 11.4545C19.5587 11.3674 19.6364 11.2159 19.6364 11V10.9545C19.6364 10.3939 19.483 9.95833 19.1761 9.64773C18.8731 9.33712 18.4129 9.18182 17.7955 9.18182C17.1553 9.18182 16.6534 9.32197 16.2898 9.60227C15.9261 9.88258 15.6705 10.1818 15.5227 10.5L14.25 10.0455C14.4773 9.51515 14.7803 9.10227 15.1591 8.80682C15.5417 8.50758 15.9583 8.29924 16.4091 8.18182C16.8636 8.06061 17.3106 8 17.75 8C18.0303 8 18.3523 8.03409 18.7159 8.10227C19.0833 8.16667 19.4375 8.30114 19.7784 8.50568C20.1231 8.71023 20.4091 9.01894 20.6364 9.43182C20.8636 9.8447 20.9773 10.3977 20.9773 11.0909V16.8409H19.6364V15.6591H19.5682C19.4773 15.8485 19.3258 16.0511 19.1136 16.267C18.9015 16.483 18.6193 16.6667 18.267 16.8182C17.9148 16.9697 17.4848 17.0455 16.9773 17.0455ZM17.1818 15.8409C17.7121 15.8409 18.1591 15.7367 18.5227 15.5284C18.8902 15.3201 19.1667 15.0511 19.3523 14.7216C19.5417 14.392 19.6364 14.0455 19.6364 13.6818V12.4545C19.5795 12.5227 19.4545 12.5852 19.2614 12.642C19.072 12.6951 18.8523 12.7424 18.6023 12.7841C18.3561 12.822 18.1155 12.8561 17.8807 12.8864C17.6496 12.9129 17.4621 12.9356 17.3182 12.9545C16.9697 13 16.6439 13.0739 16.3409 13.1761C16.0417 13.2746 15.7992 13.4242 15.6136 13.625C15.4318 13.822 15.3409 14.0909 15.3409 14.4318C15.3409 14.8977 15.5133 15.25 15.858 15.4886C16.2064 15.7235 16.6477 15.8409 17.1818 15.8409Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M2 18.5H22V20H2V18.5Z\", fill: \"currentColor\" })\n  ] }),\n  Text: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M6 5.5V4H18V5.5H6Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M11.25 5H12.75V19H11.25V5Z\", fill: \"currentColor\" })\n  ] }),\n  Heading1: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M20 20H18.5V13H17V12L20 11V20Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 20V4H4.5V11H12.5V4H14V20H12.5V12.5H4.5V20H3Z\", fill: \"currentColor\" })\n  ] }),\n  Heading2: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 20V4H4.5V11H12.5V4H14V20H12.5V12.5H4.5V20H3Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M21 20V18.5H18L20.0072 16.1583C20.6478 15.4109 21 14.4589 21 13.4744C21 12.1078 19.8794 11 18.5129 11C17.1321 11 16 12.1193 16 13.5V14H17.5V13.5C17.5 12.9477 17.9477 12.5 18.5 12.5C19.0523 12.5 19.5 12.9477 19.5 13.5V13.7485C19.5 14.233 19.3242 14.701 19.0052 15.0655L16 18.5V20H21Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Heading3: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 20V4H4.5V11H12.5V4H14V20H12.5V12.5H4.5V20H3Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M18.5 11C17.2905 11 16.2816 11.8589 16.05 13L17.6338 13C17.8067 12.7011 18.1298 12.5 18.5 12.5C19.0523 12.5 19.5 12.9477 19.5 13.5V13.75C19.5 14.3023 19.0523 14.75 18.5 14.75H18V16.25H18.5C19.0523 16.25 19.5 16.6977 19.5 17.25V17.5C19.5 18.0523 19.0523 18.5 18.5 18.5C18.1298 18.5 17.8067 18.2989 17.6338 18L16.05 18C16.2816 19.1411 17.2905 20 18.5 20C19.8807 20 21 18.8807 21 17.5V17.25C21 16.5686 20.7274 15.9509 20.2853 15.5C20.7274 15.0491 21 14.4314 21 13.75V13.5C21 12.1193 19.8807 11 18.5 11Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Bold: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      d: \"M14.5013 11.6717C15.4198 10.8697 16 9.69009 16 8.375C16 5.95875 14.0412 4 11.625 4H7V20H12.625C15.0412 20 17 18.0412 17 15.625C17 13.8803 15.9787 12.3741 14.5013 11.6717ZM8.5 5.5H11.625C13.2128 5.5 14.5 6.78718 14.5 8.375C14.5 9.96282 13.2128 11.25 11.625 11.25H8.5V5.5ZM8.5 12.75V18.5H12.625C14.2128 18.5 15.5 17.2128 15.5 15.625C15.5 14.0372 14.2128 12.75 12.625 12.75H8.5Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Italic: () => /* @__PURE__ */ jsx(\"path\", { d: \"M18 4H10V5.5H13.5L9 18.5H6V20H14V18.5H10.5L15 5.5H18V4Z\", fill: \"currentColor\" }),\n  Underline: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M8.5 5H7V12C7 14.7614 9.23858 17 12 17C14.7614 17 17 14.7614 17 12V5H15.5V12C15.5 13.933 13.933 15.5 12 15.5C10.067 15.5 8.5 13.933 8.5 12V5Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M5 18.5V20H19V18.5H5Z\", fill: \"currentColor\" })\n  ] }),\n  Strike: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M6.75 8.25C6.75 5.90279 8.65279 4 11 4H12.75C14.6622 4 16.2794 5.26283 16.8132 7H15.2001C14.745 6.10958 13.8187 5.5 12.75 5.5H11C9.48122 5.5 8.25 6.73122 8.25 8.25C8.25 9.76878 9.48122 11 11 11H20V12.5H4V11H7.75952C7.12987 10.2588 6.75 9.29875 6.75 8.25Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M14.8714 14H16.6241C16.8656 14.5337 17 15.1261 17 15.75C17 18.0972 15.0972 20 12.75 20H11C9.08782 20 7.47058 18.7372 6.9368 17H8.54985C9.00503 17.8904 9.93133 18.5 11 18.5H12.75C14.2688 18.5 15.5 17.2688 15.5 15.75C15.5 15.0852 15.2641 14.4755 14.8714 14Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Link: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"rect\", { x: \"8\", y: \"11\", width: \"8\", height: \"2\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M11 7H8C5.23858 7 3 9.23858 3 12C3 14.7614 5.23858 17 8 17H11V15.5H8C6.067 15.5 4.5 13.933 4.5 12C4.5 10.067 6.067 8.5 8 8.5H11V7Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M13 15.5H16C17.933 15.5 19.5 13.933 19.5 12C19.5 10.067 17.933 8.5 16 8.5H13V7H16C18.7614 7 21 9.23858 21 12C21 14.7614 18.7614 17 16 17H13V15.5Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  Code: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M8.30334 8.82067L7.24268 7.76001L3.00004 12.0027L7.24268 16.2453L8.30334 15.1846L5.12136 12.0027L8.30334 8.82067Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M15.6993 8.82067L16.76 7.76001L21.0027 12.0027L16.76 16.2453L15.6993 15.1846L18.8813 12.0027L15.6993 8.82067Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M12.5 6L10 18H11.5L14 6H12.5Z\", fill: \"currentColor\" })\n  ] }),\n  BlockCode: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M10 3H7C5.34315 3 4 4.34315 4 6V10C4 10.5523 3.55228 11 3 11H2V12.5H3C3.55228 12.5 4 12.9477 4 13.5V17.5C4 19.1569 5.34315 20.5 7 20.5H10V19H7C6.17157 19 5.5 18.3284 5.5 17.5V13.5C5.5 12.8186 5.22742 12.2009 4.78536 11.75C5.22742 11.2991 5.5 10.6814 5.5 10V6C5.5 5.17157 6.17157 4.5 7 4.5H10V3Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M13 3H16C17.6569 3 19 4.34315 19 6V10C19 10.5523 19.4477 11 20 11H21V12.5H20C19.4477 12.5 19 12.9477 19 13.5V17.5C19 19.1569 17.6569 20.5 16 20.5H13V19H16C16.8284 19 17.5 18.3284 17.5 17.5V13.5C17.5 12.8186 17.7726 12.2009 18.2146 11.75C17.7726 11.2991 17.5 10.6814 17.5 10V6C17.5 5.17157 16.8284 4.5 16 4.5H13V3Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  BlockQuote: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M21 6H18C15.2386 6 13 8.23858 13 11V20H21V12H14.5V11C14.5 9.067 16.067 7.5 18 7.5H21V6ZM19.5 13.5H14.5V18.5H19.5V13.5Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M3 20H11V12H4.5V11C4.5 9.067 6.067 7.5 8 7.5H11V6H8C5.23858 6 3 8.23858 3 11V20ZM9.5 13.5H4.5V18.5H9.5V13.5Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  OrderList: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M8 5H22V6.5H8V5Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M8 11H22V12.5H8V11Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M8 17.5H22V19H8V17.5Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M4 11H3V5.55556H2V4.77778L4 4V11Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M6 20V18.8333H3.6L5.20573 17.012C5.71827 16.4307 6 15.6902 6 14.9245C6 13.8617 5.10355 13 4.01028 13C2.90571 13 2 13.8706 2 14.9444V15.3333H3.2V14.9444C3.2 14.5149 3.55817 14.1667 4 14.1667C4.44183 14.1667 4.8 14.5149 4.8 14.9444V15.1377C4.8 15.5145 4.65933 15.8785 4.40412 16.1621L2 18.8333V20H6Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  UnorderList: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M8 5H22V6.5H8V5Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M8 11H22V12.5H8V11Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M8 17.5H22V19H8V17.5Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"3\", y: \"5\", width: \"2\", height: \"2\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"3\", y: \"11\", width: \"2\", height: \"2\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"rect\", { x: \"3\", y: \"17\", width: \"2\", height: \"2\", fill: \"currentColor\" })\n  ] }),\n  Mention: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12.4105 21.527C10.8892 21.527 9.54441 21.3182 8.37608 20.9006C7.20776 20.488 6.22587 19.8789 5.43041 19.0735C4.63496 18.2681 4.0334 17.2813 3.62573 16.113C3.21806 14.9446 3.01422 13.6073 3.01422 12.1009C3.01422 10.6442 3.22054 9.34165 3.63318 8.19321C4.0508 7.04478 4.65485 6.07035 5.44533 5.26992C6.24078 4.46452 7.20527 3.85053 8.3388 3.42795C9.47729 3.00536 10.7649 2.79407 12.2017 2.79407C13.5987 2.79407 14.8217 3.02276 15.8708 3.48015C16.9247 3.93256 17.8047 4.54655 18.5107 5.32212C19.2216 6.09272 19.7536 6.96026 20.1066 7.92475C20.4645 8.88924 20.6435 9.88356 20.6435 10.9077C20.6435 11.6286 20.6087 12.3594 20.5391 13.1002C20.4695 13.8409 20.3228 14.5221 20.0991 15.1435C19.8754 15.76 19.5298 16.2571 19.0625 16.635C18.6002 17.0128 17.9737 17.2017 17.1833 17.2017C16.8352 17.2017 16.4524 17.1471 16.0348 17.0377C15.6172 16.9283 15.2468 16.7468 14.9237 16.4933C14.6005 16.2397 14.4091 15.8992 14.3494 15.4716H14.26C14.1406 15.76 13.9567 16.0334 13.7081 16.2919C13.4645 16.5505 13.1438 16.7568 12.7461 16.9109C12.3534 17.065 11.8736 17.1321 11.3068 17.1122C10.6605 17.0874 10.0913 16.9432 9.59909 16.6797C9.10691 16.4113 8.69426 16.0483 8.36117 15.5909C8.03304 15.1286 7.78446 14.5941 7.61543 13.9876C7.45137 13.3761 7.36933 12.7174 7.36933 12.0114C7.36933 11.3402 7.46877 10.7262 7.66763 10.1694C7.86649 9.6126 8.14242 9.12539 8.4954 8.70777C8.85336 8.29016 9.27097 7.95706 9.74824 7.70849C10.2305 7.45493 10.75 7.29833 11.3068 7.23867C11.804 7.18895 12.2564 7.21133 12.6641 7.30579C13.0717 7.39528 13.4073 7.53199 13.6708 7.71594C13.9343 7.89492 14.1009 8.09378 14.1705 8.31253H14.26V7.47731H15.8409V14.2188C15.8409 14.6364 15.9578 15.0043 16.1914 15.3225C16.4251 15.6407 16.7656 15.7997 17.2131 15.7997C17.7202 15.7997 18.108 15.6257 18.3764 15.2777C18.6499 14.9297 18.8363 14.3928 18.9357 13.6669C19.0401 12.9411 19.0923 12.0114 19.0923 10.8779C19.0923 10.2117 19.0004 9.55543 18.8164 8.90912C18.6374 8.25785 18.364 7.64883 17.9961 7.08207C17.6332 6.5153 17.1733 6.01566 16.6165 5.58313C16.0597 5.1506 15.4059 4.81253 14.6552 4.56893C13.9095 4.32035 13.0618 4.19606 12.1122 4.19606C10.9439 4.19606 9.89739 4.37752 8.97267 4.74045C8.05293 5.0984 7.2699 5.6229 6.6236 6.31395C5.98226 7.00003 5.49256 7.83526 5.15449 8.81964C4.82139 9.79904 4.65485 10.9127 4.65485 12.1605C4.65485 13.4283 4.82139 14.5544 5.15449 15.5387C5.49256 16.5231 5.98972 17.3534 6.64597 18.0295C7.30719 18.7056 8.12502 19.2177 9.09945 19.5657C10.0739 19.9187 11.1975 20.0952 12.4702 20.0952C13.0171 20.0952 13.5565 20.043 14.0884 19.9386C14.6204 19.8342 15.0902 19.7198 15.4979 19.5956C15.9056 19.4713 16.1989 19.3793 16.3779 19.3196L16.7955 20.6918C16.4872 20.8211 16.0845 20.9503 15.5874 21.0796C15.0952 21.2088 14.5682 21.3157 14.0064 21.4002C13.4496 21.4848 12.9176 21.527 12.4105 21.527ZM11.5455 15.5909C12.2117 15.5909 12.7511 15.4567 13.1637 15.1882C13.5764 14.9198 13.8771 14.5146 14.0661 13.9727C14.255 13.4308 14.3494 12.7472 14.3494 11.9219C14.3494 11.0867 14.245 10.4354 14.0362 9.96807C13.8274 9.50074 13.5192 9.17262 13.1115 8.9837C12.7039 8.79478 12.2017 8.70032 11.6051 8.70032C11.0384 8.70032 10.5536 8.84947 10.1509 9.14776C9.75321 9.44108 9.44746 9.83384 9.23368 10.326C9.02488 10.8132 8.92047 11.3452 8.92047 11.9219C8.92047 12.5583 9.00499 13.1573 9.17402 13.7191C9.34306 14.276 9.61898 14.7284 10.0018 15.0764C10.3846 15.4194 10.8992 15.5909 11.5455 15.5909Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Filter: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 5H21V6.5H3V5Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M6 11H18V12.5H6V11Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M9 17.5H15V19H9V17.5Z\", fill: \"currentColor\" })\n  ] }),\n  Sort: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 5H21V6.5H3V5Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 11H15V12.5H3V11Z\", fill: \"currentColor\" }),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M3 17.5H9V19H3V17.5Z\", fill: \"currentColor\" })\n  ] }),\n  ArrowUpDown: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M7.99999 5.87868L7.99998 16L6.49999 16L6.49999 5.86398L4.06066 8.30331L3 7.24264L7.24264 3.00001L11.4853 7.24264L10.4246 8.30331L7.99999 5.87868Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M16 18.1213L16 8.00002L17.5 8L17.5 18.136L19.9393 15.6967L21 16.7574L16.7574 21L12.5147 16.7574L13.5754 15.6967L16 18.1213Z\",\n        fill: \"currentColor\"\n      }\n    )\n  ] }),\n  ArrowRight: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M18.124 12.6993H3.00002L3 11.1993L18.1387 11.1993L13 6.06064L14.0607 4.99998L21.0027 11.942L14.0607 18.8839L13 17.8233L18.124 12.6993Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ArrowLeft: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M5.8787 11.244L21.0027 11.244L21.0027 12.744L5.864 12.744L11.0027 17.8827L9.94203 18.9434L3.00003 12.0014L9.94203 5.05943L11.0027 6.12009L5.8787 11.244Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ArrowTop: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12.7587 5.81938L12.7587 20.9433L11.2587 20.9434L11.2587 5.80467L6.12003 10.9434L5.05937 9.8827L12.0014 2.94071L18.9433 9.8827L17.8827 10.9434L12.7587 5.81938Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ArrowBottom: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M11.244 18.124L11.244 3.00002L12.744 3L12.744 18.1387L17.8827 13L18.9433 14.0607L12.0013 21.0027L5.05936 14.0607L6.12003 13L11.244 18.124Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ArrowDropRight: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M16.1421 12L9.07108 4.92892L9.00001 4.99999L9.07108 19.0711L16.1421 12Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ArrowDropLeft: () => /* @__PURE__ */ jsx(\"path\", { d: \"M7.85785 12L14.9289 19.0711L15 19L14.9289 4.92894L7.85785 12Z\", fill: \"currentColor\" }),\n  ArrowDropTop: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12 7.85785L4.92892 14.9289L4.99999 15L19.0711 14.9289L12 7.85785Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  ArrowDropBottom: () => /* @__PURE__ */ jsx(\n    \"path\",\n    {\n      d: \"M12 16.1421L19.0711 9.07108L19 9.00001L4.92894 9.07108L12 16.1421Z\",\n      fill: \"currentColor\"\n    }\n  ),\n  Reload: () => /* @__PURE__ */ jsxs(Fragment, { children: [\n    /* @__PURE__ */ jsx(\n      \"path\",\n      {\n        d: \"M20.5 12C20.5 16.6944 16.6944 20.5 12 20.5C7.30558 20.5 3.5 16.6944 3.5 12H2C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C8.29859 2 5.06687 4.01099 3.33782 7H5.1254C6.67093 4.87867 9.17446 3.5 12 3.5C16.6944 3.5 20.5 7.30558 20.5 12Z\",\n        fill: \"currentColor\"\n      }\n    ),\n    /* @__PURE__ */ jsx(\"path\", { d: \"M4.5 3H3V8H8V6.5H4.5V3Z\", fill: \"currentColor\" })\n  ] })\n};\nconst Checkbox_css_ts_vanilla = \"\";\nvar Checkbox$1 = createRuntimeFn({ defaultClassName: \"_1ke4j9q2 _1mqalmd1 _1mqalmd0\", variantClassNames: { size: { \"50\": \"cpipac7\", \"100\": \"cpipac8\", \"200\": \"cpipac9\", \"300\": \"cpipaca\", \"400\": \"cpipacb\", \"500\": \"cpipacc\", \"600\": \"cpipacd\", Inherit: \"cpipac6\" }, variant: { Primary: \"_1ke4j9qb\", Secondary: \"_1ke4j9qc\", Success: \"_1ke4j9qd\", Warning: \"_1ke4j9qe\", Critical: \"_1ke4j9qf\" } }, defaultVariants: { size: \"400\", variant: \"Secondary\" }, compoundVariants: [] });\nvar CheckboxIcon = \"_1ke4j9qh\";\nvar CheckboxInput = \"_1ke4j9qg _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\";\nconst Checkbox = forwardRef(\n  ({ className, variant, size, style, ...props }, ref) => /* @__PURE__ */ jsxs(\"span\", { className: classNames(Checkbox$1({ variant, size }), className), style, children: [\n    /* @__PURE__ */ jsx(\"input\", { className: CheckboxInput, type: \"checkbox\", ...props, ref }),\n    /* @__PURE__ */ jsx(Icon, { className: CheckboxIcon, \"aria-hidden\": true, size, src: Icons.Check })\n  ] })\n);\nconst Chip_css_ts_vanilla = \"\";\nvar Chip$1 = createRuntimeFn({ defaultClassName: \"_1bv8u1w6 _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\", variantClassNames: { variant: { Background: \"_1bv8u1w7\", Surface: \"_1bv8u1w8\", SurfaceVariant: \"_1bv8u1w9\", Primary: \"_1bv8u1wa\", Secondary: \"_1bv8u1wb\", Success: \"_1bv8u1wc\", Warning: \"_1bv8u1wd\", Critical: \"_1bv8u1we\" }, size: { \"400\": \"_1bv8u1wf\", \"500\": \"_1bv8u1wg\" }, fill: { Soft: \"_1bv8u1wh\", None: \"_1bv8u1wi\" }, outlined: { true: \"_1bv8u1wj\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { variant: \"Surface\", fill: \"Soft\", size: \"400\", radii: \"400\" }, compoundVariants: [] });\nconst Chip = as(\n  ({\n    as: AsChip = \"button\",\n    className,\n    variant,\n    fill,\n    size,\n    outlined,\n    radii,\n    before,\n    after,\n    children,\n    ...props\n  }, ref) => /* @__PURE__ */ jsxs(\n    AsChip,\n    {\n      className: classNames(\n        Chip$1({\n          variant,\n          fill,\n          size,\n          outlined,\n          radii\n        }),\n        className\n      ),\n      \"data-ui-before\": before ? true : void 0,\n      \"data-ui-after\": after ? true : void 0,\n      ...props,\n      ref,\n      children: [\n        before,\n        children,\n        after\n      ]\n    }\n  )\n);\nconst Dialog_css_ts_vanilla = \"\";\nvar Dialog$1 = createRuntimeFn({ defaultClassName: \"_5z5e2h1 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Background: \"_5z5e2h2\", Surface: \"_5z5e2h3\", SurfaceVariant: \"_5z5e2h4\", Primary: \"_5z5e2h5\", Secondary: \"_5z5e2h6\", Success: \"_5z5e2h7\", Warning: \"_5z5e2h8\", Critical: \"_5z5e2h9\" } }, defaultVariants: { variant: \"Surface\" }, compoundVariants: [] });\nconst Dialog = as(\n  ({ as: AsDialog = \"div\", className, variant, ...props }, ref) => /* @__PURE__ */ jsx(AsDialog, { className: classNames(Dialog$1({ variant }), className), ...props, ref })\n);\nconst Header_css_ts_vanilla = \"\";\nvar Header$1 = createRuntimeFn({ defaultClassName: \"hru6be0 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Background: \"hru6be1\", Surface: \"hru6be2\", SurfaceVariant: \"hru6be3\", Primary: \"hru6be4\", Secondary: \"hru6be5\", Success: \"hru6be6\", Warning: \"hru6be7\", Critical: \"hru6be8\" }, size: { \"300\": \"hru6be9\", \"400\": \"hru6bea\", \"500\": \"hru6beb\", \"600\": \"hru6bec\", \"700\": \"hru6bed\" } }, defaultVariants: { variant: \"Surface\", size: \"400\" }, compoundVariants: [] });\nconst Header = as(\n  ({ as: AsHeader = \"header\", className, variant, size, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsHeader,\n    {\n      className: classNames(Header$1({ variant, size }), className),\n      ...props,\n      ref\n    }\n  )\n);\nconst IconButton_css_ts_vanilla = \"\";\nvar IconButton$1 = createRuntimeFn({ defaultClassName: \"brs7ce5 _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\", variantClassNames: { size: { \"300\": \"brs7ce6\", \"400\": \"brs7ce7\", \"500\": \"brs7ce8\", \"600\": \"brs7ce9\" }, variant: { Background: \"brs7cea\", Surface: \"brs7ceb\", SurfaceVariant: \"brs7cec\", Primary: \"brs7ced\", Secondary: \"brs7cee\", Success: \"brs7cef\", Warning: \"brs7ceg\", Critical: \"brs7ceh\" }, fill: { Soft: \"brs7cei\", None: \"brs7cej\" }, outlined: { true: \"brs7cek\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { size: \"400\", variant: \"Surface\", fill: \"Soft\", radii: \"400\" }, compoundVariants: [] });\nconst IconButton = as(\n  ({ as: AsIconButton = \"button\", className, size, variant, fill, radii, outlined, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsIconButton,\n    {\n      className: classNames(IconButton$1({ variant, fill, size, radii, outlined }), className),\n      ...props,\n      ref\n    }\n  )\n);\nconst Input_css_ts_vanilla = \"\";\nvar Input$1 = createRuntimeFn({ defaultClassName: \"_1rrvnjm8 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Background: \"_1rrvnjm9\", Surface: \"_1rrvnjma\", SurfaceVariant: \"_1rrvnjmb\", Primary: \"_1rrvnjmc\", Secondary: \"_1rrvnjmd\", Success: \"_1rrvnjme\", Warning: \"_1rrvnjmf\", Critical: \"_1rrvnjmg\" }, size: { \"300\": \"_1rrvnjmh\", \"400\": \"_1rrvnjmi\", \"500\": \"_1rrvnjmj\" }, outlined: { true: \"_1rrvnjmk\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { variant: \"Background\", size: \"400\", radii: \"400\" }, compoundVariants: [] });\nvar InputInput = \"_1rrvnjmr _1mqalmd1 _1mqalmd0 _1bugis91\";\nconst Input = forwardRef(\n  ({ className, style, variant, size, inputSize = 1, outlined, radii, before, after, ...props }, ref) => /* @__PURE__ */ jsxs(\n    \"div\",\n    {\n      className: classNames(Input$1({ variant, size, outlined, radii }), className),\n      style,\n      \"data-ui-before\": before ? true : void 0,\n      \"data-ui-after\": after ? true : void 0,\n      children: [\n        before,\n        /* @__PURE__ */ jsx(\"input\", { className: InputInput, size: inputSize, ...props, ref }),\n        after\n      ]\n    }\n  )\n);\nconst Line_css_ts_vanilla = \"\";\nvar Line$1 = createRuntimeFn({ defaultClassName: \"_1yan8dd1 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Inherit: \"_1yan8dd2\", Background: \"_1yan8dd3\", Surface: \"_1yan8dd4\", SurfaceVariant: \"_1yan8dd5\", Primary: \"_1yan8dd6\", Secondary: \"_1yan8dd7\", Success: \"_1yan8dd8\", Warning: \"_1yan8dd9\", Critical: \"_1yan8dda\" }, direction: { Horizontal: \"_1yan8ddb\", Vertical: \"_1yan8ddc\" }, size: { \"300\": \"_1yan8ddd\", \"400\": \"_1yan8dde\", \"500\": \"_1yan8ddf\", \"600\": \"_1yan8ddg\", \"700\": \"_1yan8ddh\" } }, defaultVariants: { variant: \"Surface\", direction: \"Horizontal\", size: \"400\" }, compoundVariants: [] });\nconst Line = as(\n  ({ as: AsLine = \"div\", className, variant, direction, size, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsLine,\n    {\n      className: classNames(Line$1({ variant, direction, size }), className),\n      ...props,\n      ref\n    }\n  )\n);\nconst MenuItem_css_ts_vanilla = \"\";\nvar MenuItem$1 = createRuntimeFn({ defaultClassName: \"_13tt0gb6 _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\", variantClassNames: { variant: { Background: \"_13tt0gb7\", Surface: \"_13tt0gb8\", SurfaceVariant: \"_13tt0gb9\", Primary: \"_13tt0gba\", Secondary: \"_13tt0gbb\", Success: \"_13tt0gbc\", Warning: \"_13tt0gbd\", Critical: \"_13tt0gbe\" }, fill: { Soft: \"_13tt0gbf\", None: \"_13tt0gbg\" }, size: { \"300\": \"_13tt0gbh\", \"400\": \"_13tt0gbi\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { variant: \"Surface\", fill: \"Soft\", size: \"400\", radii: \"0\" }, compoundVariants: [] });\nconst MenuItem = as(\n  ({\n    as: AsMenuItem = \"button\",\n    className,\n    variant,\n    fill,\n    size,\n    radii,\n    before,\n    after,\n    children,\n    ...props\n  }, ref) => /* @__PURE__ */ jsxs(\n    AsMenuItem,\n    {\n      className: classNames(MenuItem$1({ variant, fill, size, radii }), className),\n      \"data-ui-before\": before ? true : void 0,\n      \"data-ui-after\": after ? true : void 0,\n      ...props,\n      ref,\n      children: [\n        before,\n        children,\n        after\n      ]\n    }\n  )\n);\nconst Menu_css_ts_vanilla = \"\";\nvar Menu$1 = createRuntimeFn({ defaultClassName: \"_1fptcza0 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Background: \"_1fptcza1\", Surface: \"_1fptcza2\", SurfaceVariant: \"_1fptcza3\", Primary: \"_1fptcza4\", Secondary: \"_1fptcza5\", Success: \"_1fptcza6\", Warning: \"_1fptcza7\", Critical: \"_1fptcza8\" } }, defaultVariants: { variant: \"Surface\" }, compoundVariants: [] });\nconst Menu = as(\n  ({ as: AsMenu = \"div\", className, variant, ...props }, ref) => /* @__PURE__ */ jsx(AsMenu, { className: classNames(Menu$1({ variant }), className), ...props, ref })\n);\nconst Modal_css_ts_vanilla = \"\";\nvar Modal$1 = createRuntimeFn({ defaultClassName: \"_1fc5sz51 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Background: \"_1fc5sz52\", Surface: \"_1fc5sz53\", SurfaceVariant: \"_1fc5sz54\", Primary: \"_1fc5sz55\", Secondary: \"_1fc5sz56\", Success: \"_1fc5sz57\", Warning: \"_1fc5sz58\", Critical: \"_1fc5sz59\" }, size: { \"300\": \"_1fc5sz5a\", \"400\": \"_1fc5sz5b\", \"500\": \"_1fc5sz5c\" }, flexHeight: { true: \"_1fc5sz5d\" } }, defaultVariants: { variant: \"Surface\", size: \"400\" }, compoundVariants: [] });\nconst Modal = as(\n  ({ as: AsModal = \"div\", className, variant, size, flexHeight, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsModal,\n    {\n      className: classNames(Modal$1({ variant, size, flexHeight }), className),\n      ...props,\n      ref\n    }\n  )\n);\nconst Overlay_css_ts_vanilla = \"\";\nvar Overlay$1 = \"_1oc5jl80 _1mqalmd1 _1mqalmd0\";\nvar OverlayBackdrop$1 = \"_1oc5jl82 _1mqalmd1 _1mqalmd0\";\nvar OverlayCenter$1 = \"_1oc5jl83 _1mqalmd1 _1mqalmd0\";\nconst Portal = ({ container, children }) => /* @__PURE__ */ jsx(Fragment, { children: createPortal(children, container ?? document.body) });\nconst Overlay = as(\n  ({ as: AsOverlay = \"div\", className, open, container, backdrop, children, ...props }, ref) => /* @__PURE__ */ jsx(Portal, { container, children: open ? /* @__PURE__ */ jsxs(AsOverlay, { className: classNames(Overlay$1, className), ...props, ref, children: [\n    backdrop,\n    children\n  ] }) : null })\n);\nconst OverlayBackdrop = as(\n  ({ as: AsOverlayBackdrop = \"div\", className, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsOverlayBackdrop,\n    {\n      className: classNames(OverlayBackdrop$1, className),\n      ...props,\n      ref\n    }\n  )\n);\nconst OverlayCenter = as(\n  ({ as: AsOverlayCenter = \"div\", className, ...props }, ref) => /* @__PURE__ */ jsx(AsOverlayCenter, { className: classNames(OverlayCenter$1, className), ...props, ref })\n);\nconst PopOut_css_ts_vanilla = \"\";\nvar PopOut$1 = \"_1v6ozra0\";\nvar PopOutContainer = \"_1v6ozra1\";\nconst PopOut = as(\n  ({\n    as: AsPopOut = \"div\",\n    className,\n    anchor,\n    position = \"Bottom\",\n    align = \"Center\",\n    offset = 10,\n    alignOffset = 0,\n    content,\n    children,\n    ...props\n  }, ref) => {\n    const baseRef = useRef(null);\n    const positionPopOut = useCallback(() => {\n      const baseEl = baseRef.current;\n      if (!baseEl || !anchor)\n        return;\n      const pCSS = getRelativeFixedPosition(\n        anchor,\n        baseEl.getBoundingClientRect(),\n        position,\n        align,\n        offset,\n        alignOffset\n      );\n      baseEl.style.top = pCSS.top ?? \"unset\";\n      baseEl.style.bottom = pCSS.bottom ?? \"unset\";\n      baseEl.style.left = pCSS.left ?? \"unset\";\n      baseEl.style.right = pCSS.right ?? \"unset\";\n    }, [anchor, position, align, offset, alignOffset]);\n    useEffect(() => {\n      window.addEventListener(\"resize\", positionPopOut);\n      return () => {\n        window.removeEventListener(\"resize\", positionPopOut);\n      };\n    }, [positionPopOut]);\n    useLayoutEffect(() => {\n      positionPopOut();\n    }, [positionPopOut]);\n    return /* @__PURE__ */ jsxs(Fragment, { children: [\n      children,\n      anchor && /* @__PURE__ */ jsx(Portal, { children: /* @__PURE__ */ jsx(AsPopOut, { className: classNames(PopOut$1, className), ...props, ref, children: /* @__PURE__ */ jsx(\"div\", { ref: baseRef, className: PopOutContainer, children: content }) }) })\n    ] });\n  }\n);\nconst ProgressBar_css_ts_vanilla = \"\";\nvar ProgressBar$1 = createRuntimeFn({ defaultClassName: \"w2djj94 _1mqalmd1 _1mqalmd0 _1bugis91\", variantClassNames: { size: { \"300\": \"w2djj95\", \"400\": \"w2djj96\", \"500\": \"w2djj97\" }, variant: { Primary: \"w2djj98\", Secondary: \"w2djj99\", Success: \"w2djj9a\", Warning: \"w2djj9b\", Critical: \"w2djj9c\" }, fill: { Solid: \"w2djj9d\", Soft: \"w2djj9e\", None: \"w2djj9f\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" }, outlined: { true: \"w2djj9m\" } }, defaultVariants: { variant: \"Secondary\", size: \"400\", fill: \"Soft\", radii: \"Pill\" }, compoundVariants: [] });\nvar ProgressBarFill = \"w2djj9n _1mqalmd1 _1mqalmd0\";\nconst ProgressBar = as(\n  ({\n    as: AsProgressBar = \"span\",\n    className,\n    variant,\n    size,\n    fill,\n    radii,\n    outlined,\n    value,\n    min = 0,\n    max,\n    ...props\n  }, ref) => /* @__PURE__ */ jsx(\n    AsProgressBar,\n    {\n      className: classNames(ProgressBar$1({ variant, size, fill, radii, outlined }), className),\n      role: \"progressbar\",\n      \"aria-valuenow\": value,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      ...props,\n      ref,\n      children: /* @__PURE__ */ jsx(\"span\", { className: ProgressBarFill, style: { width: `${percent(min, max, value)}%` } })\n    }\n  )\n);\nconst RadioButton_css_ts_vanilla = \"\";\nvar RadioButton$1 = createRuntimeFn({ defaultClassName: \"_1agxj9w0 _1mqalmd1 _1mqalmd0 _1bugis90 _1bugis91\", variantClassNames: { variant: { Primary: \"_1agxj9w1\", Secondary: \"_1agxj9w2\", Success: \"_1agxj9w3\", Warning: \"_1agxj9w4\", Critical: \"_1agxj9w5\" }, size: { \"50\": \"cpipac7\", \"100\": \"cpipac8\", \"200\": \"cpipac9\", \"300\": \"cpipaca\", \"400\": \"cpipacb\", \"500\": \"cpipacc\", \"600\": \"cpipacd\", Inherit: \"cpipac6\" } }, defaultVariants: { variant: \"Secondary\", size: \"400\" }, compoundVariants: [] });\nconst RadioButton = forwardRef(\n  ({ className, variant, size, ...props }, ref) => /* @__PURE__ */ jsx(\n    \"input\",\n    {\n      className: classNames(RadioButton$1({ variant, size }), className),\n      ...props,\n      type: \"radio\",\n      ref\n    }\n  )\n);\nconst Scroll_css_ts_vanilla = \"\";\nvar Scroll$1 = createRuntimeFn({ defaultClassName: \"_4yxtfd2 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Background: \"_4yxtfd3\", Surface: \"_4yxtfd4\", SurfaceVariant: \"_4yxtfd5\", Primary: \"_4yxtfd6\", Secondary: \"_4yxtfd7\", Success: \"_4yxtfd8\", Warning: \"_4yxtfd9\", Critical: \"_4yxtfda\" }, visibility: { Always: \"_4yxtfdb\", Hover: \"_4yxtfdc\" }, hideTrack: { true: \"_4yxtfdd\" }, size: { \"0\": \"_4yxtfde\", \"300\": \"_4yxtfdf\", \"400\": \"_4yxtfdg\" }, direction: { Horizontal: \"_4yxtfdh\", Vertical: \"_4yxtfdi\", Both: \"_4yxtfdj\" } }, defaultVariants: { variant: \"Surface\", visibility: \"Always\", size: \"400\", direction: \"Vertical\" }, compoundVariants: [[{ direction: \"Horizontal\", size: \"300\" }, \"_4yxtfdk\"], [{ direction: \"Horizontal\", size: \"400\" }, \"_4yxtfdl\"], [{ direction: \"Vertical\", size: \"300\" }, \"_4yxtfdm\"], [{ direction: \"Vertical\", size: \"400\" }, \"_4yxtfdn\"], [{ direction: \"Both\", size: \"300\" }, \"_4yxtfdo\"], [{ direction: \"Both\", size: \"400\" }, \"_4yxtfdp\"]] });\nconst Scroll = as(\n  ({ as: AsScroll = \"div\", className, variant, visibility, hideTrack, size, direction, ...props }, ref) => {\n    const scrollLocalRef = useRef();\n    useLayoutEffect(() => {\n      if (scrollLocalRef.current) {\n        const $scroll = scrollLocalRef.current;\n        if (size === \"0\") {\n          $scroll.setAttribute(\"data-x-scrollbar-width\", \"0\");\n          $scroll.setAttribute(\"data-y-scrollbar-width\", \"0\");\n        } else {\n          const xScrollbarWidth = $scroll.offsetHeight - $scroll.clientHeight;\n          const yScrollbarWidth = $scroll.offsetWidth - $scroll.clientWidth;\n          $scroll.setAttribute(\"data-x-scrollbar-width\", `${xScrollbarWidth}`);\n          $scroll.setAttribute(\"data-y-scrollbar-width\", `${yScrollbarWidth}`);\n        }\n      }\n    }, [size]);\n    return /* @__PURE__ */ jsx(\n      AsScroll,\n      {\n        className: classNames(\n          Scroll$1({\n            variant,\n            visibility,\n            hideTrack,\n            size,\n            direction\n          }),\n          className\n        ),\n        ...props,\n        ref: (r) => {\n          if (r)\n            scrollLocalRef.current = r;\n          if (ref) {\n            if (\"current\" in ref) {\n              const propRef = ref;\n              propRef.current = r;\n            }\n            if (typeof ref === \"function\") {\n              ref(r);\n            }\n          }\n        }\n      }\n    );\n  }\n);\nconst Spinner_css_ts_vanilla = \"\";\nvar Spinner$1 = createRuntimeFn({ defaultClassName: \"_31czpk7 _1mqalmd1 _1mqalmd0\", variantClassNames: { size: { \"50\": \"cpipac7\", \"100\": \"cpipac8\", \"200\": \"cpipac9\", \"300\": \"cpipaca\", \"400\": \"cpipacb\", \"500\": \"cpipacc\", \"600\": \"cpipacd\", Inherit: \"cpipac6\" }, variant: { Primary: \"_31czpkg\", Secondary: \"_31czpkh\", Success: \"_31czpki\", Warning: \"_31czpkj\", Critical: \"_31czpkk\" }, fill: { Solid: \"_31czpkl\", Soft: \"_31czpkm\" } }, defaultVariants: { size: \"400\", variant: \"Secondary\", fill: \"Soft\" }, compoundVariants: [] });\nvar SpinnerInner = \"_31czpkp\";\nvar SpinnerOuter = \"_31czpko\";\nvar SpinnerSvg$1 = \"_31czpkn _1mqalmd1 _1mqalmd0\";\nconst SpinnerSvg = () => /* @__PURE__ */ jsxs(\n  \"svg\",\n  {\n    className: SpinnerSvg$1,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    children: [\n      /* @__PURE__ */ jsx(\n        \"path\",\n        {\n          className: SpinnerOuter,\n          d: \"M5.98986 18.0104C7.52806 19.5486 9.65306 20.5 12.0003 20.5C16.6947 20.5 20.5003 16.6944 20.5003 12C20.5003 7.30558 16.6947 3.5 12.0003 3.5C9.65306 3.5 7.52806 4.45139 5.98986 5.98959L4.9292 4.92893C6.73884 3.11929 9.23884 2 12.0003 2C17.5231 2 22.0003 6.47715 22.0003 12C22.0003 17.5228 17.5231 22 12.0003 22C9.23884 22 6.73884 20.8807 4.9292 19.0711L5.98986 18.0104Z\"\n        }\n      ),\n      /* @__PURE__ */ jsx(\n        \"path\",\n        {\n          className: SpinnerInner,\n          d: \"M4.92908 19.0711C3.1204 17.2624 2.00134 14.7641 2.00015 12.0044L2.00015 11.9956C2.00134 9.23593 3.1204 6.73763 4.92909 4.92896L5.98975 5.98962C4.45155 7.52781 3.50015 9.65281 3.50015 12C3.50015 14.3472 4.45155 16.4722 5.98975 18.0104L4.92908 19.0711Z\"\n        }\n      )\n    ]\n  }\n);\nconst Spinner = as(\n  ({ as: AsSpinner = \"span\", className, size, variant, fill, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsSpinner,\n    {\n      className: classNames(Spinner$1({ size, variant, fill }), className),\n      ...props,\n      ref,\n      children: /* @__PURE__ */ jsx(SpinnerSvg, {})\n    }\n  )\n);\nconst Switch_css_ts_vanilla = \"\";\nvar Switch$1 = createRuntimeFn({ defaultClassName: \"_1mqalmd1 _1mqalmd0 _1gp7uix2 _1bugis90 _1bugis91\", variantClassNames: { variant: { Primary: \"_1gp7uix4\", Secondary: \"_1gp7uix5\", Success: \"_1gp7uix6\", Warning: \"_1gp7uix7\", Critical: \"_1gp7uix8\" } }, defaultVariants: { variant: \"Primary\" }, compoundVariants: [] });\nvar SwitchThumb = \"_1gp7uix9 _1mqalmd1 _1mqalmd0\";\nconst Switch = forwardRef(\n  ({ className, variant, value = false, onChange, ...props }, ref) => {\n    const handleClick = () => onChange == null ? void 0 : onChange(!value);\n    return /* @__PURE__ */ jsx(\n      \"button\",\n      {\n        className: classNames(Switch$1({ variant }), className),\n        role: \"switch\",\n        type: \"button\",\n        \"aria-checked\": value,\n        onClick: handleClick,\n        ...props,\n        ref,\n        children: /* @__PURE__ */ jsx(\"span\", { className: SwitchThumb, \"aria-hidden\": true, children: /* @__PURE__ */ jsx(Icon, { src: Icons.Check, size: \"100\" }) })\n      }\n    );\n  }\n);\nconst Text_css_ts_vanilla = \"\";\nvar Text$1 = createRuntimeFn({ defaultClassName: \"_1xny9xl0 _1mqalmd1 _1mqalmd0\", variantClassNames: { size: { Inherit: \"_1xny9xl1\", D400: \"_1xny9xl2\", H1: \"_1xny9xl3\", H2: \"_1xny9xl4\", H3: \"_1xny9xl5\", H4: \"_1xny9xl6\", H5: \"_1xny9xl7\", H6: \"_1xny9xl8\", T500: \"_1xny9xl9\", T400: \"_1xny9xla\", T300: \"_1xny9xlb\", T200: \"_1xny9xlc\", B500: \"_1xny9xld\", B400: \"_1xny9xle\", B300: \"_1xny9xlf\", L400: \"_1xny9xlg\", O400: \"_1xny9xlh\", C400: \"_1xny9xli\" }, align: { Left: \"_1xny9xlj\", Center: \"_1xny9xlk\", Right: \"_1xny9xll\", Justify: \"_1xny9xlm\" }, truncate: { true: \"_1xny9xln\" }, priority: { \"300\": \"_1xny9xlo\", \"400\": \"_1xny9xlp\", \"500\": \"_1xny9xlq\", Inherit: \"_1xny9xlr\", Initial: \"_1xny9xls\" } }, defaultVariants: { size: \"T400\", priority: \"Inherit\" }, compoundVariants: [] });\nconst Text = as(\n  ({ as: AsText = \"p\", className, size, truncate, align, priority, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsText,\n    {\n      className: classNames(Text$1({ size, truncate, align, priority }), className),\n      ...props,\n      ref\n    }\n  )\n);\nconst Tooltip_css_ts_vanilla = \"\";\nvar Tooltip$1 = createRuntimeFn({ defaultClassName: \"_6plmi21 _1mqalmd1 _1mqalmd0\", variantClassNames: { variant: { Background: \"_6plmi22\", Surface: \"_6plmi23\", SurfaceVariant: \"_6plmi24\", Primary: \"_6plmi25\", Secondary: \"_6plmi26\", Success: \"_6plmi27\", Warning: \"_6plmi28\", Critical: \"_6plmi29\" }, radii: { \"0\": \"cpipac1\", \"300\": \"cpipac2\", \"400\": \"cpipac3\", \"500\": \"cpipac4\", Inherit: \"cpipac0\", Pill: \"cpipac5\" } }, defaultVariants: { variant: \"Surface\", radii: \"400\" }, compoundVariants: [] });\nvar TooltipProvider$1 = \"_6plmi2g\";\nconst Tooltip = as(\n  ({ as: AsTooltip = \"div\", className, variant, radii, ...props }, ref) => /* @__PURE__ */ jsx(\n    AsTooltip,\n    {\n      className: classNames(Tooltip$1({ variant, radii }), className),\n      ...props,\n      ref\n    }\n  )\n);\nconst useTooltip = (position, align, offset, alignOffset, delay) => {\n  const triggerRef = useRef(null);\n  const baseRef = useRef(null);\n  const [open, setOpen] = useState(false);\n  const positionTooltip = useCallback(() => {\n    const anchor = triggerRef.current;\n    const baseEl = baseRef.current;\n    if (!anchor)\n      return;\n    if (!baseEl)\n      return;\n    const tooltipCss = getRelativeFixedPosition(\n      anchor.getBoundingClientRect(),\n      baseEl.getBoundingClientRect(),\n      position,\n      align,\n      offset,\n      alignOffset\n    );\n    baseEl.style.top = tooltipCss.top ?? \"unset\";\n    baseEl.style.bottom = tooltipCss.bottom ?? \"unset\";\n    baseEl.style.left = tooltipCss.left ?? \"unset\";\n    baseEl.style.right = tooltipCss.right ?? \"unset\";\n  }, [position, align, offset, alignOffset]);\n  useEffect(() => {\n    const trigger = triggerRef.current;\n    let timeoutId;\n    const openTooltip = (evt) => {\n      if (timeoutId)\n        return;\n      if (evt.type === \"focus\")\n        setOpen(true);\n      else\n        timeoutId = window.setTimeout(() => setOpen(true), delay);\n    };\n    const closeTooltip = () => {\n      clearTimeout(timeoutId);\n      timeoutId = void 0;\n      setOpen(false);\n    };\n    const onKeyDown = (evt) => {\n      if (evt.key === \"Escape\" && document.activeElement === trigger) {\n        evt.preventDefault();\n        clearTimeout(timeoutId);\n        setOpen(false);\n      }\n    };\n    trigger == null ? void 0 : trigger.addEventListener(\"mouseenter\", openTooltip);\n    trigger == null ? void 0 : trigger.addEventListener(\"mouseleave\", closeTooltip);\n    trigger == null ? void 0 : trigger.addEventListener(\"focus\", openTooltip);\n    trigger == null ? void 0 : trigger.addEventListener(\"blur\", closeTooltip);\n    document.addEventListener(\"keydown\", onKeyDown);\n    trigger == null ? void 0 : trigger.addEventListener(\"click\", closeTooltip);\n    return () => {\n      clearTimeout(timeoutId);\n      trigger == null ? void 0 : trigger.removeEventListener(\"mouseenter\", openTooltip);\n      trigger == null ? void 0 : trigger.removeEventListener(\"mouseleave\", closeTooltip);\n      trigger == null ? void 0 : trigger.removeEventListener(\"focus\", openTooltip);\n      trigger == null ? void 0 : trigger.removeEventListener(\"blur\", closeTooltip);\n      document.removeEventListener(\"keydown\", onKeyDown);\n      trigger == null ? void 0 : trigger.removeEventListener(\"click\", closeTooltip);\n    };\n  }, [position, align, offset, alignOffset, delay]);\n  useLayoutEffect(() => {\n    if (open)\n      positionTooltip();\n  }, [open, positionTooltip]);\n  const handleTriggerRef = useCallback((element) => {\n    triggerRef.current = element;\n  }, []);\n  const handleBaseRef = useCallback((element) => {\n    baseRef.current = element;\n  }, []);\n  return {\n    triggerRef: handleTriggerRef,\n    baseRef: handleBaseRef,\n    open\n  };\n};\nconst TooltipProvider = as(\n  ({\n    as: AsTooltipProvider = \"div\",\n    className,\n    position = \"Top\",\n    align = \"Center\",\n    offset = 10,\n    alignOffset = 0,\n    delay = 200,\n    tooltip,\n    children,\n    ...props\n  }, ref) => {\n    const { open, triggerRef, baseRef } = useTooltip(position, align, offset, alignOffset, delay);\n    return /* @__PURE__ */ jsxs(Fragment, { children: [\n      children(triggerRef),\n      open && /* @__PURE__ */ jsx(Portal, { children: /* @__PURE__ */ jsx(\n        AsTooltipProvider,\n        {\n          role: \"tooltip\",\n          className: classNames(TooltipProvider$1, className),\n          ...props,\n          ref: (instance) => {\n            baseRef(instance);\n            if (ref) {\n              if (typeof ref === \"function\")\n                ref(instance);\n              else\n                ref.current = instance;\n            }\n          },\n          children: tooltip\n        }\n      ) })\n    ] });\n  }\n);\nexport {\n  Avatar,\n  AvatarFallback,\n  AvatarImage,\n  Badge,\n  Box,\n  Button,\n  Checkbox,\n  Chip,\n  CrossSizeVariant,\n  DefaultReset,\n  Dialog,\n  Disabled,\n  FocusOutline,\n  Header,\n  Icon,\n  IconButton,\n  Icons,\n  Input,\n  Line,\n  Menu,\n  MenuItem,\n  Modal,\n  Overlay,\n  OverlayBackdrop,\n  OverlayCenter,\n  PopOut,\n  Portal,\n  ProgressBar,\n  RadiiVariant,\n  RadioButton,\n  Scroll,\n  Spinner,\n  Switch,\n  Text,\n  TextReset,\n  Tooltip,\n  TooltipProvider,\n  as,\n  color,\n  config,\n  configClass,\n  getRelativeFixedPosition,\n  lightTheme,\n  percent,\n  pxToRem,\n  toRem,\n  vars,\n  varsClass\n};\n//# sourceMappingURL=index.js.map\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n'use strict';\n\nvar validateFormat = process.env.NODE_ENV !== \"production\" ? function (format) {\n  if (format === undefined) {\n    throw new Error('invariant(...): Second argument must be a string.');\n  }\n} : function (format) {};\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments to provide\n * information about what broke and what you were expecting.\n *\n * The invariant message will be stripped in production, but the invariant will\n * remain to ensure logic does not differ in production.\n */\n\nfunction invariant(condition, format) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return String(args[argIndex++]);\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // Skip invariant's own stack frame.\n\n    throw error;\n  }\n}\n\nmodule.exports = invariant;","/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule Dispatcher\r\n * \r\n * @preventMunge\r\n */\n'use strict';\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _prefix = 'ID_';\n/**\r\n * Dispatcher is used to broadcast payloads to registered callbacks. This is\r\n * different from generic pub-sub systems in two ways:\r\n *\r\n *   1) Callbacks are not subscribed to particular events. Every payload is\r\n *      dispatched to every registered callback.\r\n *   2) Callbacks can be deferred in whole or part until other callbacks have\r\n *      been executed.\r\n *\r\n * For example, consider this hypothetical flight destination form, which\r\n * selects a default city when a country is selected:\r\n *\r\n *   var flightDispatcher = new Dispatcher();\r\n *\r\n *   // Keeps track of which country is selected\r\n *   var CountryStore = {country: null};\r\n *\r\n *   // Keeps track of which city is selected\r\n *   var CityStore = {city: null};\r\n *\r\n *   // Keeps track of the base flight price of the selected city\r\n *   var FlightPriceStore = {price: null}\r\n *\r\n * When a user changes the selected city, we dispatch the payload:\r\n *\r\n *   flightDispatcher.dispatch({\r\n *     actionType: 'city-update',\r\n *     selectedCity: 'paris'\r\n *   });\r\n *\r\n * This payload is digested by `CityStore`:\r\n *\r\n *   flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'city-update') {\r\n *       CityStore.city = payload.selectedCity;\r\n *     }\r\n *   });\r\n *\r\n * When the user selects a country, we dispatch the payload:\r\n *\r\n *   flightDispatcher.dispatch({\r\n *     actionType: 'country-update',\r\n *     selectedCountry: 'australia'\r\n *   });\r\n *\r\n * This payload is digested by both stores:\r\n *\r\n *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'country-update') {\r\n *       CountryStore.country = payload.selectedCountry;\r\n *     }\r\n *   });\r\n *\r\n * When the callback to update `CountryStore` is registered, we save a reference\r\n * to the returned token. Using this token with `waitFor()`, we can guarantee\r\n * that `CountryStore` is updated before the callback that updates `CityStore`\r\n * needs to query its data.\r\n *\r\n *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {\r\n *     if (payload.actionType === 'country-update') {\r\n *       // `CountryStore.country` may not be updated.\r\n *       flightDispatcher.waitFor([CountryStore.dispatchToken]);\r\n *       // `CountryStore.country` is now guaranteed to be updated.\r\n *\r\n *       // Select the default city for the new country\r\n *       CityStore.city = getDefaultCityForCountry(CountryStore.country);\r\n *     }\r\n *   });\r\n *\r\n * The usage of `waitFor()` can be chained, for example:\r\n *\r\n *   FlightPriceStore.dispatchToken =\r\n *     flightDispatcher.register(function(payload) {\r\n *       switch (payload.actionType) {\r\n *         case 'country-update':\r\n *         case 'city-update':\r\n *           flightDispatcher.waitFor([CityStore.dispatchToken]);\r\n *           FlightPriceStore.price =\r\n *             getFlightPriceStore(CountryStore.country, CityStore.city);\r\n *           break;\r\n *     }\r\n *   });\r\n *\r\n * The `country-update` payload will be guaranteed to invoke the stores'\r\n * registered callbacks in order: `CountryStore`, `CityStore`, then\r\n * `FlightPriceStore`.\r\n */\n\nvar Dispatcher = /*#__PURE__*/function () {\n  function Dispatcher() {\n    _defineProperty(this, \"_callbacks\", void 0);\n\n    _defineProperty(this, \"_isDispatching\", void 0);\n\n    _defineProperty(this, \"_isHandled\", void 0);\n\n    _defineProperty(this, \"_isPending\", void 0);\n\n    _defineProperty(this, \"_lastID\", void 0);\n\n    _defineProperty(this, \"_pendingPayload\", void 0);\n\n    this._callbacks = {};\n    this._isDispatching = false;\n    this._isHandled = {};\n    this._isPending = {};\n    this._lastID = 1;\n  }\n  /**\r\n   * Registers a callback to be invoked with every dispatched payload. Returns\r\n   * a token that can be used with `waitFor()`.\r\n   */\n\n\n  var _proto = Dispatcher.prototype;\n\n  _proto.register = function register(callback) {\n    var id = _prefix + this._lastID++;\n    this._callbacks[id] = callback;\n    return id;\n  }\n  /**\r\n   * Removes a callback based on its token.\r\n   */\n  ;\n\n  _proto.unregister = function unregister(id) {\n    !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n    delete this._callbacks[id];\n  }\n  /**\r\n   * Waits for the callbacks specified to be invoked before continuing execution\r\n   * of the current callback. This method should only be used by a callback in\r\n   * response to a dispatched payload.\r\n   */\n  ;\n\n  _proto.waitFor = function waitFor(ids) {\n    !this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : void 0;\n\n    for (var ii = 0; ii < ids.length; ii++) {\n      var id = ids[ii];\n\n      if (this._isPending[id]) {\n        !this._isHandled[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : void 0;\n        continue;\n      }\n\n      !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n\n      this._invokeCallback(id);\n    }\n  }\n  /**\r\n   * Dispatches a payload to all registered callbacks.\r\n   */\n  ;\n\n  _proto.dispatch = function dispatch(payload) {\n    !!this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : void 0;\n\n    this._startDispatching(payload);\n\n    try {\n      for (var id in this._callbacks) {\n        if (this._isPending[id]) {\n          continue;\n        }\n\n        this._invokeCallback(id);\n      }\n    } finally {\n      this._stopDispatching();\n    }\n  }\n  /**\r\n   * Is this Dispatcher currently dispatching.\r\n   */\n  ;\n\n  _proto.isDispatching = function isDispatching() {\n    return this._isDispatching;\n  }\n  /**\r\n   * Call the callback stored with the given id. Also do some internal\r\n   * bookkeeping.\r\n   *\r\n   * @internal\r\n   */\n  ;\n\n  _proto._invokeCallback = function _invokeCallback(id) {\n    this._isPending[id] = true;\n\n    this._callbacks[id](this._pendingPayload);\n\n    this._isHandled[id] = true;\n  }\n  /**\r\n   * Set up bookkeeping needed when dispatching.\r\n   *\r\n   * @internal\r\n   */\n  ;\n\n  _proto._startDispatching = function _startDispatching(payload) {\n    for (var id in this._callbacks) {\n      this._isPending[id] = false;\n      this._isHandled[id] = false;\n    }\n\n    this._pendingPayload = payload;\n    this._isDispatching = true;\n  }\n  /**\r\n   * Clear bookkeeping used for dispatching.\r\n   *\r\n   * @internal\r\n   */\n  ;\n\n  _proto._stopDispatching = function _stopDispatching() {\n    delete this._pendingPayload;\n    this._isDispatching = false;\n  };\n\n  return Dispatcher;\n}();\n\nmodule.exports = Dispatcher;","/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n */\r\n\r\nmodule.exports.Dispatcher = require('./lib/Dispatcher');\r\n","import { Dispatcher } from 'flux';\n\nconst appDispatcher = new Dispatcher();\nexport default appDispatcher;\n","const cons = {\n  version: '4.2.3',\n  secretKey: {\n    ACCESS_TOKEN: 'cinny_access_token',\n    DEVICE_ID: 'cinny_device_id',\n    USER_ID: 'cinny_user_id',\n    BASE_URL: 'cinny_hs_base_url',\n  },\n  DEVICE_DISPLAY_NAME: 'Cinny Web',\n  IN_CINNY_SPACES: 'in.cinny.spaces',\n  supportEventTypes: [\n    'm.room.create',\n    'm.room.message',\n    'm.room.encrypted',\n    'm.room.member',\n    'm.sticker',\n  ],\n  supportReceiptTypes: ['m.read', 'm.read.private'],\n  notifs: {\n    DEFAULT: 'default',\n    ALL_MESSAGES: 'all_messages',\n    MENTIONS_AND_KEYWORDS: 'mentions_and_keywords',\n    MUTE: 'mute',\n  },\n  status: {\n    PRE_FLIGHT: 'pre-flight',\n    IN_FLIGHT: 'in-flight',\n    SUCCESS: 'success',\n    ERROR: 'error',\n  },\n  actions: {\n    navigation: {\n      OPEN_SPACE_SETTINGS: 'OPEN_SPACE_SETTINGS',\n      OPEN_SPACE_ADDEXISTING: 'OPEN_SPACE_ADDEXISTING',\n      TOGGLE_ROOM_SETTINGS: 'TOGGLE_ROOM_SETTINGS',\n      OPEN_CREATE_ROOM: 'OPEN_CREATE_ROOM',\n      OPEN_JOIN_ALIAS: 'OPEN_JOIN_ALIAS',\n      OPEN_INVITE_USER: 'OPEN_INVITE_USER',\n      OPEN_PROFILE_VIEWER: 'OPEN_PROFILE_VIEWER',\n      OPEN_SETTINGS: 'OPEN_SETTINGS',\n      OPEN_SEARCH: 'OPEN_SEARCH',\n      OPEN_REUSABLE_CONTEXT_MENU: 'OPEN_REUSABLE_CONTEXT_MENU',\n      OPEN_REUSABLE_DIALOG: 'OPEN_REUSABLE_DIALOG',\n      OPEN_EMOJI_VERIFICATION: 'OPEN_EMOJI_VERIFICATION',\n    },\n    settings: {\n      TOGGLE_SYSTEM_THEME: 'TOGGLE_SYSTEM_THEME',\n      TOGGLE_MARKDOWN: 'TOGGLE_MARKDOWN',\n      TOGGLE_PEOPLE_DRAWER: 'TOGGLE_PEOPLE_DRAWER',\n      TOGGLE_MEMBERSHIP_EVENT: 'TOGGLE_MEMBERSHIP_EVENT',\n      TOGGLE_NICKAVATAR_EVENT: 'TOGGLE_NICKAVATAR_EVENT',\n    },\n  },\n  events: {\n    navigation: {\n      SPACE_SETTINGS_OPENED: 'SPACE_SETTINGS_OPENED',\n      SPACE_ADDEXISTING_OPENED: 'SPACE_ADDEXISTING_OPENED',\n      ROOM_SETTINGS_TOGGLED: 'ROOM_SETTINGS_TOGGLED',\n      CREATE_ROOM_OPENED: 'CREATE_ROOM_OPENED',\n      JOIN_ALIAS_OPENED: 'JOIN_ALIAS_OPENED',\n      INVITE_USER_OPENED: 'INVITE_USER_OPENED',\n      SETTINGS_OPENED: 'SETTINGS_OPENED',\n      SEARCH_OPENED: 'SEARCH_OPENED',\n      REUSABLE_CONTEXT_MENU_OPENED: 'REUSABLE_CONTEXT_MENU_OPENED',\n      REUSABLE_DIALOG_OPENED: 'REUSABLE_DIALOG_OPENED',\n      EMOJI_VERIFICATION_OPENED: 'EMOJI_VERIFICATION_OPENED',\n    },\n    notifications: {\n      NOTI_CHANGED: 'NOTI_CHANGED',\n      FULL_READ: 'FULL_READ',\n      MUTE_TOGGLED: 'MUTE_TOGGLED',\n    },\n    settings: {\n      SYSTEM_THEME_TOGGLED: 'SYSTEM_THEME_TOGGLED',\n      MARKDOWN_TOGGLED: 'MARKDOWN_TOGGLED',\n      PEOPLE_DRAWER_TOGGLED: 'PEOPLE_DRAWER_TOGGLED',\n      MEMBERSHIP_EVENTS_TOGGLED: 'MEMBERSHIP_EVENTS_TOGGLED',\n      NICKAVATAR_EVENTS_TOGGLED: 'NICKAVATAR_EVENTS_TOGGLED',\n    },\n  },\n};\n\nObject.freeze(cons);\n\nexport default cons;\n","import { lightTheme } from 'folds';\nimport EventEmitter from 'events';\nimport appDispatcher from '../dispatcher';\n\nimport cons from './cons';\nimport { darkTheme, butterTheme, silverTheme, oldDarkTheme } from '../../colors.css';\nimport { onLightFontWeight, onDarkFontWeight } from '../../config.css';\n\nfunction getSettings() {\n  const settings = localStorage.getItem('settings');\n  if (settings === null) return null;\n  return JSON.parse(settings);\n}\n\nfunction setSettings(key, value) {\n  let settings = getSettings();\n  if (settings === null) settings = {};\n  settings[key] = value;\n  localStorage.setItem('settings', JSON.stringify(settings));\n}\n\nclass Settings extends EventEmitter {\n  constructor() {\n    super();\n\n    this.themeClasses = [lightTheme, silverTheme, darkTheme, butterTheme, oldDarkTheme];\n    this.fontWeightClasses = [onLightFontWeight, onLightFontWeight, onDarkFontWeight, onDarkFontWeight, onDarkFontWeight]\n    this.themes = ['', 'silver-theme', 'dark-theme', 'butter-theme', 'old-dark-theme'];\n    this.themeIndex = this.getThemeIndex();\n\n    this.useSystemTheme = this.getUseSystemTheme();\n    this.isMarkdown = this.getIsMarkdown();\n    this.isPeopleDrawer = this.getIsPeopleDrawer();\n    this.hideMembershipEvents = this.getHideMembershipEvents();\n    this.hideNickAvatarEvents = this.getHideNickAvatarEvents();\n\n    this.darkModeQueryList = window.matchMedia('(prefers-color-scheme: dark)');\n\n    this.darkModeQueryList.addEventListener('change', () => this.applyTheme())\n\n    this.isTouchScreenDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);\n  }\n\n  getThemeIndex() {\n    if (typeof this.themeIndex === 'number') return this.themeIndex;\n\n    const settings = getSettings();\n    if (settings === null) return 0;\n    if (typeof settings.themeIndex === 'undefined') return 0;\n    // eslint-disable-next-line radix\n    return parseInt(settings.themeIndex);\n  }\n\n  getThemeName() {\n    return this.themes[this.themeIndex];\n  }\n\n  _clearTheme() {\n    this.themes.forEach((themeName, index) => {\n      if (themeName !== '') document.body.classList.remove(themeName);\n      document.body.classList.remove(this.themeClasses[index]);\n      document.body.classList.remove(this.fontWeightClasses[index]);\n      document.body.classList.remove('prism-light')\n      document.body.classList.remove('prism-dark')\n    });\n  }\n\n  applyTheme() {\n    this._clearTheme();\n    const autoThemeIndex = this.darkModeQueryList.matches ? 2 : 0;\n    const themeIndex = this.useSystemTheme ? autoThemeIndex : this.themeIndex;\n    if (this.themes[themeIndex] === undefined) return\n    if (this.themes[themeIndex]) document.body.classList.add(this.themes[themeIndex]);\n    document.body.classList.add(this.themeClasses[themeIndex]);\n    document.body.classList.add(this.fontWeightClasses[themeIndex]);\n    document.body.classList.add(themeIndex < 2 ? 'prism-light' : 'prism-dark');\n  }\n\n  setTheme(themeIndex) {\n    this.themeIndex = themeIndex;\n    setSettings('themeIndex', this.themeIndex);\n    this.applyTheme();\n  }\n\n  toggleUseSystemTheme() {\n    this.useSystemTheme = !this.useSystemTheme;\n    setSettings('useSystemTheme', this.useSystemTheme);\n    this.applyTheme();\n\n    this.emit(cons.events.settings.SYSTEM_THEME_TOGGLED, this.useSystemTheme);\n  }\n\n  getUseSystemTheme() {\n    if (typeof this.useSystemTheme === 'boolean') return this.useSystemTheme;\n\n    const settings = getSettings();\n    if (settings === null) return true;\n    if (typeof settings.useSystemTheme === 'undefined') return true;\n    return settings.useSystemTheme;\n  }\n\n  getIsMarkdown() {\n    if (typeof this.isMarkdown === 'boolean') return this.isMarkdown;\n\n    const settings = getSettings();\n    if (settings === null) return true;\n    if (typeof settings.isMarkdown === 'undefined') return true;\n    return settings.isMarkdown;\n  }\n\n  getHideMembershipEvents() {\n    if (typeof this.hideMembershipEvents === 'boolean') return this.hideMembershipEvents;\n\n    const settings = getSettings();\n    if (settings === null) return false;\n    if (typeof settings.hideMembershipEvents === 'undefined') return false;\n    return settings.hideMembershipEvents;\n  }\n\n  getHideNickAvatarEvents() {\n    if (typeof this.hideNickAvatarEvents === 'boolean') return this.hideNickAvatarEvents;\n\n    const settings = getSettings();\n    if (settings === null) return true;\n    if (typeof settings.hideNickAvatarEvents === 'undefined') return true;\n    return settings.hideNickAvatarEvents;\n  }\n\n  getIsPeopleDrawer() {\n    if (typeof this.isPeopleDrawer === 'boolean') return this.isPeopleDrawer;\n\n    const settings = getSettings();\n    if (settings === null) return true;\n    if (typeof settings.isPeopleDrawer === 'undefined') return true;\n    return settings.isPeopleDrawer;\n  }\n\n  setter(action) {\n    const actions = {\n      [cons.actions.settings.TOGGLE_SYSTEM_THEME]: () => {\n        this.toggleUseSystemTheme();\n      },\n      [cons.actions.settings.TOGGLE_MARKDOWN]: () => {\n        this.isMarkdown = !this.isMarkdown;\n        setSettings('isMarkdown', this.isMarkdown);\n        this.emit(cons.events.settings.MARKDOWN_TOGGLED, this.isMarkdown);\n      },\n      [cons.actions.settings.TOGGLE_PEOPLE_DRAWER]: () => {\n        this.isPeopleDrawer = !this.isPeopleDrawer;\n        setSettings('isPeopleDrawer', this.isPeopleDrawer);\n        this.emit(cons.events.settings.PEOPLE_DRAWER_TOGGLED, this.isPeopleDrawer);\n      },\n      [cons.actions.settings.TOGGLE_MEMBERSHIP_EVENT]: () => {\n        this.hideMembershipEvents = !this.hideMembershipEvents;\n        setSettings('hideMembershipEvents', this.hideMembershipEvents);\n        this.emit(cons.events.settings.MEMBERSHIP_EVENTS_TOGGLED, this.hideMembershipEvents);\n      },\n      [cons.actions.settings.TOGGLE_NICKAVATAR_EVENT]: () => {\n        this.hideNickAvatarEvents = !this.hideNickAvatarEvents;\n        setSettings('hideNickAvatarEvents', this.hideNickAvatarEvents);\n        this.emit(cons.events.settings.NICKAVATAR_EVENTS_TOGGLED, this.hideNickAvatarEvents);\n      },\n    };\n\n    actions[action.type]?.();\n  }\n}\n\nconst settings = new Settings();\nappDispatcher.register(settings.setter.bind(settings));\n\nexport default settings;\n","import { IconName, IconSrc } from 'folds';\n\nexport const bytesToSize = (bytes: number): string => {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  if (bytes === 0) return '0KB';\n\n  let sizeIndex = Math.floor(Math.log(bytes) / Math.log(1000));\n\n  if (sizeIndex === 0) sizeIndex = 1;\n\n  return `${(bytes / 1000 ** sizeIndex).toFixed(1)} ${sizes[sizeIndex]}`;\n};\n\nexport const millisecondsToMinutesAndSeconds = (milliseconds: number): string => {\n  const seconds = Math.floor(milliseconds / 1000);\n  const mm = Math.floor(seconds / 60);\n  const ss = Math.round(seconds % 60);\n  return `${mm}:${ss < 10 ? '0' : ''}${ss}`;\n};\n\nexport const secondsToMinutesAndSeconds = (seconds: number): string => {\n  const mm = Math.floor(seconds / 60);\n  const ss = Math.round(seconds % 60);\n  return `${mm}:${ss < 10 ? '0' : ''}${ss}`;\n};\n\nexport const getFileTypeIcon = (icons: Record<IconName, IconSrc>, fileType: string): IconSrc => {\n  const type = fileType.toLowerCase();\n  if (type.startsWith('audio')) {\n    return icons.Play;\n  }\n  if (type.startsWith('video')) {\n    return icons.Vlc;\n  }\n  if (type.startsWith('image')) {\n    return icons.Photo;\n  }\n  return icons.File;\n};\n\nexport const fulfilledPromiseSettledResult = <T>(prs: PromiseSettledResult<T>[]): T[] =>\n  prs.reduce<T[]>((values, pr) => {\n    if (pr.status === 'fulfilled') values.push(pr.value);\n    return values;\n  }, []);\n\nexport const promiseFulfilledResult = <T>(\n  settledResult: PromiseSettledResult<T>\n): T | undefined => {\n  if (settledResult.status === 'fulfilled') return settledResult.value;\n  return undefined;\n};\nexport const promiseRejectedResult = <T>(settledResult: PromiseSettledResult<T>): any => {\n  if (settledResult.status === 'rejected') return settledResult.reason;\n  return undefined;\n};\n\nexport const binarySearch = <T>(items: T[], match: (item: T) => -1 | 0 | 1): T | undefined => {\n  const search = (start: number, end: number): T | undefined => {\n    if (start > end) return undefined;\n\n    const mid = Math.floor((start + end) / 2);\n\n    const result = match(items[mid]);\n    if (result === 0) return items[mid];\n\n    if (result === 1) return search(start, mid - 1);\n    return search(mid + 1, end);\n  };\n\n  return search(0, items.length - 1);\n};\n\nexport const randomNumberBetween = (min: number, max: number) =>\n  Math.floor(Math.random() * (max - min + 1)) + min;\n\nexport const scaleYDimension = (x: number, scaledX: number, y: number): number => {\n  const scaleFactor = scaledX / x;\n  return scaleFactor * y;\n};\n\nexport const parseGeoUri = (location: string) => {\n  const [, data] = location.split(':');\n  const [cords] = data.split(';');\n  const [latitude, longitude] = cords.split(',');\n  return {\n    latitude,\n    longitude,\n  };\n};\n\nconst START_SLASHES_REG = /^\\/+/g;\nconst END_SLASHES_REG = /\\/+$/g;\nexport const trimLeadingSlash = (str: string): string => str.replace(START_SLASHES_REG, '');\nexport const trimTrailingSlash = (str: string): string => str.replace(END_SLASHES_REG, '');\n\nexport const trimSlash = (str: string): string => trimLeadingSlash(trimTrailingSlash(str));\n\nexport const nameInitials = (str: string | undefined | null, len = 1): string => {\n  if (!str) return '';\n  return [...str].slice(0, len).join('') || '';\n};\n\nexport const randomStr = (len = 12): string => {\n  let str = '';\n  const minCode = 'A'.charCodeAt(0);\n  const maxCode = 'Z'.charCodeAt(0);\n\n  for (let i = 0; i < len; i += 1) {\n    const code = Math.floor(Math.random() * (maxCode - minCode + 1) + minCode);\n    str += String.fromCharCode(code);\n  }\n  return str;\n};\n","let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function(get) {\n      return get(this);\n    };\n    config.write = function(get, set, arg) {\n      return set(\n        this,\n        typeof arg === \"function\" ? arg(get(this)) : arg\n      );\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const dependencyMap = /* @__PURE__ */ new Map();\n    const dirtyMap = /* @__PURE__ */ new WeakMap();\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const loop1 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        if (dependent !== a) {\n          dependencyMap.set(\n            dependent,\n            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)\n          );\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom);\n    const loop2 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent, true);\n              isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach((s) => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom);\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n","'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n","/**\n * @remix-run/router v1.13.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action[\"Push\"] = \"PUSH\";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window.location.hash.substr(1));\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType[\"data\"] = \"data\";\n  ResultType[\"deferred\"] = \"deferred\";\n  ResultType[\"redirect\"] = \"redirect\";\n  ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i],\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    safelyDecodeURI(pathname));\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = p => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    // only apply the splat if it's the last segment\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, \"\");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params[\"*\"] later because it will be decoded then\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = undefined;\n    } else {\n      memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/\\/:(\\w+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n  return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\"));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches) {\n  // Use the full pathname for the leaf match so we include splat values for \".\" links\n  return getPathContributingMatches(matches).map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else if (isPathRelative) {\n    let fromSegments = routePathnames[routePathnames.length - 1].replace(/^\\//, \"\").split(\"/\");\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      // With relative=\"path\", each leading .. segment means \"go up one URL segment\"\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        fromSegments.pop();\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = \"/\" + fromSegments.join(\"/\");\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      // With relative=\"route\" (the default), each leading .. segment means\n      // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n      // difference from how <a href> works and a major reason we call this a\n      // \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nclass ErrorResponseImpl {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n  const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  // Config driven behavior flags\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized =\n  // All initialMatches need to be loaded before we're ready.  If we have lazy\n  // functions around still then we'll need to run them in initialize()\n  !initialMatches.some(m => m.route.lazy) && (\n  // And we have to either have no loaders or have been provided hydrationData\n  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController;\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions = new Map();\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener = null;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map();\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don't update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location);\n    }\n    return router;\n  }\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach(subscriber => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\n      unstable_flushSync: opts.flushSync === true\n    }));\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach(key => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach(key => deleteFetcher(key));\n    }\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === Action.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync\n    });\n  }\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      // Create a GET request for the loaders\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    // Call loaders\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, flushSync, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, flushSync, pendingActionData, pendingError) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(rf => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach(rf => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId\n      });\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        updateFetcherState(key, getLoadingFetcher(submission));\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n      [match.route.id]: actionResult.data\n    }, undefined // No need to send through errors since we short circuit above\n    );\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n      flushSync\n    });\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(state, redirect, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state.location, redirect.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n    if (isBrowser) {\n      let isDocumentReload = false;\n      if (redirect.reloadDocument) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n        const url = init.history.createURL(redirect.location);\n        isDocumentReload =\n        // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin ||\n        // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map(f => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(request, _temp3) {\n    let {\n      requestContext\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(request, _temp4) {\n    let {\n      routeId,\n      requestContext\n    } = _temp4 === void 0 ? {} : _temp4;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, routeMatch) {\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n        isStaticRequest: true,\n        isRouteRequest,\n        requestContext\n      });\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(request, matches, requestContext, undefined, {\n        [boundaryMatch.route.id]: result.error\n      });\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n    return _extends({}, context, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      actionHeaders: _extends({}, result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {})\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n    let isRouteRequest = routeMatch != null;\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, {\n      isStaticRequest: true,\n      isRouteRequest,\n      requestContext\n    }))]);\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n    }\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Add an ?index param for matched index routes if we don't already have one\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n        let [name, value] = _ref3;\n        return \"\" + acc + name + \"=\" + value + \"\\n\";\n      }, \"\") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex(m => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate:\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired ||\n      // Clicked the same link, resubmitted a GET form\n      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate if fetcher won't be present in the subsequent render\n    if (!matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let values = await Promise.all([\n        // If the handler throws, don't let it immediately bubble out,\n        // since we need to let the lazy() execution finish so we know if this\n        // route has a boundary that can handle the error\n        runHandler(handler).catch(e => {\n          handlerError = e;\n        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            data: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n      };\n    }\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\n//#endregion\n\nexport { AbortedDeferredError, Action, IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, DeferredData as UNSAFE_DeferredData, ErrorResponseImpl as UNSAFE_ErrorResponseImpl, convertRouteMatchToUiMatch as UNSAFE_convertRouteMatchToUiMatch, convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes, getResolveToMatches as UNSAFE_getResolveToMatches, invariant as UNSAFE_invariant, warning as UNSAFE_warning, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, createRouter, createStaticHandler, defer, generatePath, getStaticContextFromError, getToPathname, isDeferredData, isRouteErrorResponse, joinPaths, json, matchPath, matchRoutes, normalizePathname, parsePath, redirect, redirectDocument, resolvePath, resolveTo, stripBasename };\n//# sourceMappingURL=router.js.map\n","/**\n * React Router v6.20.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_invariant, joinPaths, matchPath, UNSAFE_getResolveToMatches, UNSAFE_warning, resolveTo, parsePath, matchRoutes, Action, UNSAFE_convertRouteMatchToUiMatch, stripBasename, IDLE_BLOCKER, isRouteErrorResponse, createMemoryHistory, AbortedDeferredError, createRouter } from '@remix-run/router';\nexport { AbortedDeferredError, Action as NavigationType, createPath, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, redirectDocument, resolvePath } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  AwaitContext.displayName = \"Await\";\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\n\nconst NavigationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\nconst navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = React.useContext(RouteContext);\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getResolveToMatches(matches));\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our history listener yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to handing off to history (but only if we're not in a data router,\n    // otherwise it'll prepend the basename inside of the router).\n    // If this is a root navigation, then we navigate to the raw basename\n    // which allows the basename to have full control over the presence of a\n    // trailing slash on root links\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/React.createContext(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /*#__PURE__*/React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getResolveToMatches(matches));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : UNSAFE_invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : void 0;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : void 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n  })), parentMatches, dataRouterState);\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (process.env.NODE_ENV !== \"production\") {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? /*#__PURE__*/React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/React.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error ? /*#__PURE__*/React.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, /*#__PURE__*/React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n}\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = React.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /*#__PURE__*/React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : UNSAFE_invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;\n    // Only data routers handle errors\n    let errorElement = null;\n    if (dataRouterState) {\n      errorElement = match.route.errorElement || defaultErrorElement;\n    }\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won't re-use the\n        // ReactElement since it's identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = /*#__PURE__*/React.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /*#__PURE__*/React.createElement(RenderedRoute, {\n        match: match,\n        routeContext: {\n          outlet,\n          matches,\n          isDataRoute: dataRouterState != null\n        },\n        children: children\n      });\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error: error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return React.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map(m => UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : undefined;\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n  var _state$errors;\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback(arg => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n\n    // If they provided us a function and we've got an active basename, strip\n    // it from the locations we expose to the user to match the behavior of\n    // useLocation\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don't get an orphaned blockerFunction in the router with a\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our router subscriber yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, message) : void 0;\n  }\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React.useState(router.state);\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    if (v7_startTransition && startTransitionImpl) {\n      startTransitionImpl(() => setStateImpl(newState));\n    } else {\n      setStateImpl(newState);\n    }\n  }, [setStateImpl, v7_startTransition]);\n\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator\n  }, state.initialized ? /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    state: state\n  }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n  let {\n    routes,\n    state\n  } = _ref2;\n  return useRoutesImpl(routes, undefined, state);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(!React.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  let path = resolveTo(to, UNSAFE_getResolveToMatches(matches), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nfunction Route(_props) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : UNSAFE_invariant(false) ;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false\n  } = _ref5;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : UNSAFE_invariant(false) : void 0;\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp\n  }), [basename, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/React.createElement(LocationContext.Provider, {\n    children: children,\n    value: locationContext\n  }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(() => {});\nclass AwaitErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), error => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: children\n      });\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (! /*#__PURE__*/React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : UNSAFE_invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"An index route cannot have child routes.\") : UNSAFE_invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\n\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.element) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      element: /*#__PURE__*/React.createElement(route.Component),\n      Component: undefined\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.errorElement) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: /*#__PURE__*/React.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties\n  }).initialize();\n}\n\nexport { Await, MemoryRouter, Navigate, Outlet, Route, Router, RouterProvider, Routes, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, mapRouteProperties as UNSAFE_mapRouteProperties, useRouteId as UNSAFE_useRouteId, useRoutesImpl as UNSAFE_useRoutesImpl, createMemoryRouter, createRoutesFromChildren, createRoutesFromChildren as createRoutesFromElements, renderMatches, useActionData, useAsyncError, useAsyncValue, useBlocker, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes };\n//# sourceMappingURL=index.js.map\n","/**\n * React Router DOM v6.20.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { UNSAFE_mapRouteProperties, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, Router, UNSAFE_useRoutesImpl, UNSAFE_NavigationContext, useHref, useResolvedPath, useLocation, useNavigate, createPath, UNSAFE_useRouteId, UNSAFE_RouteContext, useMatches, useNavigation, useBlocker } from 'react-router';\nexport { AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_useRouteId, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, redirectDocument, renderMatches, resolvePath, useActionData, useAsyncError, useAsyncValue, useBlocker, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';\nimport { stripBasename, UNSAFE_warning, createRouter, createBrowserHistory, createHashHistory, UNSAFE_ErrorResponseImpl, UNSAFE_invariant, joinPaths, IDLE_FETCHER, matchPath } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === \"_self\") &&\n  // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n    // web extensions. Relevant Bugzilla tickets:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement(\"form\"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n    }\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn't support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\n\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"],\n  _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"],\n  _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don't serialize SSR stack traces for security reasons\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/React.createContext({\n  isTransitioning: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/React.createContext(new Map());\nif (process.env.NODE_ENV !== \"production\") {\n  FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = ReactDOM[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl) {\n    startTransitionImpl(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nclass Deferred {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = value => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = reason => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React.useState(router.state);\n  let [pendingState, setPendingState] = React.useState();\n  let [vtContext, setVtContext] = React.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React.useState();\n  let [transition, setTransition] = React.useState();\n  let [interruption, setInterruption] = React.useState();\n  let fetcherData = React.useRef(new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = React.useCallback(cb => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = React.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      unstable_flushSync: flushSync,\n      unstable_viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    deletedFetchers.forEach(key => fetcherData.current.delete(key));\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== undefined) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n    // If this isn't a view transition or it's not available in this browser,\n    // just update and be done with it\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    // flushSync + startViewTransition\n    if (flushSync) {\n      // Flush through the context to mark DOM elements as transition=ing\n      flushSyncSafe(() => {\n        // Cancel any pending transitions\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      // Update the DOM\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      // Clean up after the animation completes\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    // startTransition + startViewTransition\n    if (transition) {\n      // Interrupting an in-progress transition, cancel and let everything flush\n      // out, and then kick off a new transition from the interruption state\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      // Completed navigation update with opted-in view transitions, let 'er rip\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  // When we start a view transition, create a Deferred we can use for the\n  // eventual \"completed\" render\n  React.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  // Once the deferred is created, kick off startViewTransition() to update the\n  // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n  // happened)\n  React.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition.finished.finally(() => {\n        setRenderDfd(undefined);\n        setTransition(undefined);\n        setPendingState(undefined);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  // When the new location finally renders and is committed to the DOM, this\n  // effect will run to resolve the transition\n  React.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  // If we get interrupted with a new navigation during a transition, we skip\n  // the active transition, let it cleanup, then kick it off again here\n  React.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(undefined);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, /*#__PURE__*/React.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator\n  }, state.initialized ? /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    state: state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    state\n  } = _ref3;\n  return UNSAFE_useRoutesImpl(routes, undefined, state);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref4;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref5;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\nif (process.env.NODE_ENV !== \"production\") {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */\nconst Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref7,\n    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  // Rendered into <a href> for absolute URLs\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can't do external URL detection without a valid URL\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : void 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React.createElement(\"a\", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */\nconst NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      unstable_viewTransition,\n      children\n    } = _ref8,\n    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\n  let {\n    navigator\n  } = React.useContext(UNSAFE_NavigationContext);\n  let isTransitioning = routerState != null &&\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n  // we're looking for a slash _after_ what's in `to`.  For example:\n  //\n  // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n  // both want to look for a / at index 6 to match URL `/users/matt`\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to,\n    unstable_viewTransition: unstable_viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nconst Form = /*#__PURE__*/React.forwardRef((_ref9, forwardedRef) => {\n  let {\n      fetcherKey,\n      navigate,\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref9,\n    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    });\n  };\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (process.env.NODE_ENV !== \"production\") {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React.useRef(false);\n  let location = useLocation();\n  let searchParams = React.useMemo(() =>\n  // Only merge in the defaults if we haven't yet called setSearchParams.\n  // Once we call that we want those to take precedence, otherwise you can't\n  // remove a param with setSearchParams({}) if it has an initial value\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let currentRouteId = UNSAFE_useRouteId();\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let routeContext = React.useContext(UNSAFE_RouteContext);\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFormAction must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = _extends({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  // If no action was specified, browsers will persist current search params\n  // when determining the path, so match that behavior\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to this directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    path.search = location.search;\n    // When grabbing search params from the URL, remove any included ?index param\n    // since it might not apply to our contextual route.  We add it back based\n    // on match.route.index below\n    let params = new URLSearchParams(path.search);\n    if (params.has(\"index\") && params.get(\"index\") === \"\") {\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n  let fetcherData = React.useContext(FetchersContext);\n  let route = React.useContext(UNSAFE_RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a FetchersContext\") : UNSAFE_invariant(false) : void 0;\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  // Fetcher key handling\n  let [fetcherKey, setFetcherKey] = React.useState(key || \"\");\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    setFetcherKey(getUniqueFetcherId());\n  }\n  // Registration/cleanup\n  React.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n      // will not delete immediately but instead queue up a delete after the\n      // fetcher returns to an `idle` state\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  // Fetcher additions\n  let load = React.useCallback((href, opts) => {\n    !routeId ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No routeId available for fetcher.load()\") : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = React.useCallback((target, opts) => {\n    submitImpl(target, _extends({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = React.useMemo(() => {\n    let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n      return /*#__PURE__*/React.createElement(Form, _extends({}, props, {\n        navigate: false,\n        fetcherKey: fetcherKey,\n        ref: ref\n      }));\n    });\n    if (process.env.NODE_ENV !== \"production\") {\n      FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n  }, [fetcherKey]);\n  // Exposed FetcherWithComponents\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React.useMemo(() => _extends({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return Array.from(state.fetchers.entries()).map(_ref11 => {\n    let [key, fetcher] = _ref11;\n    return _extends({}, fetcher, {\n      key\n    });\n  });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(React.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n      process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : void 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\n      _extends({}, location, {\n        pathname: stripBasename(location.pathname, basename) || location.pathname\n      }), matches) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don't reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = useBlocker(when);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        // This timeout is needed to avoid a weird \"race\" on POP navigations\n        // between the `window.history` revert navigation and the result of\n        // `window.confirm`\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = React.useContext(ViewTransitionContext);\n  !(vtContext != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename\n  } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n  let path = useResolvedPath(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  // Transition is active if we're going to or coming from the indicated\n  // destination.  This ensures that other PUSH navigations that reverse\n  // an indicated transition apply.  I.e., on the list view you have:\n  //\n  //   <NavLink to=\"/details/1\" unstable_viewTransition>\n  //\n  // If you click the breadcrumb back to the list view:\n  //\n  //   <NavLink to=\"/list\" unstable_viewTransition>\n  //\n  // We should apply the transition because it's indicated as active going\n  // from /list -> /details/1 and therefore should be active on the reverse\n  // (even though this isn't strictly a POP reverse)\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n//#endregion\n\nexport { BrowserRouter, Form, HashRouter, Link, NavLink, RouterProvider, ScrollRestoration, FetchersContext as UNSAFE_FetchersContext, ViewTransitionContext as UNSAFE_ViewTransitionContext, useScrollRestoration as UNSAFE_useScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, usePrompt as unstable_usePrompt, useViewTransitionState as unstable_useViewTransitionState, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit };\n//# sourceMappingURL=index.js.map\n","/*!\n* tabbable 6.0.1\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRootHost;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  var nodeRootHost = getRootNode(node).host;\n  var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));\n  while (!attached && nodeRootHost) {\n    var _nodeRootHost2;\n    // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n    //  which means we need to get the host's host and check if that parent host is contained\n    //  in (i.e. attached to) the document\n    nodeRootHost = getRootNode(nodeRootHost).host;\n    attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.2.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, isFocusable } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) ||\n      // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return isTabbable(n, config.tabbableOptions);\n            });\n          }\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return isTabbable(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === doc.activeElement) {\n      return;\n    }\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var target = getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  var checkKey = function checkKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n      return;\n    }\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      if (onActivate) {\n        onActivate();\n      }\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      if (onDeactivate) {\n        onDeactivate();\n      }\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar React = require('react');\nvar PropTypes = require('prop-types');\nvar _require = require('focus-trap'),\n  createFocusTrap = _require.createFocusTrap;\nvar _require2 = require('tabbable'),\n  isFocusable = _require2.isFocusable;\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  _inherits(FocusTrap, _React$Component);\n  var _super = _createSuper(FocusTrap);\n  function FocusTrap(props) {\n    var _this;\n    _classCallCheck(this, FocusTrap);\n    _this = _super.call(this, props);\n    _defineProperty(_assertThisInitialized(_this), \"getNodeForOption\", function (optionName) {\n      var _this$internalOptions;\n      // use internal options first, falling back to original options\n      var optionValue = (_this$internalOptions = this.internalOptions[optionName]) !== null && _this$internalOptions !== void 0 ? _this$internalOptions : this.originalOptions[optionName];\n      if (typeof optionValue === 'function') {\n        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          params[_key - 1] = arguments[_key];\n        }\n        optionValue = optionValue.apply(void 0, params);\n      }\n      if (optionValue === true) {\n        optionValue = undefined; // use default value\n      }\n\n      if (!optionValue) {\n        if (optionValue === undefined || optionValue === false) {\n          return optionValue;\n        }\n        // else, empty string (invalid), null (invalid), 0 (invalid)\n\n        throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n      }\n      var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n      if (typeof optionValue === 'string') {\n        var _this$getDocument;\n        node = (_this$getDocument = this.getDocument()) === null || _this$getDocument === void 0 ? void 0 : _this$getDocument.querySelector(optionValue); // resolve to node, or null if fails\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n      }\n      return node;\n    });\n    _this.handleDeactivate = _this.handleDeactivate.bind(_assertThisInitialized(_this));\n    _this.handlePostDeactivate = _this.handlePostDeactivate.bind(_assertThisInitialized(_this));\n    _this.handleClickOutsideDeactivates = _this.handleClickOutsideDeactivates.bind(_assertThisInitialized(_this));\n\n    // focus-trap options used internally when creating the trap\n    _this.internalOptions = {\n      // We need to hijack the returnFocusOnDeactivate option,\n      // because React can move focus into the element before we arrived at\n      // this lifecycle hook (e.g. with autoFocus inputs). So the component\n      // captures the previouslyFocusedElement in componentWillMount,\n      // then (optionally) returns focus to it in componentWillUnmount.\n      returnFocusOnDeactivate: false,\n      // the rest of these are also related to deactivation of the trap, and we\n      //  need to use them and control them as well\n      checkCanReturnFocus: null,\n      onDeactivate: _this.handleDeactivate,\n      onPostDeactivate: _this.handlePostDeactivate,\n      // we need to special-case this setting as well so that we can know if we should\n      //  NOT return focus if the trap gets auto-deactivated as the result of an\n      //  outside click (otherwise, we'll always think we should return focus because\n      //  of how we manage that flag internally here)\n      clickOutsideDeactivates: _this.handleClickOutsideDeactivates\n    };\n\n    // original options provided by the consumer\n    _this.originalOptions = {\n      // because of the above `internalOptions`, we maintain our own flag for\n      //  this option, and default it to `true` because that's focus-trap's default\n      returnFocusOnDeactivate: true,\n      // because of the above `internalOptions`, we keep these separate since\n      //  they're part of the deactivation process which we configure (internally) to\n      //  be shared between focus-trap and focus-trap-react\n      onDeactivate: null,\n      onPostDeactivate: null,\n      checkCanReturnFocus: null,\n      // the user's setting, defaulted to false since focus-trap defaults this to false\n      clickOutsideDeactivates: false\n    };\n    var focusTrapOptions = props.focusTrapOptions;\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n      if (optionName === 'returnFocusOnDeactivate' || optionName === 'onDeactivate' || optionName === 'onPostDeactivate' || optionName === 'checkCanReturnFocus' || optionName === 'clickOutsideDeactivates') {\n        _this.originalOptions[optionName] = focusTrapOptions[optionName];\n        continue; // exclude from internalOptions\n      }\n\n      _this.internalOptions[optionName] = focusTrapOptions[optionName];\n    }\n\n    // if set, `{ target: Node, allowDeactivation: boolean }` where `target` is the outside\n    //  node that was clicked, and `allowDeactivation` is the result of the consumer's\n    //  option (stored in `this.originalOptions.clickOutsideDeactivates`, which may be a\n    //  function) whether to allow or deny auto-deactivation on click on this outside node\n    _this.outsideClick = null;\n\n    // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n    _this.focusTrapElements = props.containerElements || [];\n\n    // now we remember what the currently focused element is, not relying on focus-trap\n    _this.updatePreviousElement();\n    return _this;\n  }\n\n  /**\n   * Gets the configured document.\n   * @returns {Document|undefined} Configured document, falling back to the main\n   *  document, if it exists. During SSR, `undefined` is returned since the\n   *  document doesn't exist.\n   */\n  _createClass(FocusTrap, [{\n    key: \"getDocument\",\n    value: function getDocument() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      return this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n    }\n\n    /**\n     * Gets the node for the given option, which is expected to be an option that\n     *  can be either a DOM node, a string that is a selector to get a node, `false`\n     *  (if a node is explicitly NOT given), or a function that returns any of these\n     *  values.\n     * @param {string} optionName\n     * @returns {undefined | false | HTMLElement | SVGElement} Returns\n     *  `undefined` if the option is not specified; `false` if the option\n     *  resolved to `false` (node explicitly not given); otherwise, the resolved\n     *  DOM node.\n     * @throws {Error} If the option is set, not `false`, and is not, or does not\n     *  resolve to a node.\n     */\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus', this.previouslyFocusedElement);\n      return node ? node : node === false ? false : this.previouslyFocusedElement;\n    }\n\n    /** Update the previously focused element with the currently focused element. */\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      var currentDocument = this.getDocument();\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      // NOTE: it's possible the focus trap has already been deactivated without our knowing it,\n      //  especially if the user set the `clickOutsideDeactivates: true` option on the trap,\n      //  and the mouse was clicked on some element outside the trap; at that point, focus-trap\n      //  will initiate its auto-deactivation process, which will call our own\n      //  handleDeactivate(), which will call into this method\n      if (!this.focusTrap || !this.focusTrap.active) {\n        return;\n      }\n      this.focusTrap.deactivate({\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        returnFocus: false,\n        // we'll call this in our own post deactivate handler so make sure the trap doesn't\n        //  do it prematurely\n        checkCanReturnFocus: null,\n        // let it call the user's original deactivate handler, if any, instead of\n        //  our own which calls back into this function\n        onDeactivate: this.originalOptions.onDeactivate\n        // NOTE: for post deactivate, don't specify anything so that it calls the\n        //  onPostDeactivate handler specified on `this.internalOptions`\n        //  which will always be our own `handlePostDeactivate()` handler, which\n        //  will finish things off by calling the user's provided onPostDeactivate\n        //  handler, if any, at the right time\n        // onPostDeactivate: NOTHING\n      });\n    }\n  }, {\n    key: \"handleClickOutsideDeactivates\",\n    value: function handleClickOutsideDeactivates(event) {\n      // use consumer's option (or call their handler) as the permission or denial\n      var allowDeactivation = typeof this.originalOptions.clickOutsideDeactivates === 'function' ? this.originalOptions.clickOutsideDeactivates.call(null, event) // call out of context\n      : this.originalOptions.clickOutsideDeactivates; // boolean\n\n      if (allowDeactivation) {\n        // capture the outside target that was clicked so we can use it in the deactivation\n        //  process since the consumer allowed it to cause auto-deactivation\n        this.outsideClick = {\n          target: event.target,\n          allowDeactivation: allowDeactivation\n        };\n      }\n      return allowDeactivation;\n    }\n  }, {\n    key: \"handleDeactivate\",\n    value: function handleDeactivate() {\n      if (this.originalOptions.onDeactivate) {\n        this.originalOptions.onDeactivate.call(null); // call user's handler out of context\n      }\n\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"handlePostDeactivate\",\n    value: function handlePostDeactivate() {\n      var _this2 = this;\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n        var canReturnFocus = !!(\n        // did the consumer allow it?\n\n        _this2.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?\n        returnFocusNode !== null && returnFocusNode !== void 0 && returnFocusNode.focus && (\n        // was there an outside click that allowed deactivation?\n        !_this2.outsideClick ||\n        // did the consumer allow deactivation when the outside node was clicked?\n        _this2.outsideClick.allowDeactivation &&\n        // is the outside node NOT focusable (implying that it did NOT receive focus\n        //  as a result of the click-through) -- in which case do NOT restore focus\n        //  to `returnFocusNode` because focus should remain on the outside node\n        !isFocusable(_this2.outsideClick.target, _this2.internalOptions.tabbableOptions))\n\n        // if no, the restore focus to `returnFocusNode` at this point\n        );\n\n        var _this2$internalOption = _this2.internalOptions.preventScroll,\n          preventScroll = _this2$internalOption === void 0 ? false : _this2$internalOption;\n        if (canReturnFocus) {\n          // return focus to the element that had focus when the trap was activated\n          returnFocusNode.focus({\n            preventScroll: preventScroll\n          });\n        }\n        if (_this2.originalOptions.onPostDeactivate) {\n          _this2.originalOptions.onPostDeactivate.call(null); // don't call it in context of \"this\"\n        }\n\n        _this2.outsideClick = null; // reset: no longer needed\n      };\n\n      if (this.originalOptions.checkCanReturnFocus) {\n        this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()) // call out of context\n        .then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (this.focusTrap) {\n        // trap already exists: it's possible we're in StrictMode and we're being remounted,\n        //  in which case, we will have deactivated the trap when we got unmounted (remember,\n        //  StrictMode, in development, purposely unmounts and remounts components after\n        //  mounting them the first time to make sure they have reusable state,\n        //  @see https://reactjs.org/docs/strict-mode.html#ensuring-reusable-state) so now\n        //  we need to restore the state of the trap according to our component state\n        // NOTE: Strict mode __violates__ assumptions about the `componentWillUnmount()` API\n        //  which clearly states -- even for React 18 -- that, \"Once a component instance is\n        //  unmounted, __it will never be mounted again.__\" (emphasis ours). So when we get\n        //  unmounted, we assume we're gone forever and we deactivate the trap. But then\n        //  we get remounted and we're supposed to restore state. But if you had paused,\n        //  we've now deactivated (we don't know we're amount to get remounted again)\n        //  which means we need to reactivate and then pause. Otherwise, do nothing.\n        if (this.props.active && !this.focusTrap.active) {\n          this.focusTrap.activate();\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      } else {\n        var nodesExist = this.focusTrapElements.some(Boolean);\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(this.focusTrapElements, this.internalOptions);\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.active) {\n        this.setupFocusTrap();\n      }\n      // else, wait for later activation in case the `focusTrapOptions` will be updated\n      //  again before the trap is activated (e.g. if waiting to know what the document\n      //  object will be, so the Trap must be rendered, but the consumer is waiting to\n      //  activate until they have obtained the document from a ref)\n      //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else {\n        // NOTE: if we're in `componentDidUpdate` and we don't have a trap yet,\n        //  it either means it shouldn't be active, or it should be but none of\n        //  of given `containerElements` were present in the DOM the last time\n        //  we tried to create the trap\n\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrapElements = this.props.containerElements;\n        }\n\n        // don't create the trap unless it should be active in case the consumer\n        //  is still updating `focusTrapOptions`\n        //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n        if (this.props.active) {\n          this.updatePreviousElement();\n          this.setupFocusTrap();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n        var callbackRef = function callbackRef(element) {\n          var containerElements = _this3.props.containerElements;\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n        var childWithRef = React.cloneElement(child, {\n          ref: callbackRef\n        });\n        return childWithRef;\n      }\n      return null;\n    }\n  }]);\n  return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string,\n    // NOTE: does not support `false` as value (or return value from function)\n    PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool,\n    tabbableOptions: PropTypes.shape({\n      displayCheck: PropTypes.oneOf(['full', 'legacy-full', 'non-zero-area', 'none']),\n      getShadowRoot: PropTypes.oneOfType([PropTypes.bool, PropTypes.func])\n    }),\n    trapStack: PropTypes.array,\n    isKeyForward: PropTypes.func,\n    isKeyBackward: PropTypes.func\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  // DOM element ONLY\n  children: PropTypes.oneOfType([PropTypes.element,\n  // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ])\n\n  // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n};\n\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;","import { useCallback, useRef } from 'react';\n\nexport interface DebounceOptions {\n  wait?: number;\n  immediate?: boolean;\n}\nexport type DebounceCallback<T extends unknown[]> = (...args: T) => void;\n\nexport function useDebounce<T extends unknown[]>(\n  callback: DebounceCallback<T>,\n  options?: DebounceOptions\n): DebounceCallback<T> {\n  const timeoutIdRef = useRef<number>();\n  const { wait, immediate } = options ?? {};\n\n  const debounceCallback = useCallback(\n    (...cbArgs: T) => {\n      if (timeoutIdRef.current) {\n        clearTimeout(timeoutIdRef.current);\n        timeoutIdRef.current = undefined;\n      } else if (immediate) {\n        callback(...cbArgs);\n      }\n\n      timeoutIdRef.current = window.setTimeout(() => {\n        callback(...cbArgs);\n        timeoutIdRef.current = undefined;\n      }, wait);\n    },\n    [callback, wait, immediate]\n  );\n\n  return debounceCallback;\n}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name]) {\n        throw new TypeError('Unknown modifier: \"' + value + '\"');\n      }\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\nexports.default = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;","import { isKeyHotkey } from 'is-hotkey';\nimport { KeyboardEventHandler } from 'react';\n\nexport interface KeyboardEventLike {\n  key: string;\n  which: number;\n  altKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  shiftKey: boolean;\n  preventDefault(): void;\n}\n\nexport const onTabPress = (evt: KeyboardEventLike, callback: () => void) => {\n  if (isKeyHotkey('tab', evt)) {\n    evt.preventDefault();\n    callback();\n  }\n};\n\nexport const preventScrollWithArrowKey: KeyboardEventHandler = (evt) => {\n  if (isKeyHotkey(['arrowup', 'arrowright', 'arrowdown', 'arrowleft'], evt)) {\n    evt.preventDefault();\n  }\n};\n\nexport const onEnterOrSpace =\n  <T>(callback: (evt: T) => void) =>\n  (evt: KeyboardEventLike) => {\n    if (isKeyHotkey('enter', evt) || isKeyHotkey('space', evt)) {\n      evt.preventDefault();\n      callback(evt as T);\n    }\n  };\n\nexport const stopPropagation = (evt: KeyboardEvent): boolean => {\n  evt.stopPropagation();\n  return true;\n};\n","import React, {\n  ChangeEventHandler,\n  KeyboardEventHandler,\n  MouseEventHandler,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  Header,\n  Icon,\n  IconButton,\n  Icons,\n  Input,\n  Menu,\n  MenuItem,\n  PopOut,\n  RectCords,\n  Text,\n  config,\n} from 'folds';\nimport FocusTrap from 'focus-trap-react';\n\nimport { useDebounce } from '../../hooks/useDebounce';\nimport { stopPropagation } from '../../utils/keyboard';\n\nexport function ServerPicker({\n  server,\n  serverList,\n  allowCustomServer,\n  onServerChange,\n}: {\n  server: string;\n  serverList: string[];\n  allowCustomServer?: boolean;\n  onServerChange: (server: string) => void;\n}) {\n  const [serverMenuAnchor, setServerMenuAnchor] = useState<RectCords>();\n  const serverInputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    // sync input with it outside server changes\n    if (serverInputRef.current && serverInputRef.current.value !== server) {\n      serverInputRef.current.value = server;\n    }\n  }, [server]);\n\n  const debounceServerSelect = useDebounce(onServerChange, { wait: 700 });\n\n  const handleServerChange: ChangeEventHandler<HTMLInputElement> = (evt) => {\n    const inputServer = evt.target.value.trim();\n    if (inputServer) debounceServerSelect(inputServer);\n  };\n\n  const handleKeyDown: KeyboardEventHandler<HTMLInputElement> = (evt) => {\n    if (evt.key === 'ArrowDown') {\n      evt.preventDefault();\n      setServerMenuAnchor(undefined);\n    }\n    if (evt.key === 'Enter') {\n      evt.preventDefault();\n      const inputServer = evt.currentTarget.value.trim();\n      if (inputServer) onServerChange(inputServer);\n    }\n  };\n\n  const handleServerSelect: MouseEventHandler<HTMLButtonElement> = (evt) => {\n    const selectedServer = evt.currentTarget.getAttribute('data-server');\n    if (selectedServer) {\n      onServerChange(selectedServer);\n    }\n    setServerMenuAnchor(undefined);\n  };\n\n  const handleOpenServerMenu: MouseEventHandler<HTMLElement> = (evt) => {\n    const target = evt.currentTarget.parentElement ?? evt.currentTarget;\n    setServerMenuAnchor(target.getBoundingClientRect());\n  };\n\n  return (\n    <Input\n      ref={serverInputRef}\n      style={{ paddingRight: config.space.S200 }}\n      variant={allowCustomServer ? 'Background' : 'Surface'}\n      outlined\n      defaultValue={server}\n      onChange={handleServerChange}\n      onKeyDown={handleKeyDown}\n      size=\"500\"\n      readOnly={!allowCustomServer}\n      onClick={allowCustomServer ? undefined : handleOpenServerMenu}\n      after={\n        serverList.length === 0 || (serverList.length === 1 && !allowCustomServer) ? undefined : (\n          <PopOut\n            anchor={serverMenuAnchor}\n            position=\"Bottom\"\n            align=\"End\"\n            offset={4}\n            content={\n              <FocusTrap\n                focusTrapOptions={{\n                  initialFocus: false,\n                  onDeactivate: () => setServerMenuAnchor(undefined),\n                  clickOutsideDeactivates: true,\n                  isKeyForward: (evt: KeyboardEvent) => evt.key === 'ArrowDown',\n                  isKeyBackward: (evt: KeyboardEvent) => evt.key === 'ArrowUp',\n                  escapeDeactivates: stopPropagation,\n                }}\n              >\n                <Menu>\n                  <Header size=\"300\" style={{ padding: `0 ${config.space.S200}` }}>\n                    <Text size=\"L400\">Homeserver List</Text>\n                  </Header>\n                  <div style={{ padding: config.space.S100, paddingTop: 0 }}>\n                    {serverList?.map((serverName) => (\n                      <MenuItem\n                        key={serverName}\n                        radii=\"300\"\n                        aria-pressed={serverName === server}\n                        data-server={serverName}\n                        onClick={handleServerSelect}\n                      >\n                        <Text>{serverName}</Text>\n                      </MenuItem>\n                    ))}\n                  </div>\n                </Menu>\n              </FocusTrap>\n            }\n          >\n            <IconButton\n              onClick={handleOpenServerMenu}\n              variant={allowCustomServer ? 'Background' : 'Surface'}\n              size=\"300\"\n              aria-pressed={!!serverMenuAnchor}\n              radii=\"300\"\n            >\n              <Icon src={Icons.ChevronBottom} />\n            </IconButton>\n          </PopOut>\n        )\n      }\n    />\n  );\n}\n","/**\n * @param { Promise } promise\n * @param { Object= } errorExt - Additional Information you can pass to the err object\n * @return { Promise }\n */\nfunction to(promise, errorExt) {\n    return promise\n        .then(function (data) { return [null, data]; })\n        .catch(function (err) {\n        if (errorExt) {\n            Object.assign(err, errorExt);\n        }\n        return [err, undefined];\n    });\n}\n\nexport { to };\nexport default to;\n//# sourceMappingURL=await-to-js.es5.js.map\n","import to from 'await-to-js';\nimport { trimTrailingSlash } from './utils/common';\n\nexport enum AutoDiscoveryAction {\n  PROMPT = 'PROMPT',\n  IGNORE = 'IGNORE',\n  FAIL_PROMPT = 'FAIL_PROMPT',\n  FAIL_ERROR = 'FAIL_ERROR',\n}\n\nexport type AutoDiscoveryError = {\n  host: string;\n  action: AutoDiscoveryAction;\n};\n\nexport type AutoDiscoveryInfo = Record<string, unknown> & {\n  'm.homeserver': {\n    base_url: string;\n  };\n  'm.identity_server'?: {\n    base_url: string;\n  };\n};\n\nexport const autoDiscovery = async (\n  request: typeof fetch,\n  server: string\n): Promise<[AutoDiscoveryError, undefined] | [undefined, AutoDiscoveryInfo]> => {\n  const host = /^https?:\\/\\//.test(server) ? trimTrailingSlash(server) : `https://${server}`;\n  const autoDiscoveryUrl = `${host}/.well-known/matrix/client`;\n\n  const [err, response] = await to(request(autoDiscoveryUrl, { method: 'GET' }));\n\n  if (err || response.status === 404) {\n    // AutoDiscoveryAction.IGNORE\n    // We will use default value for IGNORE action\n    return [\n      undefined,\n      {\n        'm.homeserver': {\n          base_url: host,\n        },\n      },\n    ];\n  }\n  if (response.status !== 200) {\n    return [\n      {\n        host,\n        action: AutoDiscoveryAction.FAIL_PROMPT,\n      },\n      undefined,\n    ];\n  }\n\n  const [contentErr, content] = await to<AutoDiscoveryInfo>(response.json());\n\n  if (contentErr || typeof content !== 'object') {\n    return [\n      {\n        host,\n        action: AutoDiscoveryAction.FAIL_PROMPT,\n      },\n      undefined,\n    ];\n  }\n\n  const baseUrl = content['m.homeserver']?.base_url;\n  if (typeof baseUrl !== 'string') {\n    return [\n      {\n        host,\n        action: AutoDiscoveryAction.FAIL_PROMPT,\n      },\n      undefined,\n    ];\n  }\n\n  if (/^https?:\\/\\//.test(baseUrl) === false) {\n    return [\n      {\n        host,\n        action: AutoDiscoveryAction.FAIL_ERROR,\n      },\n      undefined,\n    ];\n  }\n\n  content['m.homeserver'].base_url = trimTrailingSlash(baseUrl);\n  if (content['m.identity_server']) {\n    content['m.identity_server'].base_url = trimTrailingSlash(\n      content['m.identity_server'].base_url\n    );\n  }\n\n  return [undefined, content];\n};\n\nexport type SpecVersions = {\n  versions: string[];\n  unstable_features?: Record<string, boolean>;\n};\nexport const specVersions = async (\n  request: typeof fetch,\n  baseUrl: string\n): Promise<SpecVersions> => {\n  const res = await request(`${trimTrailingSlash(baseUrl)}/_matrix/client/versions`);\n\n  const data = (await res.json()) as unknown;\n\n  if (data && typeof data === 'object' && 'versions' in data && Array.isArray(data.versions)) {\n    return data as SpecVersions;\n  }\n  throw new Error('Homeserver URL does not appear to be a valid Matrix homeserver');\n};\n","import { ReactNode, useCallback, useEffect, useState } from 'react';\nimport { AsyncStatus, useAsyncCallback } from '../hooks/useAsyncCallback';\nimport { SpecVersions, specVersions } from '../cs-api';\n\ntype SpecVersionsLoaderProps = {\n  baseUrl: string;\n  fallback?: () => ReactNode;\n  error?: (err: unknown, retry: () => void, ignore: () => void) => ReactNode;\n  children: (versions: SpecVersions) => ReactNode;\n};\nexport function SpecVersionsLoader({\n  baseUrl,\n  fallback,\n  error,\n  children,\n}: SpecVersionsLoaderProps) {\n  const [state, load] = useAsyncCallback(\n    useCallback(() => specVersions(fetch, baseUrl), [baseUrl])\n  );\n  const [ignoreError, setIgnoreError] = useState(false);\n\n  const ignoreCallback = useCallback(() => setIgnoreError(true), []);\n\n  useEffect(() => {\n    load();\n  }, [load]);\n\n  if (state.status === AsyncStatus.Idle || state.status === AsyncStatus.Loading) {\n    return fallback?.();\n  }\n\n  if (!ignoreError && state.status === AsyncStatus.Error) {\n    return error?.(state.error, load, ignoreCallback);\n  }\n\n  return children(\n    state.status === AsyncStatus.Success\n      ? state.data\n      : {\n          versions: [],\n        }\n  );\n}\n","import { createContext, useContext } from 'react';\nimport { SpecVersions } from '../cs-api';\n\nconst SpecVersionsContext = createContext<SpecVersions | null>(null);\n\nexport const SpecVersionsProvider = SpecVersionsContext.Provider;\n\nexport function useSpecVersions(): SpecVersions {\n  const versions = useContext(SpecVersionsContext);\n  if (!versions) throw new Error('Server versions are not provided!');\n  return versions;\n}\n","import { createContext, useContext } from 'react';\nimport { AutoDiscoveryInfo } from '../cs-api';\n\nconst AutoDiscoverInfoContext = createContext<AutoDiscoveryInfo | null>(null);\n\nexport const AutoDiscoveryInfoProvider = AutoDiscoverInfoContext.Provider;\n\nexport const useAutoDiscoveryInfo = (): AutoDiscoveryInfo => {\n  const autoDiscoveryInfo = useContext(AutoDiscoverInfoContext);\n  if (!autoDiscoveryInfo) {\n    throw new Error('Auto Discovery Info not loaded');\n  }\n\n  return autoDiscoveryInfo;\n};\n","function asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nexport { _asyncToGenerator as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2018 Andr Jaenisch\nCopyright 2019, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport loglevel from \"loglevel\";\n\n/** Logger interface used within the js-sdk codebase */\n\n/** The basic interface for a logger which doesn't support children */\n\n// This is to demonstrate, that you can use any namespace you want.\n// Namespaces allow you to turn on/off the logging for specific parts of the\n// application.\n// An idea would be to control this via an environment variable (on Node.js).\n// See https://www.npmjs.com/package/debug to see how this could be implemented\n// Part of #332 is introducing a logging library in the first place.\nvar DEFAULT_NAMESPACE = \"matrix\";\n\n// because rageshakes in react-sdk hijack the console log, also at module load time,\n// initializing the logger here races with the initialization of rageshakes.\n// to avoid the issue, we override the methodFactory of loglevel that binds to the\n// console methods at initialization time by a factory that looks up the console methods\n// when logging so we always get the current value of console methods.\nloglevel.methodFactory = function (methodName, logLevel, loggerName) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    /* eslint-disable @typescript-eslint/no-invalid-this */\n    if (this.prefix) {\n      args.unshift(this.prefix);\n    }\n    /* eslint-enable @typescript-eslint/no-invalid-this */\n    var supportedByConsole = methodName === \"error\" || methodName === \"warn\" || methodName === \"trace\" || methodName === \"info\" || methodName === \"debug\";\n    /* eslint-disable no-console */\n    if (supportedByConsole) {\n      return console[methodName](...args);\n    } else {\n      return console.log(...args);\n    }\n    /* eslint-enable no-console */\n  };\n};\n\n/**\n * Implementation of {@link Logger} based on `loglevel`.\n *\n * @deprecated this shouldn't be public; prefer {@link Logger}.\n */\n\n/** Internal utility function to turn a `loglevel.Logger` into a `PrefixedLogger` */\nfunction extendLogger(logger) {\n  var prefixedLogger = logger;\n  prefixedLogger.getChild = prefixedLogger.withPrefix = function (prefix) {\n    var existingPrefix = this.prefix || \"\";\n    return getPrefixedLogger(existingPrefix + prefix);\n  };\n}\nfunction getPrefixedLogger(prefix) {\n  var prefixLogger = loglevel.getLogger(\"\".concat(DEFAULT_NAMESPACE, \"-\").concat(prefix));\n  if (prefixLogger.prefix !== prefix) {\n    // Only do this setup work the first time through, as loggers are saved by name.\n    extendLogger(prefixLogger);\n    prefixLogger.prefix = prefix;\n    prefixLogger.setLevel(loglevel.levels.DEBUG, false);\n  }\n  return prefixLogger;\n}\n\n/**\n * Drop-in replacement for `console` using {@link https://www.npmjs.com/package/loglevel|loglevel}.\n * Can be tailored down to specific use cases if needed.\n */\nexport var logger = loglevel.getLogger(DEFAULT_NAMESPACE);\nlogger.setLevel(loglevel.levels.DEBUG, false);\nextendLogger(logger);\n\n/**\n * A \"span\" for grouping related log lines together.\n *\n * The current implementation just adds the name at the start of each log line.\n *\n * This offers a lighter-weight alternative to 'child' loggers returned by {@link Logger#getChild}. In particular,\n * it's not possible to apply individual filters to the LogSpan such as setting the verbosity level. On the other hand,\n * no reference to the LogSpan is retained in the logging framework, so it is safe to make lots of them over the course\n * of an application's life and just drop references to them when the job is done.\n */\nexport class LogSpan {\n  constructor(parent, name) {\n    this.parent = parent;\n    _defineProperty(this, \"name\", void 0);\n    this.name = name + \":\";\n  }\n  trace() {\n    for (var _len2 = arguments.length, msg = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      msg[_key2] = arguments[_key2];\n    }\n    this.parent.trace(this.name, ...msg);\n  }\n  debug() {\n    for (var _len3 = arguments.length, msg = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      msg[_key3] = arguments[_key3];\n    }\n    this.parent.debug(this.name, ...msg);\n  }\n  info() {\n    for (var _len4 = arguments.length, msg = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      msg[_key4] = arguments[_key4];\n    }\n    this.parent.info(this.name, ...msg);\n  }\n  warn() {\n    for (var _len5 = arguments.length, msg = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      msg[_key5] = arguments[_key5];\n    }\n    this.parent.warn(this.name, ...msg);\n  }\n  error() {\n    for (var _len6 = arguments.length, msg = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      msg[_key6] = arguments[_key6];\n    }\n    this.parent.error(this.name, ...msg);\n  }\n}\n//# sourceMappingURL=logger.js.map","'use strict';\n\n\nvar data = require('./data.json');\n\nfunction escapeRegexp(str) {\n  return str.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n}\n\nvar REPLACE_RE = RegExp(Object.keys(data).map(escapeRegexp).join('|'), 'g');\n\nfunction replace_fn(match) {\n  return data[match];\n}\n\nfunction unhomoglyph(str) {\n  return str.replace(REPLACE_RE, replace_fn);\n}\n\nmodule.exports = unhomoglyph;\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","module.exports = require('./lib/retry');","'use strict';\nconst retry = require('retry');\n\nconst networkErrorMsgs = [\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari\n\t'Network request failed' // `cross-fetch`\n];\n\nclass AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nconst isNetworkError = errorMessage => networkErrorMsgs.includes(errorMessage);\n\nconst pRetry = (input, options) => new Promise((resolve, reject) => {\n\toptions = {\n\t\tonFailedAttempt: () => {},\n\t\tretries: 10,\n\t\t...options\n\t};\n\n\tconst operation = retry.operation(options);\n\n\toperation.attempt(async attemptNumber => {\n\t\ttry {\n\t\t\tresolve(await input(attemptNumber));\n\t\t} catch (error) {\n\t\t\tif (!(error instanceof Error)) {\n\t\t\t\treject(new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (error instanceof AbortError) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error.originalError);\n\t\t\t} else if (error instanceof TypeError && !isNetworkError(error.message)) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\ttry {\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\treject(operation.mainError());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n});\n\nmodule.exports = pRetry;\n// TODO: remove this in the next major version\nmodule.exports.default = pRetry;\n\nmodule.exports.AbortError = AbortError;\n","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents a simple Matrix namespaced value. This will assume that if a stable prefix\n * is provided that the stable prefix should be used when representing the identifier.\n */\nexport class NamespacedValue {\n  // Stable is optional, but one of the two parameters is required, hence the weird-looking types.\n  // Goal is to to have developers explicitly say there is no stable value (if applicable).\n\n  constructor(stable, unstable) {\n    this.stable = stable;\n    this.unstable = unstable;\n    if (!this.unstable && !this.stable) {\n      throw new Error(\"One of stable or unstable values must be supplied\");\n    }\n  }\n  get name() {\n    if (this.stable) {\n      return this.stable;\n    }\n    return this.unstable;\n  }\n  get altName() {\n    if (!this.stable) {\n      return null;\n    }\n    return this.unstable;\n  }\n  get names() {\n    var names = [this.name];\n    var altName = this.altName;\n    if (altName) names.push(altName);\n    return names;\n  }\n  matches(val) {\n    return this.name === val || this.altName === val;\n  }\n\n  // this desperately wants https://github.com/microsoft/TypeScript/pull/26349 at the top level of the class\n  // so we can instantiate `NamespacedValue<string, _, _>` as a default type for that namespace.\n  findIn(obj) {\n    var val = undefined;\n    if (this.name) {\n      val = obj === null || obj === void 0 ? void 0 : obj[this.name];\n    }\n    if (!val && this.altName) {\n      val = obj === null || obj === void 0 ? void 0 : obj[this.altName];\n    }\n    return val;\n  }\n  includedIn(arr) {\n    var included = false;\n    if (this.name) {\n      included = arr.includes(this.name);\n    }\n    if (!included && this.altName) {\n      included = arr.includes(this.altName);\n    }\n    return included;\n  }\n}\nexport class ServerControlledNamespacedValue extends NamespacedValue {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"preferUnstable\", false);\n  }\n  setPreferUnstable(preferUnstable) {\n    this.preferUnstable = preferUnstable;\n  }\n  get name() {\n    if (this.stable && !this.preferUnstable) {\n      return this.stable;\n    }\n    return this.unstable;\n  }\n}\n\n/**\n * Represents a namespaced value which prioritizes the unstable value over the stable\n * value.\n */\nexport class UnstableValue extends NamespacedValue {\n  // Note: Constructor difference is that `unstable` is *required*.\n  constructor(stable, unstable) {\n    super(stable, unstable);\n    if (!this.unstable) {\n      throw new Error(\"Unstable value must be supplied\");\n    }\n  }\n  get name() {\n    return this.unstable;\n  }\n  get altName() {\n    return this.stable;\n  }\n}\n//# sourceMappingURL=NamespacedValue.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NamespacedMap = void 0;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * A `Map` implementation which accepts a NamespacedValue as a key, and arbitrary value. The\n * namespaced value must be a string type.\n */\nvar NamespacedMap = /*#__PURE__*/function () {\n  // protected to make tests happy for access\n\n  /**\n   * Creates a new map with optional seed data.\n   * @param {Array<[NS, V]>} initial The seed data.\n   */\n  function NamespacedMap(initial) {\n    _classCallCheck(this, NamespacedMap);\n\n    _defineProperty(this, \"internalMap\", new Map());\n\n    if (initial) {\n      var _iterator = _createForOfIteratorHelper(initial),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var val = _step.value;\n          this.set(val[0], val[1]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Gets a value from the map. If the value does not exist under\n   * either namespace option, falsy is returned.\n   * @param {NS} key The key.\n   * @returns {Optional<V>} The value, or falsy.\n   */\n\n\n  _createClass(NamespacedMap, [{\n    key: \"get\",\n    value: function get(key) {\n      if (key.name && this.internalMap.has(key.name)) {\n        return this.internalMap.get(key.name);\n      }\n\n      if (key.altName && this.internalMap.has(key.altName)) {\n        return this.internalMap.get(key.altName);\n      }\n\n      return null;\n    }\n    /**\n     * Sets a value in the map.\n     * @param {NS} key The key.\n     * @param {V} val The value.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, val) {\n      if (key.name) {\n        this.internalMap.set(key.name, val);\n      }\n\n      if (key.altName) {\n        this.internalMap.set(key.altName, val);\n      }\n    }\n    /**\n     * Determines if any of the valid namespaced values are present\n     * in the map.\n     * @param {NS} key The key.\n     * @returns {boolean} True if present.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return !!this.get(key);\n    }\n    /**\n     * Removes all the namespaced values from the map.\n     * @param {NS} key The key.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      if (key.name) {\n        this.internalMap[\"delete\"](key.name);\n      }\n\n      if (key.altName) {\n        this.internalMap[\"delete\"](key.altName);\n      }\n    }\n    /**\n     * Determines if the map contains a specific namespaced value\n     * instead of the parent NS type.\n     * @param {string} key The key.\n     * @returns {boolean} True if present.\n     */\n\n  }, {\n    key: \"hasNamespaced\",\n    value: function hasNamespaced(key) {\n      return this.internalMap.has(key);\n    }\n    /**\n     * Gets a specific namespaced value from the map instead of the\n     * parent NS type. Returns falsy if not found.\n     * @param {string} key The key.\n     * @returns {Optional<V>} The value, or falsy.\n     */\n\n  }, {\n    key: \"getNamespaced\",\n    value: function getNamespaced(key) {\n      return this.internalMap.get(key);\n    }\n  }]);\n\n  return NamespacedMap;\n}();\n\nexports.NamespacedMap = NamespacedMap;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidEventError = void 0;\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Thrown when an event is unforgivably unparsable.\n */\nvar InvalidEventError = /*#__PURE__*/function (_Error) {\n  _inherits(InvalidEventError, _Error);\n\n  var _super = _createSuper(InvalidEventError);\n\n  function InvalidEventError(message) {\n    _classCallCheck(this, InvalidEventError);\n\n    return _super.call(this, message);\n  }\n\n  return _createClass(InvalidEventError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.InvalidEventError = InvalidEventError;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtensibleEvent = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents an Extensible Event in Matrix.\n */\nvar ExtensibleEvent = /*#__PURE__*/function () {\n  function ExtensibleEvent(wireFormat) {\n    _classCallCheck(this, ExtensibleEvent);\n\n    this.wireFormat = wireFormat;\n  }\n  /**\n   * Shortcut to wireFormat.content\n   */\n\n\n  _createClass(ExtensibleEvent, [{\n    key: \"wireContent\",\n    get: function get() {\n      return this.wireFormat.content;\n    }\n    /**\n     * Serializes the event into a format which can be used to send the\n     * event to the room.\n     * @returns {IPartialEvent<object>} The serialized event.\n     */\n\n  }]);\n\n  return ExtensibleEvent;\n}();\n\nexports.ExtensibleEvent = ExtensibleEvent;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOptionalAString = isOptionalAString;\nexports.isProvided = isProvided;\n\n/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents an optional type: can either be T or a falsy value.\n */\n\n/**\n * Determines if the given optional string is a defined string.\n * @param {Optional<string>} s The input string.\n * @returns {boolean} True if the input is a defined string.\n */\nfunction isOptionalAString(s) {\n  return isProvided(s) && typeof s === 'string';\n}\n/**\n * Determines if the given optional was provided a value.\n * @param {Optional<T>} s The optional to test.\n * @returns {boolean} True if the value is defined.\n */\n\n\nfunction isProvided(s) {\n  return s !== null && s !== undefined;\n}\n/**\n * Represents either just T1, just T2, or T1 and T2 mixed.\n */","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnstableValue = exports.NamespacedValue = void 0;\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents a simple Matrix namespaced value. This will assume that if a stable prefix\n * is provided that the stable prefix should be used when representing the identifier.\n */\nvar NamespacedValue = /*#__PURE__*/function () {\n  // Stable is optional, but one of the two parameters is required, hence the weird-looking types.\n  // Goal is to have developers explicitly say there is no stable value (if applicable).\n  function NamespacedValue(stable, unstable) {\n    _classCallCheck(this, NamespacedValue);\n\n    this.stable = stable;\n    this.unstable = unstable;\n\n    if (!this.unstable && !this.stable) {\n      throw new Error(\"One of stable or unstable values must be supplied\");\n    }\n  }\n\n  _createClass(NamespacedValue, [{\n    key: \"name\",\n    get: function get() {\n      if (this.stable) {\n        return this.stable;\n      }\n\n      return this.unstable;\n    }\n  }, {\n    key: \"altName\",\n    get: function get() {\n      if (!this.stable) {\n        return null;\n      }\n\n      return this.unstable;\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(val) {\n      return !!this.name && this.name === val || !!this.altName && this.altName === val;\n    } // this desperately wants https://github.com/microsoft/TypeScript/pull/26349 at the top level of the class\n    // so we can instantiate `NamespacedValue<string, _, _>` as a default type for that namespace.\n\n  }, {\n    key: \"findIn\",\n    value: function findIn(obj) {\n      var val;\n\n      if (this.name) {\n        val = obj === null || obj === void 0 ? void 0 : obj[this.name];\n      }\n\n      if (!val && this.altName) {\n        val = obj === null || obj === void 0 ? void 0 : obj[this.altName];\n      }\n\n      return val;\n    }\n  }, {\n    key: \"includedIn\",\n    value: function includedIn(arr) {\n      var included = false;\n\n      if (this.name) {\n        included = arr.includes(this.name);\n      }\n\n      if (!included && this.altName) {\n        included = arr.includes(this.altName);\n      }\n\n      return included;\n    }\n  }]);\n\n  return NamespacedValue;\n}();\n/**\n * Represents a namespaced value which prioritizes the unstable value over the stable\n * value.\n */\n\n\nexports.NamespacedValue = NamespacedValue;\n\nvar UnstableValue = /*#__PURE__*/function (_NamespacedValue) {\n  _inherits(UnstableValue, _NamespacedValue);\n\n  var _super = _createSuper(UnstableValue);\n\n  // Note: Constructor difference is that `unstable` is *required*.\n  function UnstableValue(stable, unstable) {\n    var _this;\n\n    _classCallCheck(this, UnstableValue);\n\n    _this = _super.call(this, stable, unstable);\n\n    if (!_this.unstable) {\n      throw new Error(\"Unstable value must be supplied\");\n    }\n\n    return _this;\n  }\n\n  _createClass(UnstableValue, [{\n    key: \"name\",\n    get: function get() {\n      return this.unstable;\n    }\n  }, {\n    key: \"altName\",\n    get: function get() {\n      return this.stable;\n    }\n  }]);\n\n  return UnstableValue;\n}(NamespacedValue);\n\nexports.UnstableValue = UnstableValue;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollStartEvent = exports.PollAnswerSubevent = void 0;\n\nvar _poll_types = require(\"./poll_types\");\n\nvar _MessageEvent2 = require(\"./MessageEvent\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _NamespacedValue = require(\"../NamespacedValue\");\n\nvar _events = require(\"../utility/events\");\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a poll answer. Note that this is represented as a subtype and is\n * not registered as a parsable event - it is implied for usage exclusively\n * within the PollStartEvent parsing.\n */\nvar PollAnswerSubevent = /*#__PURE__*/function (_MessageEvent) {\n  _inherits(PollAnswerSubevent, _MessageEvent);\n\n  var _super = _createSuper(PollAnswerSubevent);\n\n  /**\n   * The answer ID.\n   */\n  function PollAnswerSubevent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, PollAnswerSubevent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    var id = wireFormat.content.id;\n\n    if (!id || typeof id !== \"string\") {\n      throw new _InvalidEventError.InvalidEventError(\"Answer ID must be a non-empty string\");\n    }\n\n    _this.id = id;\n    return _this;\n  }\n\n  _createClass(PollAnswerSubevent, [{\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        type: \"org.matrix.sdk.poll.answer\",\n        content: _objectSpread({\n          id: this.id\n        }, this.serializeMMessageOnly())\n      };\n    }\n    /**\n     * Creates a new PollAnswerSubevent from ID and text.\n     * @param {string} id The answer ID (unique within the poll).\n     * @param {string} text The text.\n     * @returns {PollAnswerSubevent} The representative answer.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(id, text) {\n      return new PollAnswerSubevent({\n        type: \"org.matrix.sdk.poll.answer\",\n        content: _defineProperty({\n          id: id\n        }, _message_types.M_TEXT.name, text)\n      });\n    }\n  }]);\n\n  return PollAnswerSubevent;\n}(_MessageEvent2.MessageEvent);\n/**\n * Represents a poll start event.\n */\n\n\nexports.PollAnswerSubevent = PollAnswerSubevent;\n\nvar PollStartEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(PollStartEvent, _ExtensibleEvent);\n\n  var _super2 = _createSuper(PollStartEvent);\n\n  /**\n   * The question being asked, as a MessageEvent node.\n   */\n\n  /**\n   * The interpreted kind of poll. Note that this will infer a value that is known to the\n   * SDK rather than verbatim - this means unknown types will be represented as undisclosed\n   * polls.\n   *\n   * To get the raw kind, use rawKind.\n   */\n\n  /**\n   * The true kind as provided by the event sender. Might not be valid.\n   */\n\n  /**\n   * The maximum number of selections a user is allowed to make.\n   */\n\n  /**\n   * The possible answers for the poll.\n   */\n\n  /**\n   * Creates a new PollStartEvent from a pure format. Note that the event is *not*\n   * parsed here: it will be treated as a literal m.poll.start primary typed event.\n   * @param {IPartialEvent<M_POLL_START_EVENT_CONTENT>} wireFormat The event.\n   */\n  function PollStartEvent(wireFormat) {\n    var _this2;\n\n    _classCallCheck(this, PollStartEvent);\n\n    _this2 = _super2.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this2), \"question\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"kind\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"rawKind\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"maxSelections\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"answers\", void 0);\n\n    var poll = _poll_types.M_POLL_START.findIn(_this2.wireContent);\n\n    if (!poll.question) {\n      throw new _InvalidEventError.InvalidEventError(\"A question is required\");\n    }\n\n    _this2.question = new _MessageEvent2.MessageEvent({\n      type: \"org.matrix.sdk.poll.question\",\n      content: poll.question\n    });\n    _this2.rawKind = poll.kind;\n\n    if (_poll_types.M_POLL_KIND_DISCLOSED.matches(_this2.rawKind)) {\n      _this2.kind = _poll_types.M_POLL_KIND_DISCLOSED;\n    } else {\n      _this2.kind = _poll_types.M_POLL_KIND_UNDISCLOSED; // default & assumed value\n    }\n\n    _this2.maxSelections = Number.isFinite(poll.max_selections) && poll.max_selections > 0 ? poll.max_selections : 1;\n\n    if (!Array.isArray(poll.answers)) {\n      throw new _InvalidEventError.InvalidEventError(\"Poll answers must be an array\");\n    }\n\n    var answers = poll.answers.slice(0, 20).map(function (a) {\n      return new PollAnswerSubevent({\n        type: \"org.matrix.sdk.poll.answer\",\n        content: a\n      });\n    });\n\n    if (answers.length <= 0) {\n      throw new _InvalidEventError.InvalidEventError(\"No answers available\");\n    }\n\n    _this2.answers = answers;\n    return _this2;\n  }\n\n  _createClass(PollStartEvent, [{\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _poll_types.M_POLL_START);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var _content2;\n\n      return {\n        type: _poll_types.M_POLL_START.name,\n        content: (_content2 = {}, _defineProperty(_content2, _poll_types.M_POLL_START.name, {\n          question: this.question.serialize().content,\n          kind: this.rawKind,\n          max_selections: this.maxSelections,\n          answers: this.answers.map(function (a) {\n            return a.serialize().content;\n          })\n        }), _defineProperty(_content2, _message_types.M_TEXT.name, \"\".concat(this.question.text, \"\\n\").concat(this.answers.map(function (a, i) {\n          return \"\".concat(i + 1, \". \").concat(a.text);\n        }).join(\"\\n\"))), _content2)\n      };\n    }\n    /**\n     * Creates a new PollStartEvent from question, answers, and metadata.\n     * @param {string} question The question to ask.\n     * @param {string} answers The answers. Should be unique within each other.\n     * @param {KNOWN_POLL_KIND|string} kind The kind of poll.\n     * @param {number} maxSelections The maximum number of selections. Must be 1 or higher.\n     * @returns {PollStartEvent} The representative poll start event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(question, answers, kind) {\n      var _content3;\n\n      var maxSelections = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      return new PollStartEvent({\n        type: _poll_types.M_POLL_START.name,\n        content: (_content3 = {}, _defineProperty(_content3, _message_types.M_TEXT.name, question), _defineProperty(_content3, _poll_types.M_POLL_START.name, {\n          question: _defineProperty({}, _message_types.M_TEXT.name, question),\n          kind: kind instanceof _NamespacedValue.NamespacedValue ? kind.name : kind,\n          max_selections: maxSelections,\n          answers: answers.map(function (a) {\n            return _defineProperty({\n              id: makeId()\n            }, _message_types.M_TEXT.name, a);\n          })\n        }), _content3)\n      });\n    }\n  }]);\n\n  return PollStartEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.PollStartEvent = PollStartEvent;\nvar LETTERS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\nfunction makeId() {\n  return _toConsumableArray(Array(16)).map(function () {\n    return LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));\n  }).join('');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtensibleEvents = void 0;\n\nvar _NamespacedMap = require(\"./NamespacedMap\");\n\nvar _InvalidEventError = require(\"./InvalidEventError\");\n\nvar _MRoomMessage = require(\"./interpreters/legacy/MRoomMessage\");\n\nvar _MMessage = require(\"./interpreters/modern/MMessage\");\n\nvar _message_types = require(\"./events/message_types\");\n\nvar _poll_types = require(\"./events/poll_types\");\n\nvar _MPoll = require(\"./interpreters/modern/MPoll\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Utility class for parsing and identifying event types in a renderable form. An\n * instance of this class can be created to change rendering preference depending\n * on use-case.\n */\nvar ExtensibleEvents = /*#__PURE__*/function () {\n  function ExtensibleEvents() {\n    _classCallCheck(this, ExtensibleEvents);\n\n    _defineProperty(this, \"interpreters\", new _NamespacedMap.NamespacedMap([// Remember to add your unit test when adding to this! (\"known events\" test description)\n    [_MRoomMessage.LEGACY_M_ROOM_MESSAGE, _MRoomMessage.parseMRoomMessage], [_message_types.M_MESSAGE, _MMessage.parseMMessage], [_message_types.M_EMOTE, _MMessage.parseMMessage], [_message_types.M_NOTICE, _MMessage.parseMMessage], [_poll_types.M_POLL_START, _MPoll.parseMPoll], [_poll_types.M_POLL_RESPONSE, _MPoll.parseMPoll], [_poll_types.M_POLL_END, _MPoll.parseMPoll]]));\n\n    _defineProperty(this, \"_unknownInterpretOrder\", [_message_types.M_MESSAGE]);\n  }\n  /**\n   * Gets the default instance for all extensible event parsing.\n   */\n\n\n  _createClass(ExtensibleEvents, [{\n    key: \"unknownInterpretOrder\",\n    get:\n    /**\n     * Gets the order the internal processor will use for unknown primary\n     * event types.\n     */\n    function get() {\n      var _this$_unknownInterpr;\n\n      return (_this$_unknownInterpr = this._unknownInterpretOrder) !== null && _this$_unknownInterpr !== void 0 ? _this$_unknownInterpr : [];\n    }\n    /**\n     * Sets the order the internal processor will use for unknown primary\n     * event types.\n     * @param {NamespacedValue<string, string>[]} val The parsing order.\n     */\n    ,\n    set: function set(val) {\n      this._unknownInterpretOrder = val;\n    }\n    /**\n     * Gets the order the internal processor will use for unknown primary\n     * event types.\n     */\n\n  }, {\n    key: \"registerInterpreter\",\n    value:\n    /**\n     * Registers a primary event type interpreter. Note that the interpreter might be\n     * called with non-primary events if the event is being parsed as a fallback.\n     * @param {NamespacedValue<string, string>} wireEventType The event type.\n     * @param {EventInterpreter} interpreter The interpreter.\n     */\n    function registerInterpreter(wireEventType, interpreter) {\n      this.interpreters.set(wireEventType, interpreter);\n    }\n    /**\n     * Registers a primary event type interpreter. Note that the interpreter might be\n     * called with non-primary events if the event is being parsed as a fallback.\n     * @param {NamespacedValue<string, string>} wireEventType The event type.\n     * @param {EventInterpreter} interpreter The interpreter.\n     */\n\n  }, {\n    key: \"parse\",\n    value:\n    /**\n     * Parses an event, trying the primary event type first. If the primary type is not known\n     * then the content will be inspected to find the most suitable fallback.\n     *\n     * If the parsing failed or was a completely unknown type, this will return falsy.\n     * @param {IPartialEvent<object>} wireFormat The event to parse.\n     * @returns {Optional<ExtensibleEvent>} The parsed extensible event.\n     */\n    function parse(wireFormat) {\n      try {\n        if (this.interpreters.hasNamespaced(wireFormat.type)) {\n          return this.interpreters.getNamespaced(wireFormat.type)(wireFormat);\n        }\n\n        var _iterator = _createForOfIteratorHelper(this.unknownInterpretOrder),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var tryType = _step.value;\n\n            if (this.interpreters.has(tryType)) {\n              var val = this.interpreters.get(tryType)(wireFormat);\n              if (val) return val;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return null; // cannot be parsed\n      } catch (e) {\n        if (e instanceof _InvalidEventError.InvalidEventError) {\n          return null; // fail parsing and move on\n        }\n\n        throw e; // re-throw everything else\n      }\n    }\n    /**\n     * Parses an event, trying the primary event type first. If the primary type is not known\n     * then the content will be inspected to find the most suitable fallback.\n     *\n     * If the parsing failed or was a completely unknown type, this will return falsy.\n     * @param {IPartialEvent<object>} wireFormat The event to parse.\n     * @returns {Optional<ExtensibleEvent>} The parsed extensible event.\n     */\n\n  }], [{\n    key: \"defaultInstance\",\n    get: function get() {\n      return ExtensibleEvents._defaultInstance;\n    }\n  }, {\n    key: \"unknownInterpretOrder\",\n    get: function get() {\n      return ExtensibleEvents.defaultInstance.unknownInterpretOrder;\n    }\n    /**\n     * Sets the order the internal processor will use for unknown primary\n     * event types.\n     * @param {NamespacedValue<string, string>[]} val The parsing order.\n     */\n    ,\n    set: function set(val) {\n      ExtensibleEvents.defaultInstance.unknownInterpretOrder = val;\n    }\n  }, {\n    key: \"registerInterpreter\",\n    value: function registerInterpreter(wireEventType, interpreter) {\n      ExtensibleEvents.defaultInstance.registerInterpreter(wireEventType, interpreter);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(wireFormat) {\n      return ExtensibleEvents.defaultInstance.parse(wireFormat);\n    }\n  }]);\n\n  return ExtensibleEvents;\n}();\n\nexports.ExtensibleEvents = ExtensibleEvents;\n\n_defineProperty(ExtensibleEvents, \"_defaultInstance\", new ExtensibleEvents());","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LegacyMsgType = void 0;\nexports.isEventLike = isEventLike;\n\nvar _message_types = require(\"../events/message_types\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents a legacy m.room.message msgtype\n */\nvar LegacyMsgType;\n/**\n * Determines if the given partial event looks similar enough to the given legacy msgtype\n * to count as that message type.\n * @param {IPartialEvent<EitherAnd<IPartialLegacyContent, M_MESSAGE_EVENT_CONTENT>>} event The event.\n * @param {LegacyMsgType} msgtype The message type to compare for.\n * @returns {boolean} True if the event appears to look similar enough to the msgtype.\n */\n\nexports.LegacyMsgType = LegacyMsgType;\n\n(function (LegacyMsgType) {\n  LegacyMsgType[\"Text\"] = \"m.text\";\n  LegacyMsgType[\"Notice\"] = \"m.notice\";\n  LegacyMsgType[\"Emote\"] = \"m.emote\";\n})(LegacyMsgType || (exports.LegacyMsgType = LegacyMsgType = {}));\n\nfunction isEventLike(event, msgtype) {\n  var content = event.content;\n\n  if (msgtype === LegacyMsgType.Text) {\n    return _message_types.M_MESSAGE.matches(event.type) || event.type === \"m.room.message\" && (content === null || content === void 0 ? void 0 : content['msgtype']) === \"m.text\";\n  } else if (msgtype === LegacyMsgType.Emote) {\n    return _message_types.M_EMOTE.matches(event.type) || event.type === \"m.room.message\" && (content === null || content === void 0 ? void 0 : content['msgtype']) === \"m.emote\";\n  } else if (msgtype === LegacyMsgType.Notice) {\n    return _message_types.M_NOTICE.matches(event.type) || event.type === \"m.room.message\" && (content === null || content === void 0 ? void 0 : content['msgtype']) === \"m.notice\";\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ExtensibleEvents = require(\"./ExtensibleEvents\");\n\nObject.keys(_ExtensibleEvents).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ExtensibleEvents[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _ExtensibleEvents[key];\n    }\n  });\n});\n\nvar _IPartialEvent = require(\"./IPartialEvent\");\n\nObject.keys(_IPartialEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _IPartialEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _IPartialEvent[key];\n    }\n  });\n});\n\nvar _InvalidEventError = require(\"./InvalidEventError\");\n\nObject.keys(_InvalidEventError).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _InvalidEventError[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _InvalidEventError[key];\n    }\n  });\n});\n\nvar _NamespacedValue = require(\"./NamespacedValue\");\n\nObject.keys(_NamespacedValue).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _NamespacedValue[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _NamespacedValue[key];\n    }\n  });\n});\n\nvar _NamespacedMap = require(\"./NamespacedMap\");\n\nObject.keys(_NamespacedMap).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _NamespacedMap[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _NamespacedMap[key];\n    }\n  });\n});\n\nvar _types = require(\"./types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _MessageMatchers = require(\"./utility/MessageMatchers\");\n\nObject.keys(_MessageMatchers).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MessageMatchers[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MessageMatchers[key];\n    }\n  });\n});\n\nvar _events = require(\"./utility/events\");\n\nObject.keys(_events).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _events[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _events[key];\n    }\n  });\n});\n\nvar _MRoomMessage = require(\"./interpreters/legacy/MRoomMessage\");\n\nObject.keys(_MRoomMessage).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MRoomMessage[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MRoomMessage[key];\n    }\n  });\n});\n\nvar _MMessage = require(\"./interpreters/modern/MMessage\");\n\nObject.keys(_MMessage).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MMessage[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MMessage[key];\n    }\n  });\n});\n\nvar _MPoll = require(\"./interpreters/modern/MPoll\");\n\nObject.keys(_MPoll).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MPoll[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MPoll[key];\n    }\n  });\n});\n\nvar _relationship_types = require(\"./events/relationship_types\");\n\nObject.keys(_relationship_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _relationship_types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _relationship_types[key];\n    }\n  });\n});\n\nvar _ExtensibleEvent = require(\"./events/ExtensibleEvent\");\n\nObject.keys(_ExtensibleEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ExtensibleEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _ExtensibleEvent[key];\n    }\n  });\n});\n\nvar _message_types = require(\"./events/message_types\");\n\nObject.keys(_message_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _message_types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _message_types[key];\n    }\n  });\n});\n\nvar _MessageEvent = require(\"./events/MessageEvent\");\n\nObject.keys(_MessageEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MessageEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MessageEvent[key];\n    }\n  });\n});\n\nvar _EmoteEvent = require(\"./events/EmoteEvent\");\n\nObject.keys(_EmoteEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _EmoteEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _EmoteEvent[key];\n    }\n  });\n});\n\nvar _NoticeEvent = require(\"./events/NoticeEvent\");\n\nObject.keys(_NoticeEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _NoticeEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _NoticeEvent[key];\n    }\n  });\n});\n\nvar _poll_types = require(\"./events/poll_types\");\n\nObject.keys(_poll_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _poll_types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _poll_types[key];\n    }\n  });\n});\n\nvar _PollStartEvent = require(\"./events/PollStartEvent\");\n\nObject.keys(_PollStartEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _PollStartEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _PollStartEvent[key];\n    }\n  });\n});\n\nvar _PollResponseEvent = require(\"./events/PollResponseEvent\");\n\nObject.keys(_PollResponseEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _PollResponseEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _PollResponseEvent[key];\n    }\n  });\n});\n\nvar _PollEndEvent = require(\"./events/PollEndEvent\");\n\nObject.keys(_PollEndEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _PollEndEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _PollEndEvent[key];\n    }\n  });\n});","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EventTimeline } from \"./event-timeline.js\";\nimport { logger } from \"../logger.js\";\nimport { RoomEvent } from \"./room.js\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.js\";\nimport { RelationsContainer } from \"./relations-container.js\";\nvar DEBUG = true;\n\n/* istanbul ignore next */\nvar debuglog;\nif (DEBUG) {\n  // using bind means that we get to keep useful line numbers in the console\n  debuglog = logger.log.bind(logger);\n} else {\n  /* istanbul ignore next */\n  debuglog = function debuglog() {};\n}\nexport var DuplicateStrategy = /*#__PURE__*/function (DuplicateStrategy) {\n  DuplicateStrategy[\"Ignore\"] = \"ignore\";\n  DuplicateStrategy[\"Replace\"] = \"replace\";\n  return DuplicateStrategy;\n}({});\nexport class EventTimelineSet extends TypedEventEmitter {\n  /**\n   * Construct a set of EventTimeline objects, typically on behalf of a given\n   * room.  A room may have multiple EventTimelineSets for different levels\n   * of filtering.  The global notification list is also an EventTimelineSet, but\n   * lacks a room.\n   *\n   * <p>This is an ordered sequence of timelines, which may or may not\n   * be continuous. Each timeline lists a series of events, as well as tracking\n   * the room state at the start and the end of the timeline (if appropriate).\n   * It also tracks forward and backward pagination tokens, as well as containing\n   * links to the next timeline in the sequence.\n   *\n   * <p>There is one special timeline - the 'live' timeline, which represents the\n   * timeline to which events are being added in real-time as they are received\n   * from the /sync API. Note that you should not retain references to this\n   * timeline - even if it is the current timeline right now, it may not remain\n   * so if the server gives us a timeline gap in /sync.\n   *\n   * <p>In order that we can find events from their ids later, we also maintain a\n   * map from event_id to timeline and index.\n   *\n   * @param room - Room for this timelineSet. May be null for non-room cases, such as the\n   * notification timeline.\n   * @param opts - Options inherited from Room.\n   * @param client - the Matrix client which owns this EventTimelineSet,\n   * can be omitted if room is specified.\n   * @param thread - the thread to which this timeline set relates.\n   * @param threadListType - the type of thread list represented, if any\n   * (e.g., All threads or My threads)\n   */\n  constructor(room) {\n    var _this$room$relations, _this$room, _room$client;\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var client = arguments.length > 2 ? arguments[2] : undefined;\n    var thread = arguments.length > 3 ? arguments[3] : undefined;\n    var threadListType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    super();\n    this.room = room;\n    this.thread = thread;\n    this.threadListType = threadListType;\n    _defineProperty(this, \"relations\", void 0);\n    _defineProperty(this, \"timelineSupport\", void 0);\n    _defineProperty(this, \"displayPendingEvents\", void 0);\n    _defineProperty(this, \"liveTimeline\", void 0);\n    _defineProperty(this, \"timelines\", void 0);\n    _defineProperty(this, \"_eventIdToTimeline\", new Map());\n    _defineProperty(this, \"filter\", void 0);\n    this.timelineSupport = Boolean(opts.timelineSupport);\n    this.liveTimeline = new EventTimeline(this);\n    this.displayPendingEvents = opts.pendingEvents !== false;\n\n    // just a list - *not* ordered.\n    this.timelines = [this.liveTimeline];\n    this._eventIdToTimeline = new Map();\n    this.filter = opts.filter;\n    this.relations = (_this$room$relations = (_this$room = this.room) === null || _this$room === void 0 ? void 0 : _this$room.relations) !== null && _this$room$relations !== void 0 ? _this$room$relations : new RelationsContainer((_room$client = room === null || room === void 0 ? void 0 : room.client) !== null && _room$client !== void 0 ? _room$client : client);\n  }\n\n  /**\n   * Get all the timelines in this set\n   * @returns the timelines in this set\n   */\n  getTimelines() {\n    return this.timelines;\n  }\n\n  /**\n   * Get the filter object this timeline set is filtered on, if any\n   * @returns the optional filter for this timelineSet\n   */\n  getFilter() {\n    return this.filter;\n  }\n\n  /**\n   * Set the filter object this timeline set is filtered on\n   * (passed to the server when paginating via /messages).\n   * @param filter - the filter for this timelineSet\n   */\n  setFilter(filter) {\n    this.filter = filter;\n  }\n\n  /**\n   * Get the list of pending sent events for this timelineSet's room, filtered\n   * by the timelineSet's filter if appropriate.\n   *\n   * @returns A list of the sent events\n   * waiting for remote echo.\n   *\n   * @throws If `opts.pendingEventOrdering` was not 'detached'\n   */\n  getPendingEvents() {\n    if (!this.room || !this.displayPendingEvents) {\n      return [];\n    }\n    return this.room.getPendingEvents();\n  }\n  /**\n   * Get the live timeline for this room.\n   *\n   * @returns live timeline\n   */\n  getLiveTimeline() {\n    return this.liveTimeline;\n  }\n\n  /**\n   * Set the live timeline for this room.\n   *\n   * @returns live timeline\n   */\n  setLiveTimeline(timeline) {\n    this.liveTimeline = timeline;\n  }\n\n  /**\n   * Return the timeline (if any) this event is in.\n   * @param eventId - the eventId being sought\n   * @returns timeline\n   */\n  eventIdToTimeline(eventId) {\n    return this._eventIdToTimeline.get(eventId);\n  }\n\n  /**\n   * Track a new event as if it were in the same timeline as an old event,\n   * replacing it.\n   * @param oldEventId -  event ID of the original event\n   * @param newEventId -  event ID of the replacement event\n   */\n  replaceEventId(oldEventId, newEventId) {\n    var existingTimeline = this._eventIdToTimeline.get(oldEventId);\n    if (existingTimeline) {\n      this._eventIdToTimeline.delete(oldEventId);\n      this._eventIdToTimeline.set(newEventId, existingTimeline);\n    }\n  }\n\n  /**\n   * Reset the live timeline, and start a new one.\n   *\n   * <p>This is used when /sync returns a 'limited' timeline.\n   *\n   * @param backPaginationToken -   token for back-paginating the new timeline\n   * @param forwardPaginationToken - token for forward-paginating the old live timeline,\n   * if absent or null, all timelines are reset.\n   *\n   * @remarks\n   * Fires {@link RoomEvent.TimelineReset}\n   */\n  resetLiveTimeline(backPaginationToken, forwardPaginationToken) {\n    // Each EventTimeline has RoomState objects tracking the state at the start\n    // and end of that timeline. The copies at the end of the live timeline are\n    // special because they will have listeners attached to monitor changes to\n    // the current room state, so we move this RoomState from the end of the\n    // current live timeline to the end of the new one and, if necessary,\n    // replace it with a newly created one. We also make a copy for the start\n    // of the new timeline.\n\n    // if timeline support is disabled, forget about the old timelines\n    var resetAllTimelines = !this.timelineSupport || !forwardPaginationToken;\n    var oldTimeline = this.liveTimeline;\n    var newTimeline = resetAllTimelines ? oldTimeline.forkLive(EventTimeline.FORWARDS) : oldTimeline.fork(EventTimeline.FORWARDS);\n    if (resetAllTimelines) {\n      this.timelines = [newTimeline];\n      this._eventIdToTimeline = new Map();\n    } else {\n      this.timelines.push(newTimeline);\n    }\n    if (forwardPaginationToken) {\n      // Now set the forward pagination token on the old live timeline\n      // so it can be forward-paginated.\n      oldTimeline.setPaginationToken(forwardPaginationToken, EventTimeline.FORWARDS);\n    }\n\n    // make sure we set the pagination token before firing timelineReset,\n    // otherwise clients which start back-paginating will fail, and then get\n    // stuck without realising that they *can* back-paginate.\n    newTimeline.setPaginationToken(backPaginationToken !== null && backPaginationToken !== void 0 ? backPaginationToken : null, EventTimeline.BACKWARDS);\n\n    // Now we can swap the live timeline to the new one.\n    this.liveTimeline = newTimeline;\n    this.emit(RoomEvent.TimelineReset, this.room, this, resetAllTimelines);\n  }\n\n  /**\n   * Get the timeline which contains the given event, if any\n   *\n   * @param eventId -  event ID to look for\n   * @returns timeline containing\n   * the given event, or null if unknown\n   */\n  getTimelineForEvent(eventId) {\n    if (eventId === null || eventId === undefined) {\n      return null;\n    }\n    var res = this._eventIdToTimeline.get(eventId);\n    return res === undefined ? null : res;\n  }\n\n  /**\n   * Get an event which is stored in our timelines\n   *\n   * @param eventId -  event ID to look for\n   * @returns the given event, or undefined if unknown\n   */\n  findEventById(eventId) {\n    var tl = this.getTimelineForEvent(eventId);\n    if (!tl) {\n      return undefined;\n    }\n    return tl.getEvents().find(function (ev) {\n      return ev.getId() == eventId;\n    });\n  }\n\n  /**\n   * Add a new timeline to this timeline list\n   *\n   * @returns newly-created timeline\n   */\n  addTimeline() {\n    if (!this.timelineSupport) {\n      throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" + \" parameter to true when creating MatrixClient to enable\" + \" it.\");\n    }\n    var timeline = new EventTimeline(this);\n    this.timelines.push(timeline);\n    return timeline;\n  }\n\n  /**\n   * Add events to a timeline\n   *\n   * <p>Will fire \"Room.timeline\" for each event added.\n   *\n   * @param events - A list of events to add.\n   *\n   * @param toStartOfTimeline -   True to add these events to the start\n   * (oldest) instead of the end (newest) of the timeline. If true, the oldest\n   * event will be the <b>last</b> element of 'events'.\n   *\n   * @param timeline -   timeline to\n   *    add events to.\n   *\n   * @param paginationToken -   token for the next batch of events\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   *\n   */\n  addEventsToTimeline(events, toStartOfTimeline, timeline, paginationToken) {\n    if (!timeline) {\n      throw new Error(\"'timeline' not specified for EventTimelineSet.addEventsToTimeline\");\n    }\n    if (!toStartOfTimeline && timeline == this.liveTimeline) {\n      throw new Error(\"EventTimelineSet.addEventsToTimeline cannot be used for adding events to \" + \"the live timeline - use Room.addLiveEvents instead\");\n    }\n    if (this.filter) {\n      events = this.filter.filterRoomTimeline(events);\n      if (!events.length) {\n        return;\n      }\n    }\n    var direction = toStartOfTimeline ? EventTimeline.BACKWARDS : EventTimeline.FORWARDS;\n    var inverseDirection = toStartOfTimeline ? EventTimeline.FORWARDS : EventTimeline.BACKWARDS;\n\n    // Adding events to timelines can be quite complicated. The following\n    // illustrates some of the corner-cases.\n    //\n    // Let's say we start by knowing about four timelines. timeline3 and\n    // timeline4 are neighbours:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M]          [P]          [S] <------> [T]\n    //\n    // Now we paginate timeline1, and get the following events from the server:\n    // [M, N, P, R, S, T, U].\n    //\n    // 1. First, we ignore event M, since we already know about it.\n    //\n    // 2. Next, we append N to timeline 1.\n    //\n    // 3. Next, we don't add event P, since we already know about it,\n    //    but we do link together the timelines. We now have:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P]          [S] <------> [T]\n    //\n    // 4. Now we add event R to timeline2:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P, R]       [S] <------> [T]\n    //\n    //    Note that we have switched the timeline we are working on from\n    //    timeline1 to timeline2.\n    //\n    // 5. We ignore event S, but again join the timelines:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P, R] <---> [S] <------> [T]\n    //\n    // 6. We ignore event T, and the timelines are already joined, so there\n    //    is nothing to do.\n    //\n    // 7. Finally, we add event U to timeline4:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P, R] <---> [S] <------> [T, U]\n    //\n    // The important thing to note in the above is what happened when we\n    // already knew about a given event:\n    //\n    //   - if it was appropriate, we joined up the timelines (steps 3, 5).\n    //   - in any case, we started adding further events to the timeline which\n    //       contained the event we knew about (steps 3, 5, 6).\n    //\n    //\n    // So much for adding events to the timeline. But what do we want to do\n    // with the pagination token?\n    //\n    // In the case above, we will be given a pagination token which tells us how to\n    // get events beyond 'U' - in this case, it makes sense to store this\n    // against timeline4. But what if timeline4 already had 'U' and beyond? in\n    // that case, our best bet is to throw away the pagination token we were\n    // given and stick with whatever token timeline4 had previously. In short,\n    // we want to only store the pagination token if the last event we receive\n    // is one we didn't previously know about.\n    //\n    // We make an exception for this if it turns out that we already knew about\n    // *all* of the events, and we weren't able to join up any timelines. When\n    // that happens, it means our existing pagination token is faulty, since it\n    // is only telling us what we already know. Rather than repeatedly\n    // paginating with the same token, we might as well use the new pagination\n    // token in the hope that we eventually work our way out of the mess.\n\n    var didUpdate = false;\n    var lastEventWasNew = false;\n    for (var _event of events) {\n      var eventId = _event.getId();\n      var existingTimeline = this._eventIdToTimeline.get(eventId);\n      if (!existingTimeline) {\n        // we don't know about this event yet. Just add it to the timeline.\n        this.addEventToTimeline(_event, timeline, {\n          toStartOfTimeline\n        });\n        lastEventWasNew = true;\n        didUpdate = true;\n        continue;\n      }\n      lastEventWasNew = false;\n      if (existingTimeline == timeline) {\n        debuglog(\"Event \" + eventId + \" already in timeline \" + timeline);\n        continue;\n      }\n      var neighbour = timeline.getNeighbouringTimeline(direction);\n      if (neighbour) {\n        // this timeline already has a neighbour in the relevant direction;\n        // let's assume the timelines are already correctly linked up, and\n        // skip over to it.\n        //\n        // there's probably some edge-case here where we end up with an\n        // event which is in a timeline a way down the chain, and there is\n        // a break in the chain somewhere. But I can't really imagine how\n        // that would happen, so I'm going to ignore it for now.\n        //\n        if (existingTimeline == neighbour) {\n          debuglog(\"Event \" + eventId + \" in neighbouring timeline - \" + \"switching to \" + existingTimeline);\n        } else {\n          debuglog(\"Event \" + eventId + \" already in a different \" + \"timeline \" + existingTimeline);\n        }\n        timeline = existingTimeline;\n        continue;\n      }\n\n      // time to join the timelines.\n      logger.info(\"Already have timeline for \" + eventId + \" - joining timeline \" + timeline + \" to \" + existingTimeline);\n\n      // Variables to keep the line length limited below.\n      var existingIsLive = existingTimeline === this.liveTimeline;\n      var timelineIsLive = timeline === this.liveTimeline;\n      var backwardsIsLive = direction === EventTimeline.BACKWARDS && existingIsLive;\n      var forwardsIsLive = direction === EventTimeline.FORWARDS && timelineIsLive;\n      if (backwardsIsLive || forwardsIsLive) {\n        // The live timeline should never be spliced into a non-live position.\n        // We use independent logging to better discover the problem at a glance.\n        if (backwardsIsLive) {\n          logger.warn(\"Refusing to set a preceding existingTimeLine on our \" + \"timeline as the existingTimeLine is live (\" + existingTimeline + \")\");\n        }\n        if (forwardsIsLive) {\n          logger.warn(\"Refusing to set our preceding timeline on a existingTimeLine \" + \"as our timeline is live (\" + timeline + \")\");\n        }\n        continue; // abort splicing - try next event\n      }\n      timeline.setNeighbouringTimeline(existingTimeline, direction);\n      existingTimeline.setNeighbouringTimeline(timeline, inverseDirection);\n      timeline = existingTimeline;\n      didUpdate = true;\n    }\n\n    // see above - if the last event was new to us, or if we didn't find any\n    // new information, we update the pagination token for whatever\n    // timeline we ended up on.\n    if (lastEventWasNew || !didUpdate) {\n      if (direction === EventTimeline.FORWARDS && timeline === this.liveTimeline) {\n        logger.warn({\n          lastEventWasNew,\n          didUpdate\n        }); // for debugging\n        logger.warn(\"Refusing to set forwards pagination token of live timeline \" + \"\".concat(timeline, \" to \").concat(paginationToken));\n        return;\n      }\n      timeline.setPaginationToken(paginationToken !== null && paginationToken !== void 0 ? paginationToken : null, direction);\n    }\n  }\n\n  /**\n   * Add an event to the end of this live timeline.\n   *\n   * @param event - Event to be added\n   * @param options - addLiveEvent options\n   */\n  addLiveEvent(event) {\n    var {\n      duplicateStrategy,\n      fromCache,\n      roomState,\n      timelineWasEmpty\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.filter) {\n      var events = this.filter.filterRoomTimeline([event]);\n      if (!events.length) {\n        return;\n      }\n    }\n    var timeline = this._eventIdToTimeline.get(event.getId());\n    if (timeline) {\n      if (duplicateStrategy === DuplicateStrategy.Replace) {\n        debuglog(\"EventTimelineSet.addLiveEvent: replacing duplicate event \" + event.getId());\n        var tlEvents = timeline.getEvents();\n        for (var j = 0; j < tlEvents.length; j++) {\n          if (tlEvents[j].getId() === event.getId()) {\n            // still need to set the right metadata on this event\n            if (!roomState) {\n              roomState = timeline.getState(EventTimeline.FORWARDS);\n            }\n            EventTimeline.setEventMetadata(event, roomState, false);\n            tlEvents[j] = event;\n\n            // XXX: we need to fire an event when this happens.\n            break;\n          }\n        }\n      } else {\n        debuglog(\"EventTimelineSet.addLiveEvent: ignoring duplicate event \" + event.getId());\n      }\n      return;\n    }\n    this.addEventToTimeline(event, this.liveTimeline, {\n      toStartOfTimeline: false,\n      fromCache,\n      roomState,\n      timelineWasEmpty\n    });\n  }\n\n  /**\n   * Add event to the given timeline, and emit Room.timeline. Assumes\n   * we have already checked we don't know about this event.\n   *\n   * Will fire \"Room.timeline\" for each event added.\n   *\n   * @param event - the event to add\n   * @param timeline - the timeline onto which to add it\n   * @param options - addEventToTimeline options\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   */\n\n  /**\n   * @deprecated In favor of the overload with `IAddEventToTimelineOptions`\n   */\n\n  addEventToTimeline(event, timeline, toStartOfTimelineOrOpts) {\n    var fromCache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var roomState = arguments.length > 4 ? arguments[4] : undefined;\n    var toStartOfTimeline = !!toStartOfTimelineOrOpts;\n    var timelineWasEmpty;\n    if (typeof toStartOfTimelineOrOpts === \"object\") {\n      ({\n        toStartOfTimeline,\n        fromCache = false,\n        roomState,\n        timelineWasEmpty\n      } = toStartOfTimelineOrOpts);\n    } else if (toStartOfTimelineOrOpts !== undefined) {\n      // Deprecation warning\n      // FIXME: Remove after 2023-06-01 (technical debt)\n      logger.warn(\"Overload deprecated: \" + \"`EventTimelineSet.addEventToTimeline(event, timeline, toStartOfTimeline, fromCache?, roomState?)` \" + \"is deprecated in favor of the overload with \" + \"`EventTimelineSet.addEventToTimeline(event, timeline, IAddEventToTimelineOptions)`\");\n    }\n    if (timeline.getTimelineSet() !== this) {\n      var _this$thread;\n      throw new Error(\"EventTimelineSet.addEventToTimeline: Timeline=\".concat(timeline.toString(), \" does not belong \\\" +\\n                \\\"in timelineSet(threadId=\").concat((_this$thread = this.thread) === null || _this$thread === void 0 ? void 0 : _this$thread.id, \")\"));\n    }\n    var eventId = event.getId();\n    this.relations.aggregateParentEvent(event);\n    this.relations.aggregateChildEvent(event, this);\n\n    // Make sure events don't get mixed in timelines they shouldn't be in (e.g. a\n    // threaded message should not be in the main timeline).\n    //\n    // We can only run this check for timelines with a `room` because `canContain`\n    // requires it\n    if (this.room && !this.canContain(event)) {\n      var _this$thread2;\n      var eventDebugString = \"event=\".concat(eventId);\n      if (event.threadRootId) {\n        eventDebugString += \"(belongs to thread=\".concat(event.threadRootId, \")\");\n      }\n      logger.warn(\"EventTimelineSet.addEventToTimeline: Ignoring \".concat(eventDebugString, \" that does not belong \") + \"in timeline=\".concat(timeline.toString(), \" timelineSet(threadId=\").concat((_this$thread2 = this.thread) === null || _this$thread2 === void 0 ? void 0 : _this$thread2.id, \")\"));\n      return;\n    }\n    timeline.addEvent(event, {\n      toStartOfTimeline,\n      roomState,\n      timelineWasEmpty\n    });\n    this._eventIdToTimeline.set(eventId, timeline);\n    var data = {\n      timeline: timeline,\n      liveEvent: !toStartOfTimeline && timeline == this.liveTimeline && !fromCache\n    };\n    this.emit(RoomEvent.Timeline, event, this.room, Boolean(toStartOfTimeline), false, data);\n  }\n\n  /**\n   * Insert event to the given timeline, and emit Room.timeline. Assumes\n   * we have already checked we don't know about this event.\n   *\n   * TEMPORARY: until we have recursive relations, we need this function\n   * to exist to allow us to insert events in timeline order, which is our\n   * best guess for Sync Order.\n   * This is a copy of addEventToTimeline above, modified to insert the event\n   * after the event it relates to, and before any event with a later\n   * timestamp. This is our best guess at Sync Order.\n   *\n   * Will fire \"Room.timeline\" for each event added.\n   *\n   * @internal\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   */\n  insertEventIntoTimeline(event, timeline, roomState) {\n    if (timeline.getTimelineSet() !== this) {\n      var _this$thread3;\n      throw new Error(\"EventTimelineSet.insertEventIntoTimeline: Timeline=\".concat(timeline.toString(), \" does not belong \\\" +\\n                \\\"in timelineSet(threadId=\").concat((_this$thread3 = this.thread) === null || _this$thread3 === void 0 ? void 0 : _this$thread3.id, \")\"));\n    }\n    var eventId = event.getId();\n    this.relations.aggregateParentEvent(event);\n    this.relations.aggregateChildEvent(event, this);\n\n    // Make sure events don't get mixed in timelines they shouldn't be in (e.g. a\n    // threaded message should not be in the main timeline).\n    //\n    // We can only run this check for timelines with a `room` because `canContain`\n    // requires it\n    if (this.room && !this.canContain(event)) {\n      var _this$thread4;\n      var eventDebugString = \"event=\".concat(eventId);\n      if (event.threadRootId) {\n        eventDebugString += \"(belongs to thread=\".concat(event.threadRootId, \")\");\n      }\n      logger.warn(\"EventTimelineSet.insertEventIntoTimeline: Ignoring \".concat(eventDebugString, \" that does not belong \") + \"in timeline=\".concat(timeline.toString(), \" timelineSet(threadId=\").concat((_this$thread4 = this.thread) === null || _this$thread4 === void 0 ? void 0 : _this$thread4.id, \")\"));\n      return;\n    }\n\n    // Find the event that this event is related to - the \"parent\"\n    var parentEventId = event.relationEventId;\n    if (!parentEventId) {\n      // Not related to anything - we just append\n      this.addEventToTimeline(event, timeline, {\n        toStartOfTimeline: false,\n        fromCache: false,\n        timelineWasEmpty: false,\n        roomState\n      });\n      return;\n    }\n    var parentEvent = this.findEventById(parentEventId);\n    var timelineEvents = timeline.getEvents();\n\n    // Start searching from the parent event, or if it's not loaded, start\n    // at the beginning and insert purely using timestamp order.\n    var parentIndex = parentEvent !== undefined ? timelineEvents.indexOf(parentEvent) : 0;\n    var insertIndex = parentIndex;\n    for (; insertIndex < timelineEvents.length; insertIndex++) {\n      var nextEvent = timelineEvents[insertIndex];\n      if (nextEvent.getTs() > event.getTs()) {\n        // We found an event later than ours, so insert before that.\n        break;\n      }\n    }\n    // If we got to the end of the loop, insertIndex points at the end of\n    // the list.\n\n    timeline.insertEvent(event, insertIndex, roomState);\n    this._eventIdToTimeline.set(eventId, timeline);\n    var data = {\n      timeline: timeline,\n      // The purpose of this method is inserting events in the middle of the\n      // timeline, so the events are, by definition, not live (whether or not\n      // we're adding them to the live timeline).\n      liveEvent: false\n    };\n    this.emit(RoomEvent.Timeline, event, this.room, false, false, data);\n  }\n\n  /**\n   * Replaces event with ID oldEventId with one with newEventId, if oldEventId is\n   * recognised.  Otherwise, add to the live timeline.  Used to handle remote echos.\n   *\n   * @param localEvent -     the new event to be added to the timeline\n   * @param oldEventId -          the ID of the original event\n   * @param newEventId -         the ID of the replacement event\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   */\n  handleRemoteEcho(localEvent, oldEventId, newEventId) {\n    // XXX: why don't we infer newEventId from localEvent?\n    var existingTimeline = this._eventIdToTimeline.get(oldEventId);\n    if (existingTimeline) {\n      this._eventIdToTimeline.delete(oldEventId);\n      this._eventIdToTimeline.set(newEventId, existingTimeline);\n    } else if (!this.filter || this.filter.filterRoomTimeline([localEvent]).length) {\n      this.addEventToTimeline(localEvent, this.liveTimeline, {\n        toStartOfTimeline: false\n      });\n    }\n  }\n\n  /**\n   * Removes a single event from this room.\n   *\n   * @param eventId -  The id of the event to remove\n   *\n   * @returns the removed event, or null if the event was not found\n   * in this room.\n   */\n  removeEvent(eventId) {\n    var timeline = this._eventIdToTimeline.get(eventId);\n    if (!timeline) {\n      return null;\n    }\n    var removed = timeline.removeEvent(eventId);\n    if (removed) {\n      this._eventIdToTimeline.delete(eventId);\n      var data = {\n        timeline: timeline\n      };\n      this.emit(RoomEvent.Timeline, removed, this.room, undefined, true, data);\n    }\n    return removed;\n  }\n\n  /**\n   * Determine where two events appear in the timeline relative to one another\n   *\n   * @param eventId1 -   The id of the first event\n   * @param eventId2 -   The id of the second event\n    * @returns -1 if eventId1 precedes eventId2, and +1 eventId1 succeeds\n   * eventId2. 0 if they are the same event; null if we can't tell (either\n   * because we don't know about one of the events, or because they are in\n   * separate timelines which don't join up).\n   */\n  compareEventOrdering(eventId1, eventId2) {\n    if (eventId1 == eventId2) {\n      // optimise this case\n      return 0;\n    }\n    var timeline1 = this._eventIdToTimeline.get(eventId1);\n    var timeline2 = this._eventIdToTimeline.get(eventId2);\n    if (timeline1 === undefined) {\n      return null;\n    }\n    if (timeline2 === undefined) {\n      return null;\n    }\n    if (timeline1 === timeline2) {\n      // both events are in the same timeline - figure out their relative indices\n      var idx1 = undefined;\n      var idx2 = undefined;\n      var events = timeline1.getEvents();\n      for (var idx = 0; idx < events.length && (idx1 === undefined || idx2 === undefined); idx++) {\n        var evId = events[idx].getId();\n        if (evId == eventId1) {\n          idx1 = idx;\n        }\n        if (evId == eventId2) {\n          idx2 = idx;\n        }\n      }\n      var difference = idx1 - idx2;\n\n      // Return the sign of difference.\n      if (difference < 0) {\n        return -1;\n      } else if (difference > 0) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    // the events are in different timelines. Iterate through the\n    // linkedlist to see which comes first.\n\n    // first work forwards from timeline1\n    var tl = timeline1;\n    while (tl) {\n      if (tl === timeline2) {\n        // timeline1 is before timeline2\n        return -1;\n      }\n      tl = tl.getNeighbouringTimeline(EventTimeline.FORWARDS);\n    }\n\n    // now try backwards from timeline1\n    tl = timeline1;\n    while (tl) {\n      if (tl === timeline2) {\n        // timeline2 is before timeline1\n        return 1;\n      }\n      tl = tl.getNeighbouringTimeline(EventTimeline.BACKWARDS);\n    }\n\n    // the timelines are not contiguous.\n    return null;\n  }\n\n  /**\n   * Determine whether a given event can sanely be added to this event timeline set,\n   * for timeline sets relating to a thread, only return true for events in the same\n   * thread timeline, for timeline sets not relating to a thread only return true\n   * for events which should be shown in the main room timeline.\n   * Requires the `room` property to have been set at EventTimelineSet construction time.\n   *\n   * @param event - the event to check whether it belongs to this timeline set.\n   * @throws Error if `room` was not set when constructing this timeline set.\n   * @returns whether the event belongs to this timeline set.\n   */\n  canContain(event) {\n    if (!this.room) {\n      throw new Error(\"Cannot call `EventTimelineSet::canContain without a `room` set. \" + \"Set the room when creating the EventTimelineSet to call this method.\");\n    }\n    var {\n      threadId,\n      shouldLiveInRoom,\n      shouldLiveInThread\n    } = this.room.eventShouldLiveIn(event);\n    if (this.thread) {\n      return this.thread.id === threadId;\n    }\n    if (!shouldLiveInRoom && !shouldLiveInThread) {\n      var _this$room2;\n      logger.warn(\"EventTimelineSet:canContain event encountered which cannot be added to any timeline roomId=\".concat((_this$room2 = this.room) === null || _this$room2 === void 0 ? void 0 : _this$room2.roomId, \" eventId=\").concat(event.getId(), \" threadId=\").concat(event.threadRootId));\n    }\n    return shouldLiveInRoom;\n  }\n}\n//# sourceMappingURL=event-timeline-set.js.map","/*\nCopyright 2015 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Enum for event statuses.\n * @readonly\n */\nexport var EventStatus = /*#__PURE__*/function (EventStatus) {\n  EventStatus[\"NOT_SENT\"] = \"not_sent\";\n  EventStatus[\"ENCRYPTING\"] = \"encrypting\";\n  EventStatus[\"SENDING\"] = \"sending\";\n  EventStatus[\"QUEUED\"] = \"queued\";\n  EventStatus[\"SENT\"] = \"sent\";\n  EventStatus[\"CANCELLED\"] = \"cancelled\";\n  return EventStatus;\n}({});\n//# sourceMappingURL=event-status.js.map","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Construct a new Room Summary. A summary can be used for display on a recent\n * list, without having to load the entire room list into memory.\n * @param roomId - Required. The ID of this room.\n * @param info - Optional. The summary info. Additional keys are supported.\n */\nexport class RoomSummary {\n  constructor(roomId, info) {\n    this.roomId = roomId;\n  }\n}\n//# sourceMappingURL=room-summary.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017 Vector Creations Ltd\nCopyright 2017 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// eslint-disable-next-line no-restricted-imports\n\nexport class ReEmitter {\n  constructor(target) {\n    this.target = target;\n    // Map from emitter to event name to re-emitter\n    _defineProperty(this, \"reEmitters\", new WeakMap());\n  }\n  reEmit(source, eventNames) {\n    var _this = this;\n    var reEmittersByEvent = this.reEmitters.get(source);\n    if (!reEmittersByEvent) {\n      reEmittersByEvent = new Map();\n      this.reEmitters.set(source, reEmittersByEvent);\n    }\n    var _loop = function _loop(eventName) {\n      if (reEmittersByEvent.has(eventName)) return 1; // continue\n\n      // We include the source as the last argument for event handlers which may need it,\n      // such as read receipt listeners on the client class which won't have the context\n      // of the room.\n      var forSource = function forSource() {\n        // EventEmitter special cases 'error' to make the emit function throw if no\n        // handler is attached, which sort of makes sense for making sure that something\n        // handles an error, but for re-emitting, there could be a listener on the original\n        // source object so the test doesn't really work. We *could* try to replicate the\n        // same logic and throw if there is no listener on either the source or the target,\n        // but this behaviour is fairly undesireable for us anyway: the main place we throw\n        // 'error' events is for calls, where error events are usually emitted some time\n        // later by a different part of the code where 'emit' throwing because the app hasn't\n        // added an error handler isn't terribly helpful. (A better fix in retrospect may\n        // have been to just avoid using the event name 'error', but backwards compat...)\n        if (eventName === \"error\" && _this.target.listenerCount(\"error\") === 0) return;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this.target.emit(eventName, ...args, source);\n      };\n      source.on(eventName, forSource);\n      reEmittersByEvent.set(eventName, forSource);\n    };\n    for (var eventName of eventNames) {\n      if (_loop(eventName)) continue;\n    }\n  }\n  stopReEmitting(source, eventNames) {\n    var reEmittersByEvent = this.reEmitters.get(source);\n    if (!reEmittersByEvent) return; // We were never re-emitting these events in the first place\n\n    for (var eventName of eventNames) {\n      source.off(eventName, reEmittersByEvent.get(eventName));\n      reEmittersByEvent.delete(eventName);\n    }\n    if (reEmittersByEvent.size === 0) this.reEmitters.delete(source);\n  }\n}\nexport class TypedReEmitter extends ReEmitter {\n  constructor(target) {\n    super(target);\n  }\n  reEmit(source, eventNames) {\n    super.reEmit(source, eventNames);\n  }\n  stopReEmitting(source, eventNames) {\n    super.stopReEmitting(source, eventNames);\n  }\n}\n//# sourceMappingURL=ReEmitter.js.map","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ServerControlledNamespacedValue } from \"../NamespacedValue.js\";\n\n/**\n * https://github.com/matrix-org/matrix-doc/pull/3773\n *\n * @experimental\n */\nexport var UNREAD_THREAD_NOTIFICATIONS = new ServerControlledNamespacedValue(\"unread_thread_notifications\", \"org.matrix.msc3773.unread_thread_notifications\");\n//# sourceMappingURL=sync.js.map","/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { FILTER_RELATED_BY_REL_TYPES, FILTER_RELATED_BY_SENDERS, THREAD_RELATION_TYPE } from \"./models/thread.js\";\n\n/**\n * Checks if a value matches a given field value, which may be a * terminated\n * wildcard pattern.\n * @param actualValue -  The value to be compared\n * @param filterValue -  The filter pattern to be compared\n * @returns true if the actualValue matches the filterValue\n */\nfunction matchesWildcard(actualValue, filterValue) {\n  if (filterValue.endsWith(\"*\")) {\n    var typePrefix = filterValue.slice(0, -1);\n    return actualValue.slice(0, typePrefix.length) === typePrefix;\n  } else {\n    return actualValue === filterValue;\n  }\n}\n\n/* eslint-disable camelcase */\n\n/* eslint-enable camelcase */\n\n/**\n * FilterComponent is a section of a Filter definition which defines the\n * types, rooms, senders filters etc to be applied to a particular type of resource.\n * This is all ported over from synapse's Filter object.\n *\n * N.B. that synapse refers to these as 'Filters', and what js-sdk refers to as\n * 'Filters' are referred to as 'FilterCollections'.\n */\nexport class FilterComponent {\n  constructor(filterJson, userId) {\n    this.filterJson = filterJson;\n    this.userId = userId;\n  }\n\n  /**\n   * Checks with the filter component matches the given event\n   * @param event - event to be checked against the filter\n   * @returns true if the event matches the filter\n   */\n  check(event) {\n    var _event$getUnsigned, _bundledRelationships;\n    var bundledRelationships = ((_event$getUnsigned = event.getUnsigned()) === null || _event$getUnsigned === void 0 ? void 0 : _event$getUnsigned[\"m.relations\"]) || {};\n    var relations = Object.keys(bundledRelationships);\n    // Relation senders allows in theory a look-up of any senders\n    // however clients can only know about the current user participation status\n    // as sending a whole list of participants could be proven problematic in terms\n    // of performance\n    // This should be improved when bundled relationships solve that problem\n    var relationSenders = [];\n    if (this.userId && bundledRelationships !== null && bundledRelationships !== void 0 && (_bundledRelationships = bundledRelationships[THREAD_RELATION_TYPE.name]) !== null && _bundledRelationships !== void 0 && _bundledRelationships.current_user_participated) {\n      relationSenders.push(this.userId);\n    }\n    return this.checkFields(event.getRoomId(), event.getSender(), event.getType(), event.getContent() ? event.getContent().url !== undefined : false, relations, relationSenders);\n  }\n\n  /**\n   * Converts the filter component into the form expected over the wire\n   */\n  toJSON() {\n    return {\n      types: this.filterJson.types || null,\n      not_types: this.filterJson.not_types || [],\n      rooms: this.filterJson.rooms || null,\n      not_rooms: this.filterJson.not_rooms || [],\n      senders: this.filterJson.senders || null,\n      not_senders: this.filterJson.not_senders || [],\n      contains_url: this.filterJson.contains_url || null,\n      [FILTER_RELATED_BY_SENDERS.name]: this.filterJson[FILTER_RELATED_BY_SENDERS.name] || [],\n      [FILTER_RELATED_BY_REL_TYPES.name]: this.filterJson[FILTER_RELATED_BY_REL_TYPES.name] || []\n    };\n  }\n\n  /**\n   * Checks whether the filter component matches the given event fields.\n   * @param roomId -        the roomId for the event being checked\n   * @param sender -        the sender of the event being checked\n   * @param eventType -     the type of the event being checked\n   * @param containsUrl -  whether the event contains a content.url field\n   * @param relationTypes -  whether has aggregated relation of the given type\n   * @param relationSenders - whether one of the relation is sent by the user listed\n   * @returns true if the event fields match the filter\n   */\n  checkFields(roomId, sender, eventType, containsUrl, relationTypes, relationSenders) {\n    var literalKeys = {\n      rooms: function rooms(v) {\n        return roomId === v;\n      },\n      senders: function senders(v) {\n        return sender === v;\n      },\n      types: function types(v) {\n        return matchesWildcard(eventType, v);\n      }\n    };\n    for (var name in literalKeys) {\n      var matchFunc = literalKeys[name];\n      var notName = \"not_\" + name;\n      var disallowedValues = this.filterJson[notName];\n      if (disallowedValues !== null && disallowedValues !== void 0 && disallowedValues.some(matchFunc)) {\n        return false;\n      }\n      var allowedValues = this.filterJson[name];\n      if (allowedValues && !allowedValues.some(matchFunc)) {\n        return false;\n      }\n    }\n    var containsUrlFilter = this.filterJson.contains_url;\n    if (containsUrlFilter !== undefined && containsUrlFilter !== containsUrl) {\n      return false;\n    }\n    var relationTypesFilter = this.filterJson[FILTER_RELATED_BY_REL_TYPES.name];\n    if (relationTypesFilter !== undefined) {\n      if (!this.arrayMatchesFilter(relationTypesFilter, relationTypes)) {\n        return false;\n      }\n    }\n    var relationSendersFilter = this.filterJson[FILTER_RELATED_BY_SENDERS.name];\n    if (relationSendersFilter !== undefined) {\n      if (!this.arrayMatchesFilter(relationSendersFilter, relationSenders)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  arrayMatchesFilter(filter, values) {\n    return values.length > 0 && filter.every(value => {\n      return values.includes(value);\n    });\n  }\n\n  /**\n   * Filters a list of events down to those which match this filter component\n   * @param events -  Events to be checked against the filter component\n   * @returns events which matched the filter component\n   */\n  filter(events) {\n    return events.filter(this.check, this);\n  }\n\n  /**\n   * Returns the limit field for a given filter component, providing a default of\n   * 10 if none is otherwise specified. Cargo-culted from Synapse.\n   * @returns the limit for this filter component.\n   */\n  limit() {\n    return this.filterJson.limit !== undefined ? this.filterJson.limit : 10;\n  }\n}\n//# sourceMappingURL=filter-component.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2015 - 2021 Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { UNREAD_THREAD_NOTIFICATIONS } from \"./@types/sync.js\";\nimport { FilterComponent } from \"./filter-component.js\";\n/**\n */\nfunction setProp(obj, keyNesting, val) {\n  var nestedKeys = keyNesting.split(\".\");\n  var currentObj = obj;\n  for (var i = 0; i < nestedKeys.length - 1; i++) {\n    if (!currentObj[nestedKeys[i]]) {\n      currentObj[nestedKeys[i]] = {};\n    }\n    currentObj = currentObj[nestedKeys[i]];\n  }\n  currentObj[nestedKeys[nestedKeys.length - 1]] = val;\n}\n\n/* eslint-disable camelcase */\n\n/* eslint-enable camelcase */\n\nexport class Filter {\n  /**\n   * Create a filter from existing data.\n   */\n  static fromJson(userId, filterId, jsonObj) {\n    var filter = new Filter(userId, filterId);\n    filter.setDefinition(jsonObj);\n    return filter;\n  }\n  /**\n   * Construct a new Filter.\n   * @param userId - The user ID for this filter.\n   * @param filterId - The filter ID if known.\n   */\n  constructor(userId, filterId) {\n    this.userId = userId;\n    this.filterId = filterId;\n    _defineProperty(this, \"definition\", {});\n    _defineProperty(this, \"roomFilter\", void 0);\n    _defineProperty(this, \"roomTimelineFilter\", void 0);\n  }\n\n  /**\n   * Get the ID of this filter on your homeserver (if known)\n   * @returns The filter ID\n   */\n  getFilterId() {\n    return this.filterId;\n  }\n\n  /**\n   * Get the JSON body of the filter.\n   * @returns The filter definition\n   */\n  getDefinition() {\n    return this.definition;\n  }\n\n  /**\n   * Set the JSON body of the filter\n   * @param definition - The filter definition\n   */\n  setDefinition(definition) {\n    this.definition = definition;\n\n    // This is all ported from synapse's FilterCollection()\n\n    // definitions look something like:\n    // {\n    //   \"room\": {\n    //     \"rooms\": [\"!abcde:example.com\"],\n    //     \"not_rooms\": [\"!123456:example.com\"],\n    //     \"state\": {\n    //       \"types\": [\"m.room.*\"],\n    //       \"not_rooms\": [\"!726s6s6q:example.com\"],\n    //       \"lazy_load_members\": true,\n    //     },\n    //     \"timeline\": {\n    //       \"limit\": 10,\n    //       \"types\": [\"m.room.message\"],\n    //       \"not_rooms\": [\"!726s6s6q:example.com\"],\n    //       \"not_senders\": [\"@spam:example.com\"]\n    //       \"contains_url\": true\n    //     },\n    //     \"ephemeral\": {\n    //       \"types\": [\"m.receipt\", \"m.typing\"],\n    //       \"not_rooms\": [\"!726s6s6q:example.com\"],\n    //       \"not_senders\": [\"@spam:example.com\"]\n    //     }\n    //   },\n    //   \"presence\": {\n    //     \"types\": [\"m.presence\"],\n    //     \"not_senders\": [\"@alice:example.com\"]\n    //   },\n    //   \"event_format\": \"client\",\n    //   \"event_fields\": [\"type\", \"content\", \"sender\"]\n    // }\n\n    var roomFilterJson = definition.room;\n\n    // consider the top level rooms/not_rooms filter\n    var roomFilterFields = {};\n    if (roomFilterJson) {\n      if (roomFilterJson.rooms) {\n        roomFilterFields.rooms = roomFilterJson.rooms;\n      }\n      if (roomFilterJson.rooms) {\n        roomFilterFields.not_rooms = roomFilterJson.not_rooms;\n      }\n    }\n    this.roomFilter = new FilterComponent(roomFilterFields, this.userId);\n    this.roomTimelineFilter = new FilterComponent((roomFilterJson === null || roomFilterJson === void 0 ? void 0 : roomFilterJson.timeline) || {}, this.userId);\n\n    // don't bother porting this from synapse yet:\n    // this._room_state_filter =\n    //     new FilterComponent(roomFilterJson.state || {});\n    // this._room_ephemeral_filter =\n    //     new FilterComponent(roomFilterJson.ephemeral || {});\n    // this._room_account_data_filter =\n    //     new FilterComponent(roomFilterJson.account_data || {});\n    // this._presence_filter =\n    //     new FilterComponent(definition.presence || {});\n    // this._account_data_filter =\n    //     new FilterComponent(definition.account_data || {});\n  }\n\n  /**\n   * Get the room.timeline filter component of the filter\n   * @returns room timeline filter component\n   */\n  getRoomTimelineFilterComponent() {\n    return this.roomTimelineFilter;\n  }\n\n  /**\n   * Filter the list of events based on whether they are allowed in a timeline\n   * based on this filter\n   * @param events -  the list of events being filtered\n   * @returns the list of events which match the filter\n   */\n  filterRoomTimeline(events) {\n    if (this.roomFilter) {\n      events = this.roomFilter.filter(events);\n    }\n    if (this.roomTimelineFilter) {\n      events = this.roomTimelineFilter.filter(events);\n    }\n    return events;\n  }\n\n  /**\n   * Set the max number of events to return for each room's timeline.\n   * @param limit - The max number of events to return for each room.\n   */\n  setTimelineLimit(limit) {\n    setProp(this.definition, \"room.timeline.limit\", limit);\n  }\n\n  /**\n   * Enable threads unread notification\n   */\n  setUnreadThreadNotifications(enabled) {\n    var _this$definition, _this$definition2;\n    this.definition = _objectSpread(_objectSpread({}, this.definition), {}, {\n      room: _objectSpread(_objectSpread({}, (_this$definition = this.definition) === null || _this$definition === void 0 ? void 0 : _this$definition.room), {}, {\n        timeline: _objectSpread(_objectSpread({}, (_this$definition2 = this.definition) === null || _this$definition2 === void 0 || (_this$definition2 = _this$definition2.room) === null || _this$definition2 === void 0 ? void 0 : _this$definition2.timeline), {}, {\n          [UNREAD_THREAD_NOTIFICATIONS.name]: enabled\n        })\n      })\n    });\n  }\n  setLazyLoadMembers(enabled) {\n    setProp(this.definition, \"room.state.lazy_load_members\", enabled);\n  }\n\n  /**\n   * Control whether left rooms should be included in responses.\n   * @param includeLeave - True to make rooms the user has left appear\n   * in responses.\n   */\n  setIncludeLeaveRooms(includeLeave) {\n    setProp(this.definition, \"room.include_leave\", includeLeave);\n  }\n}\n_defineProperty(Filter, \"LAZY_LOADING_MESSAGES_FILTER\", {\n  lazy_load_members: true\n});\n//# sourceMappingURL=filter.js.map","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { UnstableValue } from \"../NamespacedValue.js\";\n/**\n * Extensible topic event type based on MSC3765\n * https://github.com/matrix-org/matrix-spec-proposals/pull/3765\n *\n * @example\n * ```\n * {\n *      \"type\": \"m.room.topic,\n *      \"state_key\": \"\",\n *      \"content\": {\n *          \"topic\": \"All about **pizza**\",\n *          \"m.topic\": [{\n *              \"body\": \"All about **pizza**\",\n *              \"mimetype\": \"text/plain\",\n *          }, {\n *              \"body\": \"All about <b>pizza</b>\",\n *              \"mimetype\": \"text/html\",\n *          }],\n *      }\n * }\n * ```\n */\n\n/**\n * The event type for an m.topic event (in content)\n */\nexport var M_TOPIC = new UnstableValue(\"m.topic\", \"org.matrix.msc3765.topic\");\n\n/**\n * The event content for an m.topic event (in content)\n */\n\n/**\n * The event definition for an m.topic event (in content)\n */\n\n/**\n * The event content for an m.room.topic event\n */\n//# sourceMappingURL=topic.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2018 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MsgType } from \"./@types/event.js\";\nimport { M_TEXT, REFERENCE_RELATION } from \"./@types/extensible_events.js\";\nimport { isProvided } from \"./extensible_events_v1/utilities.js\";\nimport { M_ASSET, LocationAssetType, M_LOCATION, M_TIMESTAMP } from \"./@types/location.js\";\nimport { M_TOPIC } from \"./@types/topic.js\";\n/**\n * Generates the content for a HTML Message event\n * @param body - the plaintext body of the message\n * @param htmlBody - the HTML representation of the message\n * @returns\n */\nexport function makeHtmlMessage(body, htmlBody) {\n  return {\n    msgtype: MsgType.Text,\n    format: \"org.matrix.custom.html\",\n    body: body,\n    formatted_body: htmlBody\n  };\n}\n\n/**\n * Generates the content for a HTML Notice event\n * @param body - the plaintext body of the notice\n * @param htmlBody - the HTML representation of the notice\n * @returns\n */\nexport function makeHtmlNotice(body, htmlBody) {\n  return {\n    msgtype: MsgType.Notice,\n    format: \"org.matrix.custom.html\",\n    body: body,\n    formatted_body: htmlBody\n  };\n}\n\n/**\n * Generates the content for a HTML Emote event\n * @param body - the plaintext body of the emote\n * @param htmlBody - the HTML representation of the emote\n * @returns\n */\nexport function makeHtmlEmote(body, htmlBody) {\n  return {\n    msgtype: MsgType.Emote,\n    format: \"org.matrix.custom.html\",\n    body: body,\n    formatted_body: htmlBody\n  };\n}\n\n/**\n * Generates the content for a Plaintext Message event\n * @param body - the plaintext body of the emote\n * @returns\n */\nexport function makeTextMessage(body) {\n  return {\n    msgtype: MsgType.Text,\n    body: body\n  };\n}\n\n/**\n * Generates the content for a Plaintext Notice event\n * @param body - the plaintext body of the notice\n * @returns\n */\nexport function makeNotice(body) {\n  return {\n    msgtype: MsgType.Notice,\n    body: body\n  };\n}\n\n/**\n * Generates the content for a Plaintext Emote event\n * @param body - the plaintext body of the emote\n * @returns\n */\nexport function makeEmoteMessage(body) {\n  return {\n    msgtype: MsgType.Emote,\n    body: body\n  };\n}\n\n/** Location content helpers */\n\nexport var getTextForLocationEvent = (uri, assetType, timestamp, description) => {\n  var date = \"at \".concat(new Date(timestamp).toISOString());\n  var assetName = assetType === LocationAssetType.Self ? \"User\" : undefined;\n  var quotedDescription = description ? \"\\\"\".concat(description, \"\\\"\") : undefined;\n  return [assetName, \"Location\", quotedDescription, uri, date].filter(Boolean).join(\" \");\n};\n\n/**\n * Generates the content for a Location event\n * @param uri - a geo:// uri for the location\n * @param timestamp - the timestamp when the location was correct (milliseconds since the UNIX epoch)\n * @param description - the (optional) label for this location on the map\n * @param assetType - the (optional) asset type of this location e.g. \"m.self\"\n * @param text - optional. A text for the location\n */\nexport var makeLocationContent = (text, uri, timestamp, description, assetType) => {\n  var defaultedText = text !== null && text !== void 0 ? text : getTextForLocationEvent(uri, assetType || LocationAssetType.Self, timestamp, description);\n  var timestampEvent = timestamp ? {\n    [M_TIMESTAMP.name]: timestamp\n  } : {};\n  return _objectSpread({\n    msgtype: MsgType.Location,\n    body: defaultedText,\n    geo_uri: uri,\n    [M_LOCATION.name]: {\n      description,\n      uri\n    },\n    [M_ASSET.name]: {\n      type: assetType || LocationAssetType.Self\n    },\n    [M_TEXT.name]: defaultedText\n  }, timestampEvent);\n};\n\n/**\n * Parse location event content and transform to\n * a backwards compatible modern m.location event format\n */\nexport var parseLocationEvent = wireEventContent => {\n  var _location$uri, _asset$type;\n  var location = M_LOCATION.findIn(wireEventContent);\n  var asset = M_ASSET.findIn(wireEventContent);\n  var timestamp = M_TIMESTAMP.findIn(wireEventContent);\n  var text = M_TEXT.findIn(wireEventContent);\n  var geoUri = (_location$uri = location === null || location === void 0 ? void 0 : location.uri) !== null && _location$uri !== void 0 ? _location$uri : wireEventContent === null || wireEventContent === void 0 ? void 0 : wireEventContent.geo_uri;\n  var description = location === null || location === void 0 ? void 0 : location.description;\n  var assetType = (_asset$type = asset === null || asset === void 0 ? void 0 : asset.type) !== null && _asset$type !== void 0 ? _asset$type : LocationAssetType.Self;\n  var fallbackText = text !== null && text !== void 0 ? text : wireEventContent.body;\n  return makeLocationContent(fallbackText, geoUri, timestamp !== null && timestamp !== void 0 ? timestamp : undefined, description, assetType);\n};\n\n/**\n * Topic event helpers\n */\n\nexport var makeTopicContent = (topic, htmlTopic) => {\n  var renderings = [{\n    body: topic,\n    mimetype: \"text/plain\"\n  }];\n  if (isProvided(htmlTopic)) {\n    renderings.push({\n      body: htmlTopic,\n      mimetype: \"text/html\"\n    });\n  }\n  return {\n    topic,\n    [M_TOPIC.name]: renderings\n  };\n};\nexport var parseTopicContent = content => {\n  var _mtopic$find$body, _mtopic$find, _mtopic$find2;\n  var mtopic = M_TOPIC.findIn(content);\n  if (!Array.isArray(mtopic)) {\n    return {\n      text: content.topic\n    };\n  }\n  var text = (_mtopic$find$body = mtopic === null || mtopic === void 0 || (_mtopic$find = mtopic.find(r => !isProvided(r.mimetype) || r.mimetype === \"text/plain\")) === null || _mtopic$find === void 0 ? void 0 : _mtopic$find.body) !== null && _mtopic$find$body !== void 0 ? _mtopic$find$body : content.topic;\n  var html = mtopic === null || mtopic === void 0 || (_mtopic$find2 = mtopic.find(r => r.mimetype === \"text/html\")) === null || _mtopic$find2 === void 0 ? void 0 : _mtopic$find2.body;\n  return {\n    text,\n    html\n  };\n};\n\n/**\n * Beacon event helpers\n */\n\nexport var makeBeaconInfoContent = (timeout, isLive, description, assetType, timestamp) => ({\n  description,\n  timeout,\n  live: isLive,\n  [M_TIMESTAMP.name]: timestamp || Date.now(),\n  [M_ASSET.name]: {\n    type: assetType !== null && assetType !== void 0 ? assetType : LocationAssetType.Self\n  }\n});\n/**\n * Flatten beacon info event content\n */\nexport var parseBeaconInfoContent = content => {\n  var _M_TIMESTAMP$findIn;\n  var {\n    description,\n    timeout,\n    live\n  } = content;\n  var timestamp = (_M_TIMESTAMP$findIn = M_TIMESTAMP.findIn(content)) !== null && _M_TIMESTAMP$findIn !== void 0 ? _M_TIMESTAMP$findIn : undefined;\n  var asset = M_ASSET.findIn(content);\n  return {\n    description,\n    timeout,\n    live,\n    assetType: asset === null || asset === void 0 ? void 0 : asset.type,\n    timestamp\n  };\n};\nexport var makeBeaconContent = (uri, timestamp, beaconInfoEventId, description) => ({\n  [M_LOCATION.name]: {\n    description,\n    uri\n  },\n  [M_TIMESTAMP.name]: timestamp,\n  \"m.relates_to\": {\n    rel_type: REFERENCE_RELATION.name,\n    event_id: beaconInfoEventId\n  }\n});\nexport var parseBeaconContent = content => {\n  var _M_TIMESTAMP$findIn2;\n  var location = M_LOCATION.findIn(content);\n  var timestamp = (_M_TIMESTAMP$findIn2 = M_TIMESTAMP.findIn(content)) !== null && _M_TIMESTAMP$findIn2 !== void 0 ? _M_TIMESTAMP$findIn2 : undefined;\n  return {\n    description: location === null || location === void 0 ? void 0 : location.description,\n    uri: location === null || location === void 0 ? void 0 : location.uri,\n    timestamp\n  };\n};\n//# sourceMappingURL=content-helpers.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { parseBeaconContent, parseBeaconInfoContent } from \"../content-helpers.js\";\nimport { sortEventsByLatestContentTimestamp } from \"../utils.js\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.js\";\nexport var BeaconEvent = /*#__PURE__*/function (BeaconEvent) {\n  BeaconEvent[\"New\"] = \"Beacon.new\";\n  BeaconEvent[\"Update\"] = \"Beacon.update\";\n  BeaconEvent[\"LivenessChange\"] = \"Beacon.LivenessChange\";\n  BeaconEvent[\"Destroy\"] = \"Beacon.Destroy\";\n  BeaconEvent[\"LocationUpdate\"] = \"Beacon.LocationUpdate\";\n  return BeaconEvent;\n}({});\nexport var isTimestampInDuration = (startTimestamp, durationMs, timestamp) => timestamp >= startTimestamp && startTimestamp + durationMs >= timestamp;\n\n// beacon info events are uniquely identified by\n// `<roomId>_<state_key>`\n\nexport var getBeaconInfoIdentifier = event => \"\".concat(event.getRoomId(), \"_\").concat(event.getStateKey());\n\n// https://github.com/matrix-org/matrix-spec-proposals/pull/3672\nexport class Beacon extends TypedEventEmitter {\n  constructor(rootEvent) {\n    super();\n    this.rootEvent = rootEvent;\n    _defineProperty(this, \"roomId\", void 0);\n    // beaconInfo is assigned by setBeaconInfo in the constructor\n    // ! to make tsc believe it is definitely assigned\n    _defineProperty(this, \"_beaconInfo\", void 0);\n    _defineProperty(this, \"_isLive\", void 0);\n    _defineProperty(this, \"livenessWatchTimeout\", void 0);\n    _defineProperty(this, \"_latestLocationEvent\", void 0);\n    _defineProperty(this, \"clearLatestLocation\", () => {\n      this._latestLocationEvent = undefined;\n      this.emit(BeaconEvent.LocationUpdate, this.latestLocationState);\n    });\n    this.roomId = this.rootEvent.getRoomId();\n    this.setBeaconInfo(this.rootEvent);\n  }\n  get isLive() {\n    return !!this._isLive;\n  }\n  get identifier() {\n    return getBeaconInfoIdentifier(this.rootEvent);\n  }\n  get beaconInfoId() {\n    return this.rootEvent.getId();\n  }\n  get beaconInfoOwner() {\n    return this.rootEvent.getStateKey();\n  }\n  get beaconInfoEventType() {\n    return this.rootEvent.getType();\n  }\n  get beaconInfo() {\n    return this._beaconInfo;\n  }\n  get latestLocationState() {\n    return this._latestLocationEvent && parseBeaconContent(this._latestLocationEvent.getContent());\n  }\n  get latestLocationEvent() {\n    return this._latestLocationEvent;\n  }\n  update(beaconInfoEvent) {\n    if (getBeaconInfoIdentifier(beaconInfoEvent) !== this.identifier) {\n      throw new Error(\"Invalid updating event\");\n    }\n    // don't update beacon with an older event\n    if (beaconInfoEvent.getTs() < this.rootEvent.getTs()) {\n      return;\n    }\n    this.rootEvent = beaconInfoEvent;\n    this.setBeaconInfo(this.rootEvent);\n    this.emit(BeaconEvent.Update, beaconInfoEvent, this);\n    this.clearLatestLocation();\n  }\n  destroy() {\n    if (this.livenessWatchTimeout) {\n      clearTimeout(this.livenessWatchTimeout);\n    }\n    this._isLive = false;\n    this.emit(BeaconEvent.Destroy, this.identifier);\n  }\n\n  /**\n   * Monitor liveness of a beacon\n   * Emits BeaconEvent.LivenessChange when beacon expires\n   */\n  monitorLiveness() {\n    if (this.livenessWatchTimeout) {\n      clearTimeout(this.livenessWatchTimeout);\n    }\n    this.checkLiveness();\n    if (!this.beaconInfo) return;\n    if (this.isLive) {\n      var expiryInMs = this.beaconInfo.timestamp + this.beaconInfo.timeout - Date.now();\n      if (expiryInMs > 1) {\n        this.livenessWatchTimeout = setTimeout(() => {\n          this.monitorLiveness();\n        }, expiryInMs);\n      }\n    } else if (this.beaconInfo.timestamp > Date.now()) {\n      // beacon start timestamp is in the future\n      // check liveness again then\n      this.livenessWatchTimeout = setTimeout(() => {\n        this.monitorLiveness();\n      }, this.beaconInfo.timestamp - Date.now());\n    }\n  }\n\n  /**\n   * Process Beacon locations\n   * Emits BeaconEvent.LocationUpdate\n   */\n  addLocations(beaconLocationEvents) {\n    var _validLocationEvents$;\n    // discard locations for beacons that are not live\n    if (!this.isLive) {\n      return;\n    }\n    var validLocationEvents = beaconLocationEvents.filter(event => {\n      var content = event.getContent();\n      var parsed = parseBeaconContent(content);\n      if (!parsed.uri || !parsed.timestamp) return false; // we won't be able to process these\n      var {\n        timestamp\n      } = parsed;\n      return this._beaconInfo.timestamp &&\n      // only include positions that were taken inside the beacon's live period\n      isTimestampInDuration(this._beaconInfo.timestamp, this._beaconInfo.timeout, timestamp) && (\n      // ignore positions older than our current latest location\n      !this.latestLocationState || timestamp > this.latestLocationState.timestamp);\n    });\n    var latestLocationEvent = (_validLocationEvents$ = validLocationEvents.sort(sortEventsByLatestContentTimestamp)) === null || _validLocationEvents$ === void 0 ? void 0 : _validLocationEvents$[0];\n    if (latestLocationEvent) {\n      this._latestLocationEvent = latestLocationEvent;\n      this.emit(BeaconEvent.LocationUpdate, this.latestLocationState);\n    }\n  }\n  setBeaconInfo(event) {\n    this._beaconInfo = parseBeaconInfoContent(event.getContent());\n    this.checkLiveness();\n  }\n  checkLiveness() {\n    var prevLiveness = this.isLive;\n\n    // element web sets a beacon's start timestamp to the senders local current time\n    // when Alice's system clock deviates slightly from Bob's a beacon Alice intended to be live\n    // may have a start timestamp in the future from Bob's POV\n    // handle this by adding 6min of leniency to the start timestamp when it is in the future\n    if (!this.beaconInfo) return;\n    var startTimestamp = this.beaconInfo.timestamp > Date.now() ? this.beaconInfo.timestamp - 360000 /* 6min */ : this.beaconInfo.timestamp;\n    this._isLive = !!this._beaconInfo.live && !!startTimestamp && isTimestampInDuration(startTimestamp, this._beaconInfo.timeout, Date.now());\n    if (prevLiveness !== this.isLive) {\n      this.emit(BeaconEvent.LivenessChange, this.isLive, this);\n    }\n  }\n}\n//# sourceMappingURL=beacon.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MAIN_ROOM_TIMELINE, ReceiptType } from \"../@types/read_receipts.js\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.js\";\nimport { isSupportedReceiptType } from \"../utils.js\";\nimport { MatrixEvent } from \"./event.js\";\nimport { EventType } from \"../@types/event.js\";\nimport { MapWithDefault } from \"../utils.js\";\nimport { NotificationCountType } from \"./room.js\";\nimport { logger } from \"../logger.js\";\nimport { inMainTimelineForReceipt, threadIdForReceipt } from \"../client.js\";\n\n/**\n * Create a synthetic receipt for the given event\n * @param userId - The user ID if the receipt sender\n * @param event - The event that is to be acknowledged\n * @param receiptType - The type of receipt\n * @param unthreaded - the receipt is unthreaded\n * @returns a new event with the synthetic receipt in it\n */\nexport function synthesizeReceipt(userId, event, receiptType) {\n  var unthreaded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return new MatrixEvent({\n    content: {\n      [event.getId()]: {\n        [receiptType]: {\n          [userId]: _objectSpread({\n            ts: event.getTs()\n          }, !unthreaded && {\n            thread_id: threadIdForReceipt(event)\n          })\n        }\n      }\n    },\n    type: EventType.Receipt,\n    room_id: event.getRoomId()\n  });\n}\nvar ReceiptPairRealIndex = 0;\nvar ReceiptPairSyntheticIndex = 1;\nexport class ReadReceipt extends TypedEventEmitter {\n  constructor() {\n    super(...arguments);\n    // receipts should clobber based on receipt_type and user_id pairs hence\n    // the form of this structure. This is sub-optimal for the exposed APIs\n    // which pass in an event ID and get back some receipts, so we also store\n    // a pre-cached list for this purpose.\n    // Map: receipt type  user Id  receipt\n    _defineProperty(this, \"receipts\", new MapWithDefault(() => new Map()));\n    _defineProperty(this, \"receiptCacheByEventId\", new Map());\n  }\n  /**\n   * Gets the latest receipt for a given user in the room\n   * @param userId - The id of the user for which we want the receipt\n   * @param ignoreSynthesized - Whether to ignore synthesized receipts or not\n   * @param receiptType - Optional. The type of the receipt we want to get\n   * @returns the latest receipts of the chosen type for the chosen user\n   */\n  getReadReceiptForUserId(userId) {\n    var _this$receipts$get$ge, _this$receipts$get;\n    var ignoreSynthesized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var receiptType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ReceiptType.Read;\n    var [realReceipt, syntheticReceipt] = (_this$receipts$get$ge = (_this$receipts$get = this.receipts.get(receiptType)) === null || _this$receipts$get === void 0 ? void 0 : _this$receipts$get.get(userId)) !== null && _this$receipts$get$ge !== void 0 ? _this$receipts$get$ge : [null, null];\n    if (ignoreSynthesized) {\n      return realReceipt;\n    }\n    return syntheticReceipt !== null && syntheticReceipt !== void 0 ? syntheticReceipt : realReceipt;\n  }\n  compareReceipts(a, b) {\n    var _this$getUnfilteredTi;\n    // Try compare them in our unfiltered timeline set order, falling back to receipt timestamp which should be\n    // relatively sane as receipts are set only by the originating homeserver so as long as its clock doesn't\n    // jump around then it should be valid.\n    return (_this$getUnfilteredTi = this.getUnfilteredTimelineSet().compareEventOrdering(a.eventId, b.eventId)) !== null && _this$getUnfilteredTi !== void 0 ? _this$getUnfilteredTi : a.data.ts - b.data.ts;\n  }\n\n  /**\n   * Get the ID of the event that a given user has read up to, or null if:\n   * - we have received no read receipts for them, or\n   * - the receipt we have points at an event we don't have, or\n   * - the thread ID in the receipt does not match the thread root of the\n   *   referenced event.\n   *\n   * (The event might not exist if it is not loaded, and the thread ID might\n   * not match if the event has moved thread because it was redacted.)\n   *\n   * @param userId - The user ID to get read receipt event ID for\n   * @param ignoreSynthesized - If true, return only receipts that have been\n   *                            sent by the server, not implicit ones generated\n   *                            by the JS SDK.\n   * @returns ID of the latest existing event that the given user has read, or null.\n   */\n  getEventReadUpTo(userId) {\n    var ignoreSynthesized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // Find what the latest receipt says is the latest event we have read\n    var latestReceipt = this.getLatestReceipt(userId, ignoreSynthesized);\n    if (!latestReceipt) {\n      return null;\n    }\n    return this.receiptPointsAtConsistentEvent(latestReceipt) ? latestReceipt.eventId : null;\n  }\n\n  /**\n   * Returns true if the event pointed at by this receipt exists, and its\n   * threadRootId is consistent with the thread information in the receipt.\n   */\n  receiptPointsAtConsistentEvent(receipt) {\n    var _receipt$data;\n    var event = this.findEventById(receipt.eventId);\n    if (!event) {\n      // If the receipt points at a non-existent event, we have multiple\n      // possibilities:\n      //\n      // 1. We don't have the event because it's not loaded yet - probably\n      //    it's old and we're best off ignoring the receipt - we can just\n      //    send a new one when we read a new event.\n      //\n      // 2. We have a bug e.g. we misclassified this event into the wrong\n      //    thread.\n      //\n      // 3. The referenced event moved out of this thread (e.g. because it\n      //    was deleted.)\n      //\n      // 4. The receipt had the incorrect thread ID (due to a bug in a\n      // client, or malicious behaviour).\n\n      // This receipt is not \"valid\" because it doesn't point at an event\n      // we have. We want to pretend it doesn't exist.\n      return false;\n    }\n    if (!((_receipt$data = receipt.data) !== null && _receipt$data !== void 0 && _receipt$data.thread_id)) {\n      // If this is an unthreaded receipt, it could point at any event, so\n      // there is no need to validate further - this receipt is valid.\n      return true;\n    }\n    // Otherwise it is a threaded receipt...\n\n    if (receipt.data.thread_id === MAIN_ROOM_TIMELINE) {\n      // The receipt is for the main timeline: we check that the event is\n      // in the main timeline.\n\n      // Check if the event is in the main timeline\n      var eventIsInMainTimeline = inMainTimelineForReceipt(event);\n      if (eventIsInMainTimeline) {\n        // The receipt is for the main timeline, and so is the event, so\n        // the receipt is valid.\n        return true;\n      }\n    } else {\n      // The receipt is for a different thread (not the main timeline)\n\n      if (event.threadRootId === receipt.data.thread_id) {\n        // If the receipt and event agree on the thread ID, the receipt\n        // is valid.\n        return true;\n      }\n    }\n\n    // The receipt thread ID disagrees with the event thread ID. There are 2\n    // possibilities:\n    //\n    // 1. The event moved to a different thread after the receipt was\n    //    created. This can happen if the event was redacted because that\n    //    moves it to the main timeline.\n    //\n    // 2. There is a bug somewhere - either we put the event into the wrong\n    //    thread, or someone sent an incorrect receipt.\n    //\n    // In many cases, we won't get here because the call to findEventById\n    // would have already returned null. We include this check to cover\n    // cases when `this` is a  room, meaning findEventById will find events\n    // in any thread, and to be defensive against unforeseen code paths.\n    logger.warn(\"Ignoring receipt because its thread_id (\".concat(receipt.data.thread_id, \") disagrees \") + \"with the thread root (\".concat(event.threadRootId, \") of the referenced event \") + \"(event ID = \".concat(receipt.eventId, \")\"));\n\n    // This receipt is not \"valid\" because it disagrees with us about what\n    // thread the event is in. We want to pretend it doesn't exist.\n    return false;\n  }\n  getLatestReceipt(userId, ignoreSynthesized) {\n    var _ref, _ref2;\n    // XXX: This is very very ugly and I hope I won't have to ever add a new\n    // receipt type here again. IMHO this should be done by the server in\n    // some more intelligent manner or the client should just use timestamps\n\n    var publicReadReceipt = this.getReadReceiptForUserId(userId, ignoreSynthesized, ReceiptType.Read);\n    var privateReadReceipt = this.getReadReceiptForUserId(userId, ignoreSynthesized, ReceiptType.ReadPrivate);\n\n    // If we have both, compare them\n    var comparison;\n    if (publicReadReceipt !== null && publicReadReceipt !== void 0 && publicReadReceipt.eventId && privateReadReceipt !== null && privateReadReceipt !== void 0 && privateReadReceipt.eventId) {\n      comparison = this.compareReceipts(publicReadReceipt, privateReadReceipt);\n    }\n\n    // The public receipt is more likely to drift out of date so the private\n    // one has precedence\n    if (!comparison) return (_ref = privateReadReceipt !== null && privateReadReceipt !== void 0 ? privateReadReceipt : publicReadReceipt) !== null && _ref !== void 0 ? _ref : null;\n\n    // If public read receipt is older, return the private one\n    return (_ref2 = comparison < 0 ? privateReadReceipt : publicReadReceipt) !== null && _ref2 !== void 0 ? _ref2 : null;\n  }\n  addReceiptToStructure(eventId, receiptType, userId, receipt, synthetic) {\n    var _pair$ReceiptPairSynt2, _pair$ReceiptPairSynt3;\n    var receiptTypesMap = this.receipts.getOrCreate(receiptType);\n    var pair = receiptTypesMap.get(userId);\n    if (!pair) {\n      pair = [null, null];\n      receiptTypesMap.set(userId, pair);\n    }\n    var existingReceipt = pair[ReceiptPairRealIndex];\n    if (synthetic) {\n      var _pair$ReceiptPairSynt;\n      existingReceipt = (_pair$ReceiptPairSynt = pair[ReceiptPairSyntheticIndex]) !== null && _pair$ReceiptPairSynt !== void 0 ? _pair$ReceiptPairSynt : pair[ReceiptPairRealIndex];\n    }\n    var wrappedReceipt = {\n      eventId,\n      data: receipt\n    };\n    if (existingReceipt) {\n      // We only want to add this receipt if we think it is later than the one we already have.\n      // This is managed server-side, but because we synthesize RRs locally we have to do it here too.\n      var _ordering = this.compareReceipts(existingReceipt, wrappedReceipt);\n      if (_ordering >= 0) {\n        return;\n      }\n    }\n    var realReceipt = synthetic ? pair[ReceiptPairRealIndex] : wrappedReceipt;\n    var syntheticReceipt = synthetic ? wrappedReceipt : pair[ReceiptPairSyntheticIndex];\n    var ordering = null;\n    if (realReceipt && syntheticReceipt) {\n      ordering = this.getUnfilteredTimelineSet().compareEventOrdering(realReceipt.eventId, syntheticReceipt.eventId);\n    }\n    var preferSynthetic = ordering === null || ordering < 0;\n\n    // we don't bother caching just real receipts by event ID as there's nothing that would read it.\n    // Take the current cached receipt before we overwrite the pair elements.\n    var cachedReceipt = (_pair$ReceiptPairSynt2 = pair[ReceiptPairSyntheticIndex]) !== null && _pair$ReceiptPairSynt2 !== void 0 ? _pair$ReceiptPairSynt2 : pair[ReceiptPairRealIndex];\n    if (synthetic && preferSynthetic) {\n      pair[ReceiptPairSyntheticIndex] = wrappedReceipt;\n    } else if (!synthetic) {\n      pair[ReceiptPairRealIndex] = wrappedReceipt;\n      if (!preferSynthetic) {\n        pair[ReceiptPairSyntheticIndex] = null;\n      }\n    }\n    var newCachedReceipt = (_pair$ReceiptPairSynt3 = pair[ReceiptPairSyntheticIndex]) !== null && _pair$ReceiptPairSynt3 !== void 0 ? _pair$ReceiptPairSynt3 : pair[ReceiptPairRealIndex];\n    if (cachedReceipt === newCachedReceipt) return;\n\n    // clean up any previous cache entry\n    if (cachedReceipt && this.receiptCacheByEventId.get(cachedReceipt.eventId)) {\n      var previousEventId = cachedReceipt.eventId;\n      // Remove the receipt we're about to clobber out of existence from the cache\n      this.receiptCacheByEventId.set(previousEventId, this.receiptCacheByEventId.get(previousEventId).filter(r => {\n        return r.type !== receiptType || r.userId !== userId;\n      }));\n      if (this.receiptCacheByEventId.get(previousEventId).length < 1) {\n        this.receiptCacheByEventId.delete(previousEventId); // clean up the cache keys\n      }\n    }\n\n    // cache the new one\n    if (!this.receiptCacheByEventId.get(eventId)) {\n      this.receiptCacheByEventId.set(eventId, []);\n    }\n    this.receiptCacheByEventId.get(eventId).push({\n      userId: userId,\n      type: receiptType,\n      data: receipt\n    });\n  }\n\n  /**\n   * Get a list of receipts for the given event.\n   * @param event - the event to get receipts for\n   * @returns A list of receipts with a userId, type and data keys or\n   * an empty list.\n   */\n  getReceiptsForEvent(event) {\n    return this.receiptCacheByEventId.get(event.getId()) || [];\n  }\n\n  /**\n   * Look in this room/thread's timeline to find an event. If `this` is a\n   * room, we look in all threads, but if `this` is a thread, we look only\n   * inside this thread.\n   */\n\n  /**\n   * This issue should also be addressed on synapse's side and is tracked as part\n   * of https://github.com/matrix-org/synapse/issues/14837\n   *\n   * Retrieves the read receipt for the logged in user and checks if it matches\n   * the last event in the room and whether that event originated from the logged\n   * in user.\n   * Under those conditions we can consider the context as read. This is useful\n   * because we never send read receipts against our own events\n   * @param userId - the logged in user\n   */\n  fixupNotifications(userId) {\n    var receipt = this.getReadReceiptForUserId(userId, false);\n    var lastEvent = this.timeline[this.timeline.length - 1];\n    if (lastEvent && (receipt === null || receipt === void 0 ? void 0 : receipt.eventId) === lastEvent.getId() && userId === lastEvent.getSender()) {\n      this.setUnread(NotificationCountType.Total, 0);\n      this.setUnread(NotificationCountType.Highlight, 0);\n    }\n  }\n\n  /**\n   * Add a temporary local-echo receipt to the room to reflect in the\n   * client the fact that we've sent one.\n   * @param userId - The user ID if the receipt sender\n   * @param e - The event that is to be acknowledged\n   * @param receiptType - The type of receipt\n   * @param unthreaded - the receipt is unthreaded\n   */\n  addLocalEchoReceipt(userId, e, receiptType) {\n    var unthreaded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.addReceipt(synthesizeReceipt(userId, e, receiptType, unthreaded), true);\n  }\n\n  /**\n   * Get a list of user IDs who have <b>read up to</b> the given event.\n   * @param event - the event to get read receipts for.\n   * @returns A list of user IDs.\n   */\n  getUsersReadUpTo(event) {\n    return this.getReceiptsForEvent(event).filter(function (receipt) {\n      return isSupportedReceiptType(receipt.type);\n    }).map(function (receipt) {\n      return receipt.userId;\n    });\n  }\n\n  /**\n   * Determines if the given user has read a particular event ID with the known\n   * history of the room. This is not a definitive check as it relies only on\n   * what is available to the room at the time of execution.\n   * @param userId - The user ID to check the read state of.\n   * @param eventId - The event ID to check if the user read.\n   * @returns True if the user has read the event, false otherwise.\n   */\n\n  /**\n   * Returns the most recent unthreaded receipt for a given user\n   * @param userId - the MxID of the User\n   * @returns an unthreaded Receipt. Can be undefined if receipts have been disabled\n   * or a user chooses to use private read receipts (or we have simply not received\n   * a receipt from this user yet).\n   *\n   * @deprecated use `hasUserReadEvent` or `getEventReadUpTo` instead\n   */\n}\n//# sourceMappingURL=read-receipt.js.map","import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { M_POLL_START } from \"matrix-events-sdk\";\nimport { M_POLL_END, M_POLL_RESPONSE } from \"../@types/polls.js\";\nimport { Relations } from \"./relations.js\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.js\";\nexport var PollEvent = /*#__PURE__*/function (PollEvent) {\n  PollEvent[\"New\"] = \"Poll.new\";\n  PollEvent[\"End\"] = \"Poll.end\";\n  PollEvent[\"Update\"] = \"Poll.update\";\n  PollEvent[\"Responses\"] = \"Poll.Responses\";\n  PollEvent[\"Destroy\"] = \"Poll.Destroy\";\n  PollEvent[\"UndecryptableRelations\"] = \"Poll.UndecryptableRelations\";\n  return PollEvent;\n}({});\nvar filterResponseRelations = (relationEvents, pollEndTimestamp) => {\n  var responseEvents = relationEvents.filter(event => {\n    if (event.isDecryptionFailure()) {\n      return;\n    }\n    return M_POLL_RESPONSE.matches(event.getType()) &&\n    // From MSC3381:\n    // \"Votes sent on or before the end event's timestamp are valid votes\"\n    event.getTs() <= pollEndTimestamp;\n  });\n  return {\n    responseEvents\n  };\n};\nexport class Poll extends TypedEventEmitter {\n  constructor(rootEvent, matrixClient, room) {\n    super();\n    this.rootEvent = rootEvent;\n    this.matrixClient = matrixClient;\n    this.room = room;\n    _defineProperty(this, \"roomId\", void 0);\n    _defineProperty(this, \"pollEvent\", void 0);\n    _defineProperty(this, \"_isFetchingResponses\", false);\n    _defineProperty(this, \"relationsNextBatch\", void 0);\n    _defineProperty(this, \"responses\", null);\n    _defineProperty(this, \"endEvent\", void 0);\n    /**\n     * Keep track of undecryptable relations\n     * As incomplete result sets affect poll results\n     */\n    _defineProperty(this, \"undecryptableRelationEventIds\", new Set());\n    _defineProperty(this, \"countUndecryptableEvents\", events => {\n      var undecryptableEventIds = events.filter(event => event.isDecryptionFailure()).map(event => event.getId());\n      var previousCount = this.undecryptableRelationsCount;\n      this.undecryptableRelationEventIds = new Set([...this.undecryptableRelationEventIds, ...undecryptableEventIds]);\n      if (this.undecryptableRelationsCount !== previousCount) {\n        this.emit(PollEvent.UndecryptableRelations, this.undecryptableRelationsCount);\n      }\n    });\n    if (!this.rootEvent.getRoomId() || !this.rootEvent.getId()) {\n      throw new Error(\"Invalid poll start event.\");\n    }\n    this.roomId = this.rootEvent.getRoomId();\n    this.pollEvent = this.rootEvent.unstableExtensibleEvent;\n  }\n  get pollId() {\n    return this.rootEvent.getId();\n  }\n  get endEventId() {\n    var _this$endEvent;\n    return (_this$endEvent = this.endEvent) === null || _this$endEvent === void 0 ? void 0 : _this$endEvent.getId();\n  }\n  get isEnded() {\n    return !!this.endEvent;\n  }\n  get isFetchingResponses() {\n    return this._isFetchingResponses;\n  }\n  get undecryptableRelationsCount() {\n    return this.undecryptableRelationEventIds.size;\n  }\n  getResponses() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // if we have already fetched some responses\n      // just return them\n      if (_this.responses) {\n        return _this.responses;\n      }\n\n      // if there is no fetching in progress\n      // start fetching\n      if (!_this.isFetchingResponses) {\n        yield _this.fetchResponses();\n      }\n      // return whatever responses we got from the first page\n      return _this.responses;\n    })();\n  }\n\n  /**\n   *\n   * @param event - event with a relation to the rootEvent\n   * @returns void\n   */\n  onNewRelation(event) {\n    var _this$endEvent2;\n    if (M_POLL_END.matches(event.getType()) && this.validateEndEvent(event)) {\n      this.endEvent = event;\n      this.refilterResponsesOnEnd();\n      this.emit(PollEvent.End);\n    }\n\n    // wait for poll responses to be initialised\n    if (!this.responses) {\n      return;\n    }\n    var pollEndTimestamp = ((_this$endEvent2 = this.endEvent) === null || _this$endEvent2 === void 0 ? void 0 : _this$endEvent2.getTs()) || Number.MAX_SAFE_INTEGER;\n    var {\n      responseEvents\n    } = filterResponseRelations([event], pollEndTimestamp);\n    this.countUndecryptableEvents([event]);\n    if (responseEvents.length) {\n      responseEvents.forEach(event => {\n        this.responses.addEvent(event);\n      });\n      this.emit(PollEvent.Responses, this.responses);\n    }\n  }\n  fetchResponses() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _this2$endEvent, _allRelations$nextBat;\n      _this2._isFetchingResponses = true;\n\n      // we want:\n      // - stable and unstable M_POLL_RESPONSE\n      // - stable and unstable M_POLL_END\n      // so make one api call and filter by event type client side\n      var allRelations = yield _this2.matrixClient.relations(_this2.roomId, _this2.rootEvent.getId(), \"m.reference\", undefined, {\n        from: _this2.relationsNextBatch || undefined\n      });\n      yield Promise.all(allRelations.events.map(event => _this2.matrixClient.decryptEventIfNeeded(event)));\n      var responses = _this2.responses || new Relations(\"m.reference\", M_POLL_RESPONSE.name, _this2.matrixClient, [M_POLL_RESPONSE.altName]);\n      var pollEndEvent = allRelations.events.find(event => M_POLL_END.matches(event.getType()));\n      if (_this2.validateEndEvent(pollEndEvent)) {\n        _this2.endEvent = pollEndEvent;\n        _this2.refilterResponsesOnEnd();\n        _this2.emit(PollEvent.End);\n      }\n      var pollCloseTimestamp = ((_this2$endEvent = _this2.endEvent) === null || _this2$endEvent === void 0 ? void 0 : _this2$endEvent.getTs()) || Number.MAX_SAFE_INTEGER;\n      var {\n        responseEvents\n      } = filterResponseRelations(allRelations.events, pollCloseTimestamp);\n      responseEvents.forEach(event => {\n        responses.addEvent(event);\n      });\n      _this2.relationsNextBatch = (_allRelations$nextBat = allRelations.nextBatch) !== null && _allRelations$nextBat !== void 0 ? _allRelations$nextBat : undefined;\n      _this2.responses = responses;\n      _this2.countUndecryptableEvents(allRelations.events);\n\n      // while there are more pages of relations\n      // fetch them\n      if (_this2.relationsNextBatch) {\n        // don't await\n        // we want to return the first page as soon as possible\n        _this2.fetchResponses();\n      } else {\n        // no more pages\n        _this2._isFetchingResponses = false;\n      }\n\n      // emit after updating _isFetchingResponses state\n      _this2.emit(PollEvent.Responses, _this2.responses);\n    })();\n  }\n\n  /**\n   * Only responses made before the poll ended are valid\n   * Refilter after an end event is recieved\n   * To ensure responses are valid\n   */\n  refilterResponsesOnEnd() {\n    var _this$endEvent3;\n    if (!this.responses) {\n      return;\n    }\n    var pollEndTimestamp = ((_this$endEvent3 = this.endEvent) === null || _this$endEvent3 === void 0 ? void 0 : _this$endEvent3.getTs()) || Number.MAX_SAFE_INTEGER;\n    this.responses.getRelations().forEach(event => {\n      if (event.getTs() > pollEndTimestamp) {\n        var _this$responses;\n        (_this$responses = this.responses) === null || _this$responses === void 0 || _this$responses.removeEvent(event);\n      }\n    });\n    this.emit(PollEvent.Responses, this.responses);\n  }\n  validateEndEvent(endEvent) {\n    if (!endEvent) {\n      return false;\n    }\n    /**\n     * Repeated end events are ignored -\n     * only the first (valid) closure event by origin_server_ts is counted.\n     */\n    if (this.endEvent && this.endEvent.getTs() < endEvent.getTs()) {\n      return false;\n    }\n\n    /**\n     * MSC3381\n     * If a m.poll.end event is received from someone other than the poll creator or user with permission to redact\n     * others' messages in the room, the event must be ignored by clients due to being invalid.\n     */\n    var roomCurrentState = this.room.currentState;\n    var endEventSender = endEvent.getSender();\n    return !!endEventSender && (endEventSender === this.rootEvent.getSender() || roomCurrentState.maySendRedactionForEvent(this.rootEvent, endEventSender));\n  }\n}\n\n/**\n * Tests whether the event is a start, response or end poll event.\n *\n * @param event - Event to test\n * @returns true if the event is a poll event, else false\n */\nexport var isPollEvent = event => {\n  var eventType = event.getType();\n  return M_POLL_START.matches(eventType) || M_POLL_RESPONSE.matches(eventType) || M_POLL_END.matches(eventType);\n};\n//# sourceMappingURL=poll.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MAIN_ROOM_TIMELINE } from \"../@types/read_receipts.js\";\nimport { threadIdForReceipt } from \"../client.js\";\nimport { RoomEvent } from \"./room.js\";\nimport { logger } from \"../logger.js\";\n\n/**\n * The latest receipts we have for a room.\n */\nexport class RoomReceipts {\n  constructor(room) {\n    _defineProperty(this, \"room\", void 0);\n    _defineProperty(this, \"threadedReceipts\", void 0);\n    _defineProperty(this, \"unthreadedReceipts\", void 0);\n    _defineProperty(this, \"danglingReceipts\", void 0);\n    /**\n     * Look for dangling receipts for the given event ID,\n     * and add them to the thread of unthread receipts if found.\n     * @param event - the event to look for\n     */\n    _defineProperty(this, \"onTimelineEvent\", event => {\n      var eventId = event.getId();\n      if (!eventId) return;\n      var danglingReceipts = this.danglingReceipts.remove(eventId);\n      danglingReceipts === null || danglingReceipts === void 0 || danglingReceipts.forEach(danglingReceipt => {\n        // The receipt is a thread receipt\n        if (danglingReceipt.receipt.thread_id) {\n          this.threadedReceipts.set(danglingReceipt.receipt.thread_id, danglingReceipt.eventId, danglingReceipt.receiptType, danglingReceipt.userId, danglingReceipt.receipt.ts, danglingReceipt.synthetic);\n        } else {\n          this.unthreadedReceipts.set(eventId, danglingReceipt.receiptType, danglingReceipt.userId, danglingReceipt.receipt.ts, danglingReceipt.synthetic);\n        }\n      });\n    });\n    this.room = room;\n    this.threadedReceipts = new ThreadedReceipts(room);\n    this.unthreadedReceipts = new ReceiptsByUser(room);\n    this.danglingReceipts = new DanglingReceipts();\n    // We listen for timeline events so we can process dangling receipts\n    room.on(RoomEvent.Timeline, this.onTimelineEvent);\n  }\n\n  /**\n   * Remember the receipt information supplied. For each receipt:\n   *\n   * If we don't have the event for this receipt, store it as \"dangling\" so we\n   * can process it later.\n   *\n   * Otherwise store it per-user in either the threaded store for its\n   * thread_id, or the unthreaded store if there is no thread_id.\n   *\n   * Ignores any receipt that is before an existing receipt for the same user\n   * (in the same thread, if applicable). \"Before\" is defined by the\n   * unfilteredTimelineSet of the room.\n   */\n  add(receiptContent, synthetic) {\n    /*\n        Transform this structure:\n        {\n          \"$EVENTID\": {\n            \"m.read|m.read.private\": {\n              \"@user:example.org\": {\n                \"ts\": 1661,\n                \"thread_id\": \"main|$THREAD_ROOT_ID\" // or missing/undefined for an unthreaded receipt\n              }\n            }\n          },\n          ...\n        }\n        into maps of:\n        threaded :: threadid :: userId :: ReceiptInfo\n        unthreaded :: userId :: ReceiptInfo\n        dangling :: eventId :: DanglingReceipt\n    */\n    for (var [_eventId, eventReceipt] of Object.entries(receiptContent)) {\n      for (var [_receiptType, receiptsByUser] of Object.entries(eventReceipt)) {\n        for (var [_userId, _receipt] of Object.entries(receiptsByUser)) {\n          var referencedEvent = this.room.findEventById(_eventId);\n          if (!referencedEvent) {\n            this.danglingReceipts.add(new DanglingReceipt(_eventId, _receiptType, _userId, _receipt, synthetic));\n          } else if (_receipt.thread_id) {\n            this.threadedReceipts.set(_receipt.thread_id, _eventId, _receiptType, _userId, _receipt.ts, synthetic);\n          } else {\n            this.unthreadedReceipts.set(_eventId, _receiptType, _userId, _receipt.ts, synthetic);\n          }\n        }\n      }\n    }\n  }\n  hasUserReadEvent(userId, eventId) {\n    var unthreaded = this.unthreadedReceipts.get(userId);\n    if (unthreaded) {\n      if (isAfterOrSame(unthreaded.eventId, eventId, this.room)) {\n        // The unthreaded receipt is after this event, so we have read it.\n        return true;\n      }\n    }\n    var event = this.room.findEventById(eventId);\n    if (!event) {\n      // We don't know whether the user has read it - default to caution and say no.\n      // This shouldn't really happen and feels like it ought to be an exception: let's\n      // log a warn for now.\n      logger.warn(\"hasUserReadEvent event ID \".concat(eventId, \" not found in room \").concat(this.room.roomId, \": this shouldn't happen!\"));\n      return false;\n    }\n    var threadId = threadIdForReceipt(event);\n    var threaded = this.threadedReceipts.get(threadId, userId);\n    if (threaded) {\n      if (isAfterOrSame(threaded.eventId, eventId, this.room)) {\n        // The threaded receipt is after this event, so we have read it.\n        return true;\n      }\n    }\n\n    // TODO: what if they sent the second-last event in the thread?\n    if (this.userSentLatestEventInThread(threadId, userId)) {\n      // The user sent the latest message in this event's thread, so we\n      // consider everything in the thread to be read.\n      //\n      // Note: maybe we don't need this because synthetic receipts should\n      // do this job for us?\n      return true;\n    }\n\n    // Neither of the receipts were after the event, so it's unread.\n    return false;\n  }\n\n  /**\n   * @returns true if the thread with this ID can be found, and the supplied\n   *          user sent the latest message in it.\n   */\n  userSentLatestEventInThread(threadId, userId) {\n    var _this$room$getThread;\n    var timeline = threadId === MAIN_ROOM_TIMELINE ? this.room.getLiveTimeline().getEvents() : (_this$room$getThread = this.room.getThread(threadId)) === null || _this$room$getThread === void 0 ? void 0 : _this$room$getThread.timeline;\n    return !!(timeline && timeline.length > 0 && timeline[timeline.length - 1].getSender() === userId);\n  }\n}\n\n// --- implementation details ---\n\n/**\n * The information \"inside\" a receipt once it has been stored inside\n * RoomReceipts - what eventId it refers to, its type, and its ts.\n *\n * Does not contain userId or threadId since these are stored as keys of the\n * maps in RoomReceipts.\n */\nclass ReceiptInfo {\n  constructor(eventId, receiptType, ts) {\n    this.eventId = eventId;\n    this.receiptType = receiptType;\n    this.ts = ts;\n  }\n}\n\n/**\n * Everything we know about a receipt that is \"dangling\" because we can't find\n * the event to which it refers.\n */\nclass DanglingReceipt {\n  constructor(eventId, receiptType, userId, receipt, synthetic) {\n    this.eventId = eventId;\n    this.receiptType = receiptType;\n    this.userId = userId;\n    this.receipt = receipt;\n    this.synthetic = synthetic;\n  }\n}\nclass UserReceipts {\n  constructor(room) {\n    _defineProperty(this, \"room\", void 0);\n    /**\n     * The real receipt for this user.\n     */\n    _defineProperty(this, \"real\", void 0);\n    /**\n     * The synthetic receipt for this user. If this is defined, it is later than real.\n     */\n    _defineProperty(this, \"synthetic\", void 0);\n    this.room = room;\n    this.real = undefined;\n    this.synthetic = undefined;\n  }\n  set(synthetic, receiptInfo) {\n    if (synthetic) {\n      this.synthetic = receiptInfo;\n    } else {\n      this.real = receiptInfo;\n    }\n\n    // Preserve the invariant: synthetic is only defined if it's later than real\n    if (this.synthetic && this.real) {\n      if (isAfterOrSame(this.real.eventId, this.synthetic.eventId, this.room)) {\n        this.synthetic = undefined;\n      }\n    }\n  }\n\n  /**\n   * Return the latest receipt we have - synthetic if we have one (and it's\n   * later), otherwise real.\n   */\n  get() {\n    var _this$synthetic;\n    // Relies on the invariant that synthetic is only defined if it's later than real.\n    return (_this$synthetic = this.synthetic) !== null && _this$synthetic !== void 0 ? _this$synthetic : this.real;\n  }\n\n  /**\n   * Return the latest receipt we have of the specified type (synthetic or not).\n   */\n  getByType(synthetic) {\n    return synthetic ? this.synthetic : this.real;\n  }\n}\n\n/**\n * The latest receipt info we have, either for a single thread, or all the\n * unthreaded receipts for a room.\n *\n * userId: ReceiptInfo\n */\nclass ReceiptsByUser {\n  constructor(room) {\n    _defineProperty(this, \"room\", void 0);\n    /** map of userId: UserReceipts */\n    _defineProperty(this, \"data\", void 0);\n    this.room = room;\n    this.data = new Map();\n  }\n\n  /**\n   * Add the supplied receipt to our structure, if it is not earlier than the\n   * one we already hold for this user.\n   */\n  set(eventId, receiptType, userId, ts, synthetic) {\n    var userReceipts = getOrCreate(this.data, userId, () => new UserReceipts(this.room));\n    var existingReceipt = userReceipts.getByType(synthetic);\n    if (existingReceipt && isAfter(existingReceipt.eventId, eventId, this.room)) {\n      // The new receipt is before the existing one - don't store it.\n      return;\n    }\n\n    // Possibilities:\n    //\n    // 1. there was no existing receipt, or\n    // 2. the existing receipt was before this one, or\n    // 3. we were unable to compare the receipts.\n    //\n    // In the case of 3 it's difficult to decide what to do, so the\n    // most-recently-received receipt wins.\n    //\n    // Case 3 can only happen if the events for these receipts have\n    // disappeared, which is quite unlikely since the new one has just been\n    // checked, and the old one was checked before it was inserted here.\n    //\n    // We go ahead and store this receipt (replacing the other if it exists)\n    userReceipts.set(synthetic, new ReceiptInfo(eventId, receiptType, ts));\n  }\n\n  /**\n   * Find the latest receipt we have for this user. (Note - there is only one\n   * receipt per user, because we are already inside a specific thread or\n   * unthreaded list.)\n   *\n   * If there is a later synthetic receipt for this user, return that.\n   * Otherwise, return the real receipt.\n   *\n   * @returns the found receipt info, or undefined if we have no receipt for this user.\n   */\n  get(userId) {\n    var _this$data$get;\n    return (_this$data$get = this.data.get(userId)) === null || _this$data$get === void 0 ? void 0 : _this$data$get.get();\n  }\n}\n\n/**\n * The latest threaded receipts we have for a room.\n */\nclass ThreadedReceipts {\n  constructor(room) {\n    _defineProperty(this, \"room\", void 0);\n    /** map of threadId: ReceiptsByUser */\n    _defineProperty(this, \"data\", void 0);\n    this.room = room;\n    this.data = new Map();\n  }\n\n  /**\n   * Add the supplied receipt to our structure, if it is not earlier than one\n   * we already hold for this user in this thread.\n   */\n  set(threadId, eventId, receiptType, userId, ts, synthetic) {\n    var receiptsByUser = getOrCreate(this.data, threadId, () => new ReceiptsByUser(this.room));\n    receiptsByUser.set(eventId, receiptType, userId, ts, synthetic);\n  }\n\n  /**\n   * Find the latest threaded receipt for the supplied user in the supplied thread.\n   *\n   * @returns the found receipt info or undefined if we don't have one.\n   */\n  get(threadId, userId) {\n    var _this$data$get2;\n    return (_this$data$get2 = this.data.get(threadId)) === null || _this$data$get2 === void 0 ? void 0 : _this$data$get2.get(userId);\n  }\n}\n\n/**\n * All the receipts that we have received but can't process because we can't\n * find the event they refer to.\n *\n * We hold on to them so we can process them if their event arrives later.\n */\nclass DanglingReceipts {\n  constructor() {\n    /**\n     * eventId: DanglingReceipt[]\n     */\n    _defineProperty(this, \"data\", new Map());\n  }\n  /**\n   * Remember the supplied dangling receipt.\n   */\n  add(danglingReceipt) {\n    var danglingReceipts = getOrCreate(this.data, danglingReceipt.eventId, () => []);\n    danglingReceipts.push(danglingReceipt);\n  }\n\n  /**\n   * Remove and return the dangling receipts for the given event ID.\n   * @param eventId - the event ID to look for\n   * @returns the found dangling receipts, or undefined if we don't have one.\n   */\n  remove(eventId) {\n    var danglingReceipts = this.data.get(eventId);\n    this.data.delete(eventId);\n    return danglingReceipts;\n  }\n}\nfunction getOrCreate(m, key, createFn) {\n  var found = m.get(key);\n  if (found) {\n    return found;\n  } else {\n    var created = createFn();\n    m.set(key, created);\n    return created;\n  }\n}\n\n/**\n * Is left after right (or the same)?\n *\n * Only returns true if both events can be found, and left is after or the same\n * as right.\n *\n * @returns left \\>= right\n */\nfunction isAfterOrSame(leftEventId, rightEventId, room) {\n  var comparison = room.compareEventOrdering(leftEventId, rightEventId);\n  return comparison !== null && comparison >= 0;\n}\n\n/**\n * Is left strictly after right?\n *\n * Only returns true if both events can be found, and left is strictly after right.\n *\n * @returns left \\> right\n */\nfunction isAfter(leftEventId, rightEventId, room) {\n  var comparison = room.compareEventOrdering(leftEventId, rightEventId);\n  return comparison !== null && comparison > 0;\n}\n//# sourceMappingURL=room-receipts.js.map","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { inMainTimelineForReceipt, threadIdForReceipt } from \"../client.js\";\n\n/**\n * Determine the order of two events in a room.\n *\n * In principle this should use the same order as the server, but in practice\n * this is difficult for events that were not received over the Sync API. See\n * MSC4033 for details.\n *\n * This implementation leans on the order of events within their timelines, and\n * falls back to comparing event timestamps when they are in different\n * timelines.\n *\n * See https://github.com/matrix-org/matrix-js-sdk/issues/3325 for where we are\n * tracking the work to fix this.\n *\n * @param room - the room we are looking in\n * @param leftEventId - the id of the first event\n * @param rightEventId - the id of the second event\n\n * @returns -1 if left \\< right, 1 if left \\> right, 0 if left == right, null if\n *          we can't tell (because we can't find the events).\n */\nexport function compareEventOrdering(room, leftEventId, rightEventId) {\n  var leftEvent = room.findEventById(leftEventId);\n  var rightEvent = room.findEventById(rightEventId);\n  if (!leftEvent || !rightEvent) {\n    // Without the events themselves, we can't find their thread or\n    // timeline, or guess based on timestamp, so we just don't know.\n    return null;\n  }\n\n  // Check whether the events are in the main timeline\n  var isLeftEventInMainTimeline = inMainTimelineForReceipt(leftEvent);\n  var isRightEventInMainTimeline = inMainTimelineForReceipt(rightEvent);\n  if (isLeftEventInMainTimeline && isRightEventInMainTimeline) {\n    return compareEventsInMainTimeline(room, leftEventId, rightEventId, leftEvent, rightEvent);\n  } else {\n    // At least one event is not in the timeline, so we can't use the room's\n    // unfiltered timeline set.\n    return compareEventsInThreads(leftEventId, rightEventId, leftEvent, rightEvent);\n  }\n}\nfunction compareEventsInMainTimeline(room, leftEventId, rightEventId, leftEvent, rightEvent) {\n  // Get the timeline set that contains all the events.\n  var timelineSet = room.getUnfilteredTimelineSet();\n\n  // If they are in the same timeline, compareEventOrdering does what we need\n  var compareSameTimeline = timelineSet.compareEventOrdering(leftEventId, rightEventId);\n  if (compareSameTimeline !== null) {\n    return compareSameTimeline;\n  }\n\n  // Find which timeline each event is in. Refuse to provide an ordering if we\n  // can't find either of the events.\n\n  var leftTimeline = timelineSet.getTimelineForEvent(leftEventId);\n  if (leftTimeline === timelineSet.getLiveTimeline()) {\n    // The left event is part of the live timeline, so it must be after the\n    // right event (since they are not in the same timeline or we would have\n    // returned after compareEventOrdering.\n    return 1;\n  }\n  var rightTimeline = timelineSet.getTimelineForEvent(rightEventId);\n  if (rightTimeline === timelineSet.getLiveTimeline()) {\n    // The right event is part of the live timeline, so it must be after the\n    // left event.\n    return -1;\n  }\n\n  // They are in older timeline sets (because they were fetched by paging up).\n  return guessOrderBasedOnTimestamp(leftEvent, rightEvent);\n}\nfunction compareEventsInThreads(leftEventId, rightEventId, leftEvent, rightEvent) {\n  var leftEventThreadId = threadIdForReceipt(leftEvent);\n  var rightEventThreadId = threadIdForReceipt(rightEvent);\n  var leftThread = leftEvent.getThread();\n  if (leftThread && leftEventThreadId === rightEventThreadId) {\n    // They are in the same thread, so we can ask the thread's timeline to\n    // figure it out for us\n    return leftThread.timelineSet.compareEventOrdering(leftEventId, rightEventId);\n  } else {\n    return guessOrderBasedOnTimestamp(leftEvent, rightEvent);\n  }\n}\n\n/**\n * Guess the order of events based on server timestamp. This is not good, but\n * difficult to avoid without MSC4033.\n *\n * See https://github.com/matrix-org/matrix-js-sdk/issues/3325\n */\nfunction guessOrderBasedOnTimestamp(leftEvent, rightEvent) {\n  var leftTs = leftEvent.getTs();\n  var rightTs = rightEvent.getTs();\n  if (leftTs < rightTs) {\n    return -1;\n  } else if (leftTs > rightTs) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n//# sourceMappingURL=compare-event-ordering.js.map","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport var Method = /*#__PURE__*/function (Method) {\n  Method[\"Get\"] = \"GET\";\n  Method[\"Put\"] = \"PUT\";\n  Method[\"Post\"] = \"POST\";\n  Method[\"Delete\"] = \"DELETE\";\n  Method[\"Options\"] = \"OPTIONS\";\n  Method[\"Head\"] = \"HEAD\";\n  Method[\"Patch\"] = \"PATCH\";\n  return Method;\n}({});\n//# sourceMappingURL=method.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Construct a generic HTTP error. This is a JavaScript Error with additional information\n * specific to HTTP responses.\n * @param msg - The error message to include.\n * @param httpStatus - The HTTP response status code.\n */\nexport class HTTPError extends Error {\n  constructor(msg, httpStatus) {\n    super(msg);\n    this.httpStatus = httpStatus;\n  }\n}\nexport class MatrixError extends HTTPError {\n  /**\n   * Construct a Matrix error. This is a JavaScript Error with additional\n   * information specific to the standard Matrix error response.\n   * @param errorJson - The Matrix error JSON returned from the homeserver.\n   * @param httpStatus - The numeric HTTP status code given\n   */\n  constructor() {\n    var errorJson = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var httpStatus = arguments.length > 1 ? arguments[1] : undefined;\n    var url = arguments.length > 2 ? arguments[2] : undefined;\n    var event = arguments.length > 3 ? arguments[3] : undefined;\n    var message = errorJson.error || \"Unknown message\";\n    if (httpStatus) {\n      message = \"[\".concat(httpStatus, \"] \").concat(message);\n    }\n    if (url) {\n      message = \"\".concat(message, \" (\").concat(url, \")\");\n    }\n    super(\"MatrixError: \".concat(message), httpStatus);\n    this.httpStatus = httpStatus;\n    this.url = url;\n    this.event = event;\n    // The Matrix 'errcode' value, e.g. \"M_FORBIDDEN\".\n    _defineProperty(this, \"errcode\", void 0);\n    // The raw Matrix error JSON used to construct this object.\n    _defineProperty(this, \"data\", void 0);\n    this.errcode = errorJson.errcode;\n    this.name = errorJson.errcode || \"Unknown error code\";\n    this.data = errorJson;\n  }\n}\n\n/**\n * Construct a ConnectionError. This is a JavaScript Error indicating\n * that a request failed because of some error with the connection, either\n * CORS was not correctly configured on the server, the server didn't response,\n * the request timed out, or the internet connection on the client side went down.\n */\nexport class ConnectionError extends Error {\n  constructor(message, cause) {\n    super(message + (cause ? \": \".concat(cause.message) : \"\"));\n  }\n  get name() {\n    return \"ConnectionError\";\n  }\n}\n//# sourceMappingURL=errors.js.map","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @experimental\n * Unencrypted access and (optional) refresh token\n */\n\n/**\n * @experimental\n * Function that performs token refresh using the given refreshToken.\n * Returns a promise that resolves to the refreshed access and (optional) refresh tokens.\n *\n * Can be passed to HttpApi instance as {@link IHttpOpts.tokenRefreshFunction} during client creation {@link ICreateClientOpts}\n */\n\nexport var HttpApiEvent = /*#__PURE__*/function (HttpApiEvent) {\n  HttpApiEvent[\"SessionLoggedOut\"] = \"Session.logged_out\";\n  HttpApiEvent[\"NoConsent\"] = \"no_consent\";\n  return HttpApiEvent;\n}({});\n//# sourceMappingURL=interface.js.map","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n","var parser = require('./parser');\nvar writer = require('./writer');\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","/* Copyright 2015 Mark Haines\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar escaped = /[\\\\\\\"\\x00-\\x1F]/g;\nvar escapes = {};\nfor (var i = 0; i < 0x20; ++i) {\n    escapes[String.fromCharCode(i)] = (\n        '\\\\U' + ('0000' + i.toString(16)).slice(-4).toUpperCase()\n    );\n}\nescapes['\\b'] = '\\\\b';\nescapes['\\t'] = '\\\\t';\nescapes['\\n'] = '\\\\n';\nescapes['\\f'] = '\\\\f';\nescapes['\\r'] = '\\\\r';\nescapes['\\\"'] = '\\\\\\\"';\nescapes['\\\\'] = '\\\\\\\\';\n\nfunction escapeString(value) {\n    escaped.lastIndex = 0;\n    return value.replace(escaped, function(c) { return escapes[c]; });\n}\n\nfunction stringify(value) {\n    switch (typeof value) {\n        case 'string':\n            return '\"' + escapeString(value) + '\"';\n        case 'number':\n            return isFinite(value) ? value : 'null';\n        case 'boolean':\n            return value;\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            if (Array.isArray(value)) {\n                return stringifyArray(value);\n            }\n            return stringifyObject(value);\n        default:\n            throw new Error('Cannot stringify: ' + typeof value);\n    }\n}\n\nfunction stringifyArray(array) {\n    var sep = '[';\n    var result = '';\n    for (var i = 0; i < array.length; ++i) {\n        result += sep;\n        sep = ',';\n        result += stringify(array[i]);\n    }\n    if (sep != ',') {\n        return '[]';\n    } else {\n        return result + ']';\n    }\n}\n\nfunction stringifyObject(object) {\n    var sep = '{';\n    var result = '';\n    var keys = Object.keys(object);\n    keys.sort();\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        result += sep + '\"' + escapeString(key) + '\":';\n        sep = ',';\n        result += stringify(object[key]);\n    }\n    if (sep != ',') {\n        return '{}';\n    } else {\n        return result + '}';\n    }\n}\n\n/** */\nmodule.exports = {stringify: stringify};\n","import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"server\", \"limit\", \"since\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2015-2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixClient} for the public class.\n */\n\nimport { SyncApi, SyncState } from \"./sync.js\";\nimport { EventStatus, MatrixEvent, MatrixEventEvent } from \"./models/event.js\";\nimport { StubStore } from \"./store/stub.js\";\nimport { createNewMatrixCall, supportsMatrixCall } from \"./webrtc/call.js\";\nimport { Filter } from \"./filter.js\";\nimport { CallEventHandler } from \"./webrtc/callEventHandler.js\";\nimport { GroupCallEventHandler } from \"./webrtc/groupCallEventHandler.js\";\nimport * as utils from \"./utils.js\";\nimport { noUnsafeEventProps, replaceParam, safeSet, sleep } from \"./utils.js\";\nimport { Direction, EventTimeline } from \"./models/event-timeline.js\";\nimport { PushProcessor } from \"./pushprocessor.js\";\nimport { AutoDiscovery } from \"./autodiscovery.js\";\nimport * as olmlib from \"./crypto/olmlib.js\";\nimport { decodeBase64, encodeBase64, encodeUnpaddedBase64Url } from \"./base64.js\";\nimport { TypedReEmitter } from \"./ReEmitter.js\";\nimport { logger } from \"./logger.js\";\nimport { SERVICE_TYPES } from \"./service-types.js\";\nimport { ClientPrefix, IdentityPrefix, MatrixError, MatrixHttpApi, MediaPrefix, Method, retryNetworkOperation } from \"./http-api/index.js\";\nimport { Crypto, CryptoEvent as LegacyCryptoEvent, fixBackupKey, isCryptoAvailable } from \"./crypto/index.js\";\nimport { User, UserEvent } from \"./models/user.js\";\nimport { getHttpUriForMxc } from \"./content-repo.js\";\nimport { SearchResult } from \"./models/search-result.js\";\nimport { DEHYDRATION_ALGORITHM } from \"./crypto/dehydration.js\";\nimport { CrossSigningKey } from \"./crypto/api.js\";\nimport * as ContentHelpers from \"./content-helpers.js\";\nimport { NotificationCountType } from \"./models/room.js\";\nimport { RoomMemberEvent } from \"./models/room-member.js\";\nimport { EventType, LOCAL_NOTIFICATION_SETTINGS_PREFIX, MSC3912_RELATION_BASED_REDACTIONS_PROP, MsgType, PUSHER_ENABLED, RelationType, RoomCreateTypeField, RoomType, UNSTABLE_MSC3088_ENABLED, UNSTABLE_MSC3088_PURPOSE, UNSTABLE_MSC3089_TREE_SUBTYPE } from \"./@types/event.js\";\nimport { GuestAccess, HistoryVisibility, Preset } from \"./@types/partials.js\";\nimport { eventMapperFor } from \"./event-mapper.js\";\nimport { randomString } from \"./randomstring.js\";\nimport { BackupManager } from \"./crypto/backup.js\";\nimport { DEFAULT_TREE_POWER_LEVELS_TEMPLATE, MSC3089TreeSpace } from \"./models/MSC3089TreeSpace.js\";\nimport { SearchOrderBy } from \"./@types/search.js\";\nimport { PushRuleActionName, PushRuleKind } from \"./@types/PushRules.js\";\nimport { GroupCall } from \"./webrtc/groupCall.js\";\nimport { MediaHandler } from \"./webrtc/mediaHandler.js\";\nimport { TypedEventEmitter } from \"./models/typed-event-emitter.js\";\nimport { MAIN_ROOM_TIMELINE, ReceiptType } from \"./@types/read_receipts.js\";\nimport { SlidingSyncSdk } from \"./sliding-sync-sdk.js\";\nimport { determineFeatureSupport, FeatureSupport, Thread, THREAD_RELATION_TYPE, ThreadFilterType, threadFilterTypeToFilter } from \"./models/thread.js\";\nimport { M_BEACON_INFO } from \"./@types/beacon.js\";\nimport { NamespacedValue, UnstableValue } from \"./NamespacedValue.js\";\nimport { ToDeviceMessageQueue } from \"./ToDeviceMessageQueue.js\";\nimport { IgnoredInvites } from \"./models/invites-ignorer.js\";\nimport { buildFeatureSupportMap, Feature, ServerSupport } from \"./feature.js\";\nimport { RUST_SDK_STORE_PREFIX } from \"./rust-crypto/constants.js\";\nimport { decodeRecoveryKey, CryptoEvent } from \"./crypto-api/index.js\";\nimport { ServerSideSecretStorageImpl } from \"./secret-storage.js\";\nimport { MatrixRTCSessionManager } from \"./matrixrtc/MatrixRTCSessionManager.js\";\nimport { getRelationsThreadFilter } from \"./thread-utils.js\";\nimport { KnownMembership } from \"./@types/membership.js\";\nimport { ServerCapabilities } from \"./serverCapabilities.js\";\nimport { sha256 } from \"./digest.js\";\nimport { keyFromAuthData } from \"./common-crypto/key-passphrase.js\";\nvar SCROLLBACK_DELAY_MS = 3000;\nexport var CRYPTO_ENABLED = isCryptoAvailable();\nvar TURN_CHECK_INTERVAL = 10 * 60 * 1000; // poll for turn credentials every 10 minutes\n\nexport var UNSTABLE_MSC3852_LAST_SEEN_UA = new UnstableValue(\"last_seen_user_agent\", \"org.matrix.msc3852.last_seen_user_agent\");\nexport var PendingEventOrdering = /*#__PURE__*/function (PendingEventOrdering) {\n  PendingEventOrdering[\"Chronological\"] = \"chronological\";\n  PendingEventOrdering[\"Detached\"] = \"detached\";\n  return PendingEventOrdering;\n}({});\nexport var GET_LOGIN_TOKEN_CAPABILITY = new NamespacedValue(\"m.get_login_token\", \"org.matrix.msc3882.get_login_token\");\nexport var UNSTABLE_MSC2666_SHARED_ROOMS = \"uk.half-shot.msc2666\";\nexport var UNSTABLE_MSC2666_MUTUAL_ROOMS = \"uk.half-shot.msc2666.mutual_rooms\";\nexport var UNSTABLE_MSC2666_QUERY_MUTUAL_ROOMS = \"uk.half-shot.msc2666.query_mutual_rooms\";\nexport var UNSTABLE_MSC4140_DELAYED_EVENTS = \"org.matrix.msc4140\";\nexport var UNSTABLE_MSC4133_EXTENDED_PROFILES = \"uk.tcpip.msc4133\";\nvar CrossSigningKeyType = /*#__PURE__*/function (CrossSigningKeyType) {\n  CrossSigningKeyType[\"MasterKey\"] = \"master_key\";\n  CrossSigningKeyType[\"SelfSigningKey\"] = \"self_signing_key\";\n  CrossSigningKeyType[\"UserSigningKey\"] = \"user_signing_key\";\n  return CrossSigningKeyType;\n}(CrossSigningKeyType || {}); // Re-export for backwards compatibility\n/**\n * The summary of a room as defined by an initial version of MSC3266 and implemented in Synapse\n * Proposed at https://github.com/matrix-org/matrix-doc/pull/3266\n */\n/* eslint-enable camelcase */\n\n// We're using this constant for methods overloading and inspect whether a variable\n// contains an eventId or not. This was required to ensure backwards compatibility\n// of methods for threads\n// Probably not the most graceful solution but does a good enough job for now\nvar EVENT_ID_PREFIX = \"$\";\nexport var ClientEvent = /*#__PURE__*/function (ClientEvent) {\n  ClientEvent[\"Sync\"] = \"sync\";\n  ClientEvent[\"Event\"] = \"event\";\n  ClientEvent[\"ToDeviceEvent\"] = \"toDeviceEvent\";\n  ClientEvent[\"AccountData\"] = \"accountData\";\n  ClientEvent[\"Room\"] = \"Room\";\n  ClientEvent[\"DeleteRoom\"] = \"deleteRoom\";\n  ClientEvent[\"SyncUnexpectedError\"] = \"sync.unexpectedError\";\n  ClientEvent[\"ClientWellKnown\"] = \"WellKnown.client\";\n  ClientEvent[\"ReceivedVoipEvent\"] = \"received_voip_event\";\n  ClientEvent[\"UndecryptableToDeviceEvent\"] = \"toDeviceEvent.undecryptable\";\n  ClientEvent[\"TurnServers\"] = \"turnServers\";\n  ClientEvent[\"TurnServersError\"] = \"turnServers.error\";\n  return ClientEvent;\n}({});\nvar SSO_ACTION_PARAM = new UnstableValue(\"action\", \"org.matrix.msc3824.action\");\n\n/**\n * Represents a Matrix Client. Only directly construct this if you want to use\n * custom modules. Normally, {@link createClient} should be used\n * as it specifies 'sensible' defaults for these modules.\n */\nexport class MatrixClient extends TypedEventEmitter {\n  constructor(opts) {\n    var _opts$logger, _opts$usingExternalCr, _this, _opts$cryptoCallbacks;\n    // If a custom logger is provided, use it. Otherwise, default to the global\n    // one in logger.ts.\n    super();\n    _this = this;\n    _defineProperty(this, \"logger\", void 0);\n    _defineProperty(this, \"reEmitter\", new TypedReEmitter(this));\n    _defineProperty(this, \"olmVersion\", null);\n    // populated after initCrypto\n    _defineProperty(this, \"usingExternalCrypto\", false);\n    _defineProperty(this, \"_store\", void 0);\n    _defineProperty(this, \"deviceId\", void 0);\n    _defineProperty(this, \"credentials\", void 0);\n    /**\n     * Encryption key used for encrypting sensitive data (such as e2ee keys) in storage.\n     *\n     * As supplied in the constructor via {@link IMatrixClientCreateOpts#pickleKey}.\n     *\n     * If unset, either a hardcoded key or no encryption at all is used, depending on the Crypto implementation.\n     *\n     * @deprecated this should be a private property.\n     */\n    _defineProperty(this, \"pickleKey\", void 0);\n    _defineProperty(this, \"scheduler\", void 0);\n    _defineProperty(this, \"clientRunning\", false);\n    _defineProperty(this, \"timelineSupport\", false);\n    _defineProperty(this, \"urlPreviewCache\", {});\n    _defineProperty(this, \"identityServer\", void 0);\n    _defineProperty(this, \"http\", void 0);\n    // XXX: Intended private, used in code.\n    /**\n     * The libolm crypto implementation, if it is in use.\n     *\n     * @deprecated This should not be used. Instead, use the methods exposed directly on this class or\n     * (where they are available) via {@link getCrypto}.\n     */\n    _defineProperty(this, \"crypto\", void 0);\n    // XXX: Intended private, used in code. Being replaced by cryptoBackend\n    _defineProperty(this, \"cryptoBackend\", void 0);\n    // one of crypto or rustCrypto\n    _defineProperty(this, \"cryptoCallbacks\", void 0);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"callEventHandler\", void 0);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"groupCallEventHandler\", void 0);\n    _defineProperty(this, \"supportsCallTransfer\", false);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"forceTURN\", false);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"iceCandidatePoolSize\", 0);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"idBaseUrl\", void 0);\n    _defineProperty(this, \"baseUrl\", void 0);\n    _defineProperty(this, \"isVoipWithNoMediaAllowed\", void 0);\n    _defineProperty(this, \"useLivekitForGroupCalls\", void 0);\n    // Note: these are all `protected` to let downstream consumers make mistakes if they want to.\n    // We don't technically support this usage, but have reasons to do this.\n    _defineProperty(this, \"canSupportVoip\", false);\n    _defineProperty(this, \"peekSync\", null);\n    _defineProperty(this, \"isGuestAccount\", false);\n    _defineProperty(this, \"ongoingScrollbacks\", {});\n    _defineProperty(this, \"notifTimelineSet\", null);\n    _defineProperty(this, \"cryptoStore\", void 0);\n    _defineProperty(this, \"verificationMethods\", void 0);\n    _defineProperty(this, \"fallbackICEServerAllowed\", false);\n    _defineProperty(this, \"syncApi\", void 0);\n    _defineProperty(this, \"roomNameGenerator\", void 0);\n    _defineProperty(this, \"pushRules\", void 0);\n    _defineProperty(this, \"syncLeftRoomsPromise\", void 0);\n    _defineProperty(this, \"syncedLeftRooms\", false);\n    _defineProperty(this, \"clientOpts\", void 0);\n    _defineProperty(this, \"clientWellKnownIntervalID\", void 0);\n    _defineProperty(this, \"canResetTimelineCallback\", void 0);\n    _defineProperty(this, \"canSupport\", new Map());\n    // The pushprocessor caches useful things, so keep one and re-use it\n    _defineProperty(this, \"pushProcessor\", new PushProcessor(this));\n    // Promise to a response of the server's /versions response\n    // TODO: This should expire: https://github.com/matrix-org/matrix-js-sdk/issues/1020\n    _defineProperty(this, \"serverVersionsPromise\", void 0);\n    _defineProperty(this, \"clientWellKnown\", void 0);\n    _defineProperty(this, \"clientWellKnownPromise\", void 0);\n    _defineProperty(this, \"turnServers\", []);\n    _defineProperty(this, \"turnServersExpiry\", 0);\n    _defineProperty(this, \"checkTurnServersIntervalID\", void 0);\n    _defineProperty(this, \"exportedOlmDeviceToImport\", void 0);\n    _defineProperty(this, \"txnCtr\", 0);\n    _defineProperty(this, \"mediaHandler\", new MediaHandler(this));\n    _defineProperty(this, \"sessionId\", void 0);\n    /** IDs of events which are currently being encrypted.\n     *\n     * This is part of the cancellation mechanism: if the event is no longer listed here when encryption completes,\n     * that tells us that it has been cancelled, and we should not send it.\n     */\n    _defineProperty(this, \"eventsBeingEncrypted\", new Set());\n    _defineProperty(this, \"useE2eForGroupCall\", true);\n    _defineProperty(this, \"toDeviceMessageQueue\", void 0);\n    _defineProperty(this, \"livekitServiceURL\", void 0);\n    _defineProperty(this, \"_secretStorage\", void 0);\n    // A manager for determining which invites should be ignored.\n    _defineProperty(this, \"ignoredInvites\", void 0);\n    _defineProperty(this, \"matrixRTC\", void 0);\n    _defineProperty(this, \"serverCapabilitiesService\", void 0);\n    _defineProperty(this, \"startCallEventHandler\", () => {\n      if (this.isInitialSyncComplete()) {\n        if (supportsMatrixCall()) {\n          this.callEventHandler.start();\n          this.groupCallEventHandler.start();\n        }\n        this.off(ClientEvent.Sync, this.startCallEventHandler);\n      }\n    });\n    _defineProperty(this, \"startMatrixRTC\", () => {\n      if (this.isInitialSyncComplete()) {\n        this.matrixRTC.start();\n        this.off(ClientEvent.Sync, this.startMatrixRTC);\n      }\n    });\n    /**\n     * Once the client has been initialised, we want to clear notifications we\n     * know for a fact should be here.\n     * This issue should also be addressed on synapse's side and is tracked as part\n     * of https://github.com/matrix-org/synapse/issues/14837\n     *\n     * We consider a room or a thread as fully read if the current user has sent\n     * the last event in the live timeline of that context and if the read receipt\n     * we have on record matches.\n     */\n    _defineProperty(this, \"fixupRoomNotifications\", () => {\n      if (this.isInitialSyncComplete()) {\n        var _this$getRooms;\n        var unreadRooms = ((_this$getRooms = this.getRooms()) !== null && _this$getRooms !== void 0 ? _this$getRooms : []).filter(room => {\n          return room.getUnreadNotificationCount(NotificationCountType.Total) > 0;\n        });\n        for (var _room of unreadRooms) {\n          var currentUserId = this.getSafeUserId();\n          _room.fixupNotifications(currentUserId);\n        }\n        this.off(ClientEvent.Sync, this.fixupRoomNotifications);\n      }\n    });\n    this.logger = (_opts$logger = opts.logger) !== null && _opts$logger !== void 0 ? _opts$logger : logger;\n    opts.baseUrl = utils.ensureNoTrailingSlash(opts.baseUrl);\n    opts.idBaseUrl = utils.ensureNoTrailingSlash(opts.idBaseUrl);\n    this.baseUrl = opts.baseUrl;\n    this.idBaseUrl = opts.idBaseUrl;\n    this.identityServer = opts.identityServer;\n    this.usingExternalCrypto = (_opts$usingExternalCr = opts.usingExternalCrypto) !== null && _opts$usingExternalCr !== void 0 ? _opts$usingExternalCr : false;\n    this.store = opts.store || new StubStore();\n    this.deviceId = opts.deviceId || null;\n    this.sessionId = randomString(10);\n    var userId = opts.userId || null;\n    this.credentials = {\n      userId\n    };\n    this.http = new MatrixHttpApi(this, {\n      fetchFn: opts.fetchFn,\n      baseUrl: opts.baseUrl,\n      idBaseUrl: opts.idBaseUrl,\n      accessToken: opts.accessToken,\n      refreshToken: opts.refreshToken,\n      tokenRefreshFunction: opts.tokenRefreshFunction,\n      prefix: ClientPrefix.V3,\n      onlyData: true,\n      extraParams: opts.queryParams,\n      localTimeoutMs: opts.localTimeoutMs,\n      useAuthorizationHeader: opts.useAuthorizationHeader,\n      logger: this.logger\n    });\n    if (opts.deviceToImport) {\n      if (this.deviceId) {\n        this.logger.warn(\"not importing device because device ID is provided to \" + \"constructor independently of exported data\");\n      } else if (this.credentials.userId) {\n        this.logger.warn(\"not importing device because user ID is provided to \" + \"constructor independently of exported data\");\n      } else if (!opts.deviceToImport.deviceId) {\n        this.logger.warn(\"not importing device because no device ID in exported data\");\n      } else {\n        this.deviceId = opts.deviceToImport.deviceId;\n        this.credentials.userId = opts.deviceToImport.userId;\n        // will be used during async initialization of the crypto\n        this.exportedOlmDeviceToImport = opts.deviceToImport.olmDevice;\n      }\n    } else if (opts.pickleKey) {\n      this.pickleKey = opts.pickleKey;\n    }\n    this.useLivekitForGroupCalls = Boolean(opts.useLivekitForGroupCalls);\n    this.scheduler = opts.scheduler;\n    if (this.scheduler) {\n      this.scheduler.setProcessFunction(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (eventToSend) {\n          var room = _this.getRoom(eventToSend.getRoomId());\n          if (eventToSend.status !== EventStatus.SENDING) {\n            _this.updatePendingEventStatus(room, eventToSend, EventStatus.SENDING);\n          }\n          var res = yield _this.sendEventHttpRequest(eventToSend);\n          if (room) {\n            // ensure we update pending event before the next scheduler run so that any listeners to event id\n            // updates on the synchronous event emitter get a chance to run first.\n            room.updatePendingEvent(eventToSend, EventStatus.SENT, res.event_id);\n          }\n          return res;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n    if (supportsMatrixCall()) {\n      this.callEventHandler = new CallEventHandler(this);\n      this.groupCallEventHandler = new GroupCallEventHandler(this);\n      this.canSupportVoip = true;\n      // Start listening for calls after the initial sync is done\n      // We do not need to backfill the call event buffer\n      // with encrypted events that might never get decrypted\n      this.on(ClientEvent.Sync, this.startCallEventHandler);\n    }\n\n    // NB. We initialise MatrixRTC whether we have call support or not: this is just\n    // the underlying session management and doesn't use any actual media capabilities\n    this.matrixRTC = new MatrixRTCSessionManager(this);\n    this.serverCapabilitiesService = new ServerCapabilities(this.http);\n    this.on(ClientEvent.Sync, this.fixupRoomNotifications);\n    this.timelineSupport = Boolean(opts.timelineSupport);\n    this.cryptoStore = opts.cryptoStore;\n    this.verificationMethods = opts.verificationMethods;\n    this.cryptoCallbacks = opts.cryptoCallbacks || {};\n    this.forceTURN = opts.forceTURN || false;\n    this.iceCandidatePoolSize = opts.iceCandidatePoolSize === undefined ? 0 : opts.iceCandidatePoolSize;\n    this.supportsCallTransfer = opts.supportsCallTransfer || false;\n    this.fallbackICEServerAllowed = opts.fallbackICEServerAllowed || false;\n    this.isVoipWithNoMediaAllowed = opts.isVoipWithNoMediaAllowed || false;\n    if (opts.useE2eForGroupCall !== undefined) this.useE2eForGroupCall = opts.useE2eForGroupCall;\n    this.livekitServiceURL = opts.livekitServiceURL;\n    this.roomNameGenerator = opts.roomNameGenerator;\n    this.toDeviceMessageQueue = new ToDeviceMessageQueue(this);\n\n    // The SDK doesn't really provide a clean way for events to recalculate the push\n    // actions for themselves, so we have to kinda help them out when they are encrypted.\n    // We do this so that push rules are correctly executed on events in their decrypted\n    // state, such as highlights when the user's name is mentioned.\n    this.on(MatrixEventEvent.Decrypted, event => {\n      fixNotificationCountOnDecryption(this, event);\n    });\n    this.ignoredInvites = new IgnoredInvites(this);\n    this._secretStorage = new ServerSideSecretStorageImpl(this, (_opts$cryptoCallbacks = opts.cryptoCallbacks) !== null && _opts$cryptoCallbacks !== void 0 ? _opts$cryptoCallbacks : {});\n\n    // having lots of event listeners is not unusual. 0 means \"unlimited\".\n    this.setMaxListeners(0);\n  }\n  set store(newStore) {\n    this._store = newStore;\n    this._store.setUserCreator(userId => User.createUser(userId, this));\n  }\n  get store() {\n    return this._store;\n  }\n\n  /**\n   * High level helper method to begin syncing and poll for new events. To listen for these\n   * events, add a listener for {@link ClientEvent.Event}\n   * via {@link MatrixClient#on}. Alternatively, listen for specific\n   * state change events.\n   * @param opts - Options to apply when syncing.\n   */\n  startClient(opts) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.clientRunning) {\n        // client is already running.\n        return;\n      }\n      _this2.clientRunning = true;\n      _this2.on(ClientEvent.Sync, _this2.startMatrixRTC);\n\n      // Create our own user object artificially (instead of waiting for sync)\n      // so it's always available, even if the user is not in any rooms etc.\n      var userId = _this2.getUserId();\n      if (userId) {\n        _this2.store.storeUser(new User(userId));\n      }\n\n      // periodically poll for turn servers if we support voip\n      if (_this2.canSupportVoip) {\n        _this2.checkTurnServersIntervalID = setInterval(() => {\n          _this2.checkTurnServers();\n        }, TURN_CHECK_INTERVAL);\n        // noinspection ES6MissingAwait\n        _this2.checkTurnServers();\n      }\n      if (_this2.syncApi) {\n        // This shouldn't happen since we thought the client was not running\n        _this2.logger.error(\"Still have sync object whilst not running: stopping old one\");\n        _this2.syncApi.stop();\n      }\n      try {\n        yield _this2.getVersions();\n\n        // This should be done with `canSupport`\n        // TODO: https://github.com/vector-im/element-web/issues/23643\n        var {\n          threads,\n          list,\n          fwdPagination\n        } = yield _this2.doesServerSupportThread();\n        Thread.setServerSideSupport(threads);\n        Thread.setServerSideListSupport(list);\n        Thread.setServerSideFwdPaginationSupport(fwdPagination);\n      } catch (e) {\n        _this2.logger.error(\"Can't fetch server versions, continuing to initialise sync, this will be retried later\", e);\n      }\n      _this2.clientOpts = opts !== null && opts !== void 0 ? opts : {};\n      if (_this2.clientOpts.slidingSync) {\n        _this2.syncApi = new SlidingSyncSdk(_this2.clientOpts.slidingSync, _this2, _this2.clientOpts, _this2.buildSyncApiOptions());\n      } else {\n        _this2.syncApi = new SyncApi(_this2, _this2.clientOpts, _this2.buildSyncApiOptions());\n      }\n      _this2.syncApi.sync().catch(e => _this2.logger.info(\"Sync startup aborted with an error:\", e));\n      if (_this2.clientOpts.clientWellKnownPollPeriod !== undefined) {\n        _this2.clientWellKnownIntervalID = setInterval(() => {\n          _this2.fetchClientWellKnown();\n        }, 1000 * _this2.clientOpts.clientWellKnownPollPeriod);\n        _this2.fetchClientWellKnown();\n      }\n      _this2.toDeviceMessageQueue.start();\n      _this2.serverCapabilitiesService.start();\n    })();\n  }\n\n  /**\n   * Construct a SyncApiOptions for this client, suitable for passing into the SyncApi constructor\n   */\n  buildSyncApiOptions() {\n    return {\n      crypto: this.crypto,\n      cryptoCallbacks: this.cryptoBackend,\n      canResetEntireTimeline: roomId => {\n        if (!this.canResetTimelineCallback) {\n          return false;\n        }\n        return this.canResetTimelineCallback(roomId);\n      }\n    };\n  }\n\n  /**\n   * High level helper method to stop the client from polling and allow a\n   * clean shutdown.\n   */\n  stopClient() {\n    var _this$cryptoBackend, _this$syncApi, _this$peekSync, _this$callEventHandle, _this$groupCallEventH;\n    (_this$cryptoBackend = this.cryptoBackend) === null || _this$cryptoBackend === void 0 || _this$cryptoBackend.stop(); // crypto might have been initialised even if the client wasn't fully started\n\n    this.off(ClientEvent.Sync, this.startMatrixRTC);\n    if (!this.clientRunning) return; // already stopped\n\n    this.logger.debug(\"stopping MatrixClient\");\n    this.clientRunning = false;\n    (_this$syncApi = this.syncApi) === null || _this$syncApi === void 0 || _this$syncApi.stop();\n    this.syncApi = undefined;\n    (_this$peekSync = this.peekSync) === null || _this$peekSync === void 0 || _this$peekSync.stopPeeking();\n    (_this$callEventHandle = this.callEventHandler) === null || _this$callEventHandle === void 0 || _this$callEventHandle.stop();\n    (_this$groupCallEventH = this.groupCallEventHandler) === null || _this$groupCallEventH === void 0 || _this$groupCallEventH.stop();\n    this.callEventHandler = undefined;\n    this.groupCallEventHandler = undefined;\n    global.clearInterval(this.checkTurnServersIntervalID);\n    this.checkTurnServersIntervalID = undefined;\n    if (this.clientWellKnownIntervalID !== undefined) {\n      global.clearInterval(this.clientWellKnownIntervalID);\n    }\n    this.toDeviceMessageQueue.stop();\n    this.matrixRTC.stop();\n    this.serverCapabilitiesService.stop();\n  }\n\n  /**\n   * Try to rehydrate a device if available.  The client must have been\n   * initialized with a `cryptoCallback.getDehydrationKey` option, and this\n   * function must be called before initCrypto and startClient are called.\n   *\n   * @returns Promise which resolves to undefined if a device could not be dehydrated, or\n   *     to the new device ID if the dehydration was successful.\n   * @returns Rejects: with an error response.\n   *\n   * @deprecated MSC2697 device dehydration is not supported for rust cryptography.\n   */\n  rehydrateDevice() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.crypto) {\n        throw new Error(\"Cannot rehydrate device after crypto is initialized\");\n      }\n      if (!_this3.cryptoCallbacks.getDehydrationKey) {\n        return;\n      }\n      var getDeviceResult = yield _this3.getDehydratedDevice();\n      if (!getDeviceResult) {\n        return;\n      }\n      if (!getDeviceResult.device_data || !getDeviceResult.device_id) {\n        _this3.logger.info(\"no dehydrated device found\");\n        return;\n      }\n      var account = new global.Olm.Account();\n      try {\n        var deviceData = getDeviceResult.device_data;\n        if (deviceData.algorithm !== DEHYDRATION_ALGORITHM) {\n          _this3.logger.warn(\"Wrong algorithm for dehydrated device\");\n          return;\n        }\n        _this3.logger.debug(\"unpickling dehydrated device\");\n        var _key = yield _this3.cryptoCallbacks.getDehydrationKey(deviceData, k => {\n          // copy the key so that it doesn't get clobbered\n          account.unpickle(new Uint8Array(k), deviceData.account);\n        });\n        account.unpickle(_key, deviceData.account);\n        _this3.logger.debug(\"unpickled device\");\n        var rehydrateResult = yield _this3.http.authedRequest(Method.Post, \"/dehydrated_device/claim\", undefined, {\n          device_id: getDeviceResult.device_id\n        }, {\n          prefix: \"/_matrix/client/unstable/org.matrix.msc2697.v2\"\n        });\n        if (rehydrateResult.success) {\n          _this3.deviceId = getDeviceResult.device_id;\n          _this3.logger.info(\"using dehydrated device\");\n          var pickleKey = _this3.pickleKey || \"DEFAULT_KEY\";\n          _this3.exportedOlmDeviceToImport = {\n            pickledAccount: account.pickle(pickleKey),\n            sessions: [],\n            pickleKey: pickleKey\n          };\n          account.free();\n          return _this3.deviceId;\n        } else {\n          account.free();\n          _this3.logger.info(\"not using dehydrated device\");\n          return;\n        }\n      } catch (e) {\n        account.free();\n        _this3.logger.warn(\"could not unpickle\", e);\n      }\n    })();\n  }\n\n  /**\n   * Get the current dehydrated device, if any\n   * @returns A promise of an object containing the dehydrated device\n   *\n   * @deprecated MSC2697 device dehydration is not supported for rust cryptography.\n   */\n  getDehydratedDevice() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this4.http.authedRequest(Method.Get, \"/dehydrated_device\", undefined, undefined, {\n          prefix: \"/_matrix/client/unstable/org.matrix.msc2697.v2\"\n        });\n      } catch (e) {\n        _this4.logger.info(\"could not get dehydrated device\", e);\n        return;\n      }\n    })();\n  }\n\n  /**\n   * Set the dehydration key.  This will also periodically dehydrate devices to\n   * the server.\n   *\n   * @param key - the dehydration key\n   * @param keyInfo - Information about the key.  Primarily for\n   *     information about how to generate the key from a passphrase.\n   * @param deviceDisplayName - The device display name for the\n   *     dehydrated device.\n   * @returns A promise that resolves when the dehydrated device is stored.\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  setDehydrationKey(key, keyInfo, deviceDisplayName) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this5.crypto) {\n        _this5.logger.warn(\"not dehydrating device if crypto is not enabled\");\n        return;\n      }\n      return _this5.crypto.dehydrationManager.setKeyAndQueueDehydration(key, keyInfo, deviceDisplayName);\n    })();\n  }\n\n  /**\n   * Creates a new MSC2967 dehydrated device (without queuing periodic dehydration)\n   * @param key - the dehydration key\n   * @param keyInfo - Information about the key.  Primarily for\n   *     information about how to generate the key from a passphrase.\n   * @param deviceDisplayName - The device display name for the\n   *     dehydrated device.\n   * @returns the device id of the newly created dehydrated device\n   *\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.startDehydration}.\n   */\n  createDehydratedDevice(key, keyInfo, deviceDisplayName) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this6.crypto) {\n        _this6.logger.warn(\"not dehydrating device if crypto is not enabled\");\n        return;\n      }\n      yield _this6.crypto.dehydrationManager.setKey(key, keyInfo, deviceDisplayName);\n      return _this6.crypto.dehydrationManager.dehydrateDevice();\n    })();\n  }\n\n  /** @deprecated Not supported for Rust Cryptography. */\n  exportDevice() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this7.crypto) {\n        _this7.logger.warn(\"not exporting device if crypto is not enabled\");\n        return;\n      }\n      return {\n        userId: _this7.credentials.userId,\n        deviceId: _this7.deviceId,\n        // XXX: Private member access.\n        olmDevice: yield _this7.crypto.olmDevice.export()\n      };\n    })();\n  }\n\n  /**\n   * Clear any data out of the persistent stores used by the client.\n   *\n   * @returns Promise which resolves when the stores have been cleared.\n   */\n  clearStores() {\n    var _this8 = this;\n    if (this.clientRunning) {\n      throw new Error(\"Cannot clear stores while client is running\");\n    }\n    var promises = [];\n    promises.push(this.store.deleteAllData());\n    if (this.cryptoStore) {\n      promises.push(this.cryptoStore.deleteAllData());\n    }\n\n    // delete the stores used by the rust matrix-sdk-crypto, in case they were used\n    var deleteRustSdkStore = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* () {\n        var indexedDB;\n        try {\n          indexedDB = global.indexedDB;\n          if (!indexedDB) return; // No indexedDB support\n        } catch (_unused) {\n          // No indexedDB support\n          return;\n        }\n        var _loop = function* _loop(dbname) {\n          var prom = new Promise((resolve, reject) => {\n            _this8.logger.info(\"Removing IndexedDB instance \".concat(dbname));\n            var req = indexedDB.deleteDatabase(dbname);\n            req.onsuccess = _ => {\n              _this8.logger.info(\"Removed IndexedDB instance \".concat(dbname));\n              resolve(0);\n            };\n            req.onerror = e => {\n              // In private browsing, Firefox has a global.indexedDB, but attempts to delete an indexeddb\n              // (even a non-existent one) fail with \"DOMException: A mutation operation was attempted on a\n              // database that did not allow mutations.\"\n              //\n              // it seems like the only thing we can really do is ignore the error.\n              _this8.logger.warn(\"Failed to remove IndexedDB instance \".concat(dbname, \":\"), e);\n              resolve(0);\n            };\n            req.onblocked = e => {\n              _this8.logger.info(\"cannot yet remove IndexedDB instance \".concat(dbname));\n            };\n          });\n          yield prom;\n        };\n        for (var dbname of [\"\".concat(RUST_SDK_STORE_PREFIX, \"::matrix-sdk-crypto\"), \"\".concat(RUST_SDK_STORE_PREFIX, \"::matrix-sdk-crypto-meta\")]) {\n          yield* _loop(dbname);\n        }\n      });\n      return function deleteRustSdkStore() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    promises.push(deleteRustSdkStore());\n    return Promise.all(promises).then(); // .then to fix types\n  }\n\n  /**\n   * Get the user-id of the logged-in user\n   *\n   * @returns MXID for the logged-in user, or null if not logged in\n   */\n  getUserId() {\n    if (this.credentials && this.credentials.userId) {\n      return this.credentials.userId;\n    }\n    return null;\n  }\n\n  /**\n   * Get the user-id of the logged-in user\n   *\n   * @returns MXID for the logged-in user\n   * @throws Error if not logged in\n   */\n  getSafeUserId() {\n    var userId = this.getUserId();\n    if (!userId) {\n      throw new Error(\"Expected logged in user but found none.\");\n    }\n    return userId;\n  }\n\n  /**\n   * Get the domain for this client's MXID\n   * @returns Domain of this MXID\n   */\n  getDomain() {\n    if (this.credentials && this.credentials.userId) {\n      return this.credentials.userId.replace(/^.*?:/, \"\");\n    }\n    return null;\n  }\n\n  /**\n   * Get the local part of the current user ID e.g. \"foo\" in \"\\@foo:bar\".\n   * @returns The user ID localpart or null.\n   */\n  getUserIdLocalpart() {\n    if (this.credentials && this.credentials.userId) {\n      return this.credentials.userId.split(\":\")[0].substring(1);\n    }\n    return null;\n  }\n\n  /**\n   * Get the device ID of this client\n   * @returns device ID\n   */\n  getDeviceId() {\n    return this.deviceId;\n  }\n\n  /**\n   * Get the session ID of this client\n   * @returns session ID\n   */\n  getSessionId() {\n    return this.sessionId;\n  }\n\n  /**\n   * Check if the runtime environment supports VoIP calling.\n   * @returns True if VoIP is supported.\n   */\n  supportsVoip() {\n    return this.canSupportVoip;\n  }\n\n  /**\n   * @returns\n   */\n  getMediaHandler() {\n    return this.mediaHandler;\n  }\n\n  /**\n   * Set whether VoIP calls are forced to use only TURN\n   * candidates. This is the same as the forceTURN option\n   * when creating the client.\n   * @param force - True to force use of TURN servers\n   */\n  setForceTURN(force) {\n    this.forceTURN = force;\n  }\n\n  /**\n   * Set whether to advertise transfer support to other parties on Matrix calls.\n   * @param support - True to advertise the 'm.call.transferee' capability\n   */\n  setSupportsCallTransfer(support) {\n    this.supportsCallTransfer = support;\n  }\n\n  /**\n   * Returns true if to-device signalling for group calls will be encrypted with Olm.\n   * If false, it will be sent unencrypted.\n   * @returns boolean Whether group call signalling will be encrypted\n   */\n  getUseE2eForGroupCall() {\n    return this.useE2eForGroupCall;\n  }\n\n  /**\n   * Creates a new call.\n   * The place*Call methods on the returned call can be used to actually place a call\n   *\n   * @param roomId - The room the call is to be placed in.\n   * @returns the call or null if the browser doesn't support calling.\n   */\n  createCall(roomId) {\n    return createNewMatrixCall(this, roomId);\n  }\n\n  /**\n   * Creates a new group call and sends the associated state event\n   * to alert other members that the room now has a group call.\n   *\n   * @param roomId - The room the call is to be placed in.\n   */\n  createGroupCall(roomId, type, isPtt, intent, dataChannelsEnabled, dataChannelOptions) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (_this9.getGroupCallForRoom(roomId)) {\n        throw new Error(\"\".concat(roomId, \" already has an existing group call\"));\n      }\n      var room = _this9.getRoom(roomId);\n      if (!room) {\n        throw new Error(\"Cannot find room \".concat(roomId));\n      }\n\n      // Because without Media section a WebRTC connection is not possible, so need a RTCDataChannel to set up a\n      // no media WebRTC connection anyway.\n      return new GroupCall(_this9, room, type, isPtt, intent, undefined, dataChannelsEnabled || _this9.isVoipWithNoMediaAllowed, dataChannelOptions, _this9.isVoipWithNoMediaAllowed, _this9.useLivekitForGroupCalls, _this9.livekitServiceURL).create();\n    })();\n  }\n  getLivekitServiceURL() {\n    return this.livekitServiceURL;\n  }\n\n  // This shouldn't need to exist, but the widget API has startup ordering problems that\n  // mean it doesn't know the livekit URL fast enough: remove this once this is fixed.\n  setLivekitServiceURL(newURL) {\n    this.livekitServiceURL = newURL;\n  }\n\n  /**\n   * Wait until an initial state for the given room has been processed by the\n   * client and the client is aware of any ongoing group calls. Awaiting on\n   * the promise returned by this method before calling getGroupCallForRoom()\n   * avoids races where getGroupCallForRoom is called before the state for that\n   * room has been processed. It does not, however, fix other races, eg. two\n   * clients both creating a group call at the same time.\n   * @param roomId - The room ID to wait for\n   * @returns A promise that resolves once existing group calls in the room\n   *          have been processed.\n   */\n  waitUntilRoomReadyForGroupCalls(roomId) {\n    return this.groupCallEventHandler.waitUntilRoomReadyForGroupCalls(roomId);\n  }\n\n  /**\n   * Get an existing group call for the provided room.\n   * @returns The group call or null if it doesn't already exist.\n   */\n  getGroupCallForRoom(roomId) {\n    return this.groupCallEventHandler.groupCalls.get(roomId) || null;\n  }\n\n  /**\n   * Get the current sync state.\n   * @returns the sync state, which may be null.\n   * @see MatrixClient#event:\"sync\"\n   */\n  getSyncState() {\n    var _this$syncApi$getSync, _this$syncApi2;\n    return (_this$syncApi$getSync = (_this$syncApi2 = this.syncApi) === null || _this$syncApi2 === void 0 ? void 0 : _this$syncApi2.getSyncState()) !== null && _this$syncApi$getSync !== void 0 ? _this$syncApi$getSync : null;\n  }\n\n  /**\n   * Returns the additional data object associated with\n   * the current sync state, or null if there is no\n   * such data.\n   * Sync errors, if available, are put in the 'error' key of\n   * this object.\n   */\n  getSyncStateData() {\n    if (!this.syncApi) {\n      return null;\n    }\n    return this.syncApi.getSyncStateData();\n  }\n\n  /**\n   * Whether the initial sync has completed.\n   * @returns True if at least one sync has happened.\n   */\n  isInitialSyncComplete() {\n    var state = this.getSyncState();\n    if (!state) {\n      return false;\n    }\n    return state === SyncState.Prepared || state === SyncState.Syncing;\n  }\n\n  /**\n   * Return whether the client is configured for a guest account.\n   * @returns True if this is a guest access_token (or no token is supplied).\n   */\n  isGuest() {\n    return this.isGuestAccount;\n  }\n\n  /**\n   * Set whether this client is a guest account. <b>This method is experimental\n   * and may change without warning.</b>\n   * @param guest - True if this is a guest account.\n   * @experimental if the token is a macaroon, it should be encoded in it that it is a 'guest'\n   * access token, which means that the SDK can determine this entirely without\n   * the dev manually flipping this flag.\n   */\n  setGuest(guest) {\n    this.isGuestAccount = guest;\n  }\n\n  /**\n   * Return the provided scheduler, if any.\n   * @returns The scheduler or undefined\n   */\n  getScheduler() {\n    return this.scheduler;\n  }\n\n  /**\n   * Retry a backed off syncing request immediately. This should only be used when\n   * the user <b>explicitly</b> attempts to retry their lost connection.\n   * Will also retry any outbound to-device messages currently in the queue to be sent\n   * (retries of regular outgoing events are handled separately, per-event).\n   * @returns True if this resulted in a request being retried.\n   */\n  retryImmediately() {\n    var _this$syncApi$retryIm, _this$syncApi3;\n    // don't await for this promise: we just want to kick it off\n    this.toDeviceMessageQueue.sendQueue();\n    return (_this$syncApi$retryIm = (_this$syncApi3 = this.syncApi) === null || _this$syncApi3 === void 0 ? void 0 : _this$syncApi3.retryImmediately()) !== null && _this$syncApi$retryIm !== void 0 ? _this$syncApi$retryIm : false;\n  }\n\n  /**\n   * Return the global notification EventTimelineSet, if any\n   *\n   * @returns the globl notification EventTimelineSet\n   */\n  getNotifTimelineSet() {\n    return this.notifTimelineSet;\n  }\n\n  /**\n   * Set the global notification EventTimelineSet\n   *\n   */\n  setNotifTimelineSet(set) {\n    this.notifTimelineSet = set;\n  }\n\n  /**\n   * Gets the cached capabilities of the homeserver, returning cached ones if available.\n   * If there are no cached capabilities and none can be fetched, throw an exception.\n   *\n   * @returns Promise resolving with The capabilities of the homeserver\n   */\n  getCapabilities() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      var caps = _this10.serverCapabilitiesService.getCachedCapabilities();\n      if (caps) return caps;\n      return _this10.serverCapabilitiesService.fetchCapabilities();\n    })();\n  }\n\n  /**\n   * Gets the cached capabilities of the homeserver. If none have been fetched yet,\n   * return undefined.\n   *\n   * @returns The capabilities of the homeserver\n   */\n  getCachedCapabilities() {\n    return this.serverCapabilitiesService.getCachedCapabilities();\n  }\n\n  /**\n   * Fetches the latest capabilities from the homeserver, ignoring any cached\n   * versions. The newly returned version is cached.\n   *\n   * @returns A promise which resolves to the capabilities of the homeserver\n   */\n  fetchCapabilities() {\n    return this.serverCapabilitiesService.fetchCapabilities();\n  }\n\n  /**\n   * Initialise support for end-to-end encryption in this client, using libolm.\n   *\n   * You should call this method after creating the matrixclient, but *before*\n   * calling `startClient`, if you want to support end-to-end encryption.\n   *\n   * It will return a Promise which will resolve when the crypto layer has been\n   * successfully initialised.\n   *\n   * @deprecated libolm is deprecated. Prefer {@link initRustCrypto}.\n   */\n  initCrypto() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (!isCryptoAvailable()) {\n        throw new Error(\"End-to-end encryption not supported in this js-sdk build: did \" + \"you remember to load the olm library?\");\n      }\n      if (_this11.cryptoBackend) {\n        _this11.logger.warn(\"Attempt to re-initialise e2e encryption on MatrixClient\");\n        return;\n      }\n      if (!_this11.cryptoStore) {\n        // the cryptostore is provided by sdk.createClient, so this shouldn't happen\n        throw new Error(\"Cannot enable encryption: no cryptoStore provided\");\n      }\n      _this11.logger.debug(\"Crypto: Starting up crypto store...\");\n      yield _this11.cryptoStore.startup();\n      var userId = _this11.getUserId();\n      if (userId === null) {\n        throw new Error(\"Cannot enable encryption on MatrixClient with unknown userId: \" + \"ensure userId is passed in createClient().\");\n      }\n      if (_this11.deviceId === null) {\n        throw new Error(\"Cannot enable encryption on MatrixClient with unknown deviceId: \" + \"ensure deviceId is passed in createClient().\");\n      }\n      var crypto = new Crypto(_this11, userId, _this11.deviceId, _this11.store, _this11.cryptoStore, _this11.verificationMethods);\n      _this11.reEmitter.reEmit(crypto, [LegacyCryptoEvent.KeyBackupFailed, LegacyCryptoEvent.KeyBackupSessionsRemaining, LegacyCryptoEvent.RoomKeyRequest, LegacyCryptoEvent.RoomKeyRequestCancellation, LegacyCryptoEvent.Warning, LegacyCryptoEvent.DevicesUpdated, LegacyCryptoEvent.WillUpdateDevices, LegacyCryptoEvent.DeviceVerificationChanged, LegacyCryptoEvent.UserTrustStatusChanged, LegacyCryptoEvent.KeysChanged]);\n      _this11.logger.debug(\"Crypto: initialising crypto object...\");\n      yield crypto.init({\n        exportedOlmDevice: _this11.exportedOlmDeviceToImport,\n        pickleKey: _this11.pickleKey\n      });\n      delete _this11.exportedOlmDeviceToImport;\n      _this11.olmVersion = Crypto.getOlmVersion();\n\n      // if crypto initialisation was successful, tell it to attach its event handlers.\n      crypto.registerEventHandlers(_this11);\n      _this11.cryptoBackend = _this11.crypto = crypto;\n\n      // upload our keys in the background\n      _this11.crypto.uploadDeviceKeys().catch(e => {\n        // TODO: throwing away this error is a really bad idea.\n        _this11.logger.error(\"Error uploading device keys\", e);\n      });\n    })();\n  }\n\n  /**\n   * Initialise support for end-to-end encryption in this client, using the rust matrix-sdk-crypto.\n   *\n   * An alternative to {@link initCrypto}.\n   *\n   * @param args.useIndexedDB - True to use an indexeddb store, false to use an in-memory store. Defaults to 'true'.\n   * @param args.storageKey - A key with which to encrypt the indexeddb store. If provided, it must be exactly\n   *    32 bytes of data, and must be the same each time the client is initialised for a given device.\n   *    If both this and `storagePassword` are unspecified, the store will be unencrypted.\n   * @param args.storagePassword - An alternative to `storageKey`. A password which will be used to derive a key to\n   *    encrypt the store with. Deriving a key from a password is (deliberately) a slow operation, so prefer\n   *    to pass a `storageKey` directly where possible.\n   *\n   * @returns a Promise which will resolve when the crypto layer has been\n   *    successfully initialised.\n   */\n  initRustCrypto() {\n    var _arguments = arguments,\n      _this12 = this;\n    return _asyncToGenerator(function* () {\n      var _this12$pickleKey;\n      var args = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};\n      if (_this12.cryptoBackend) {\n        _this12.logger.warn(\"Attempt to re-initialise e2e encryption on MatrixClient\");\n        return;\n      }\n      var userId = _this12.getUserId();\n      if (userId === null) {\n        throw new Error(\"Cannot enable encryption on MatrixClient with unknown userId: \" + \"ensure userId is passed in createClient().\");\n      }\n      var deviceId = _this12.getDeviceId();\n      if (deviceId === null) {\n        throw new Error(\"Cannot enable encryption on MatrixClient with unknown deviceId: \" + \"ensure deviceId is passed in createClient().\");\n      }\n\n      // importing rust-crypto will download the webassembly, so we delay it until we know it will be\n      // needed.\n      _this12.logger.debug(\"Downloading Rust crypto library\");\n      var RustCrypto = yield import(\"./rust-crypto/index.js\");\n      var rustCrypto = yield RustCrypto.initRustCrypto({\n        logger: _this12.logger,\n        http: _this12.http,\n        userId: userId,\n        deviceId: deviceId,\n        secretStorage: _this12.secretStorage,\n        cryptoCallbacks: _this12.cryptoCallbacks,\n        storePrefix: args.useIndexedDB === false ? null : RUST_SDK_STORE_PREFIX,\n        storeKey: args.storageKey,\n        storePassphrase: args.storagePassword,\n        legacyCryptoStore: _this12.cryptoStore,\n        legacyPickleKey: (_this12$pickleKey = _this12.pickleKey) !== null && _this12$pickleKey !== void 0 ? _this12$pickleKey : \"DEFAULT_KEY\",\n        legacyMigrationProgressListener: (progress, total) => {\n          _this12.emit(CryptoEvent.LegacyCryptoStoreMigrationProgress, progress, total);\n        }\n      });\n      rustCrypto.setSupportedVerificationMethods(_this12.verificationMethods);\n      _this12.cryptoBackend = rustCrypto;\n\n      // attach the event listeners needed by RustCrypto\n      _this12.on(RoomMemberEvent.Membership, rustCrypto.onRoomMembership.bind(rustCrypto));\n      _this12.on(ClientEvent.Event, event => {\n        rustCrypto.onLiveEventFromSync(event);\n      });\n\n      // re-emit the events emitted by the crypto impl\n      _this12.reEmitter.reEmit(rustCrypto, [CryptoEvent.VerificationRequestReceived, CryptoEvent.UserTrustStatusChanged, CryptoEvent.KeyBackupStatus, CryptoEvent.KeyBackupSessionsRemaining, CryptoEvent.KeyBackupFailed, CryptoEvent.KeyBackupDecryptionKeyCached, CryptoEvent.KeysChanged, CryptoEvent.DevicesUpdated, CryptoEvent.WillUpdateDevices]);\n    })();\n  }\n\n  /**\n   * Access the server-side secret storage API for this client.\n   */\n  get secretStorage() {\n    return this._secretStorage;\n  }\n\n  /**\n   * Access the crypto API for this client.\n   *\n   * If end-to-end encryption has been enabled for this client (via {@link initCrypto} or {@link initRustCrypto}),\n   * returns an object giving access to the crypto API. Otherwise, returns `undefined`.\n   */\n  getCrypto() {\n    return this.cryptoBackend;\n  }\n\n  /**\n   * Is end-to-end crypto enabled for this client.\n   * @returns True if end-to-end is enabled.\n   * @deprecated prefer {@link getCrypto}\n   */\n  isCryptoEnabled() {\n    return !!this.cryptoBackend;\n  }\n\n  /**\n   * Get the Ed25519 key for this device\n   *\n   * @returns base64-encoded ed25519 key. Null if crypto is\n   *    disabled.\n   *\n   * @deprecated Not supported for Rust Cryptography.Prefer {@link CryptoApi.getOwnDeviceKeys}\n   */\n  getDeviceEd25519Key() {\n    var _this$crypto$getDevic, _this$crypto;\n    return (_this$crypto$getDevic = (_this$crypto = this.crypto) === null || _this$crypto === void 0 ? void 0 : _this$crypto.getDeviceEd25519Key()) !== null && _this$crypto$getDevic !== void 0 ? _this$crypto$getDevic : null;\n  }\n\n  /**\n   * Get the Curve25519 key for this device\n   *\n   * @returns base64-encoded curve25519 key. Null if crypto is\n   *    disabled.\n   *\n   * @deprecated Not supported for Rust Cryptography. Use {@link CryptoApi.getOwnDeviceKeys}\n   */\n  getDeviceCurve25519Key() {\n    var _this$crypto$getDevic2, _this$crypto2;\n    return (_this$crypto$getDevic2 = (_this$crypto2 = this.crypto) === null || _this$crypto2 === void 0 ? void 0 : _this$crypto2.getDeviceCurve25519Key()) !== null && _this$crypto$getDevic2 !== void 0 ? _this$crypto$getDevic2 : null;\n  }\n\n  /**\n   * @deprecated Does nothing.\n   */\n  uploadKeys() {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      _this13.logger.warn(\"MatrixClient.uploadKeys is deprecated\");\n    })();\n  }\n\n  /**\n   * Download the keys for a list of users and stores the keys in the session\n   * store.\n   * @param userIds - The users to fetch.\n   * @param forceDownload - Always download the keys even if cached.\n   *\n   * @returns A promise which resolves to a map userId-\\>deviceId-\\>`DeviceInfo`\n   *\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.getUserDeviceInfo}\n   */\n  downloadKeys(userIds, forceDownload) {\n    if (!this.crypto) {\n      return Promise.reject(new Error(\"End-to-end encryption disabled\"));\n    }\n    return this.crypto.downloadKeys(userIds, forceDownload);\n  }\n\n  /**\n   * Get the stored device keys for a user id\n   *\n   * @param userId - the user to list keys for.\n   *\n   * @returns list of devices\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.getUserDeviceInfo}\n   */\n  getStoredDevicesForUser(userId) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.getStoredDevicesForUser(userId) || [];\n  }\n\n  /**\n   * Get the stored device key for a user id and device id\n   *\n   * @param userId - the user to list keys for.\n   * @param deviceId - unique identifier for the device\n   *\n   * @returns device or null\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.getUserDeviceInfo}\n   */\n  getStoredDevice(userId, deviceId) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.getStoredDevice(userId, deviceId) || null;\n  }\n\n  /**\n   * Mark the given device as verified\n   *\n   * @param userId - owner of the device\n   * @param deviceId - unique identifier for the device or user's\n   * cross-signing public key ID.\n   *\n   * @param verified - whether to mark the device as verified. defaults\n   *   to 'true'.\n   *\n   * @returns\n   *\n   * @remarks\n   * Fires {@link CryptoEvent#DeviceVerificationChanged}\n   */\n  setDeviceVerified(userId, deviceId) {\n    var verified = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var prom = this.setDeviceVerification(userId, deviceId, verified, null, null);\n\n    // if one of the user's own devices is being marked as verified / unverified,\n    // check the key backup status, since whether or not we use this depends on\n    // whether it has a signature from a verified device\n    if (userId == this.credentials.userId) {\n      this.checkKeyBackup();\n    }\n    return prom;\n  }\n\n  /**\n   * Mark the given device as blocked/unblocked\n   *\n   * @param userId - owner of the device\n   * @param deviceId - unique identifier for the device or user's\n   * cross-signing public key ID.\n   *\n   * @param blocked - whether to mark the device as blocked. defaults\n   *   to 'true'.\n   *\n   * @returns\n   *\n   * @remarks\n   * Fires {@link LegacyCryptoEvent.DeviceVerificationChanged}\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  setDeviceBlocked(userId, deviceId) {\n    var blocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.setDeviceVerification(userId, deviceId, null, blocked, null);\n  }\n\n  /**\n   * Mark the given device as known/unknown\n   *\n   * @param userId - owner of the device\n   * @param deviceId - unique identifier for the device or user's\n   * cross-signing public key ID.\n   *\n   * @param known - whether to mark the device as known. defaults\n   *   to 'true'.\n   *\n   * @returns\n   *\n   * @remarks\n   * Fires {@link CryptoEvent#DeviceVerificationChanged}\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  setDeviceKnown(userId, deviceId) {\n    var known = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.setDeviceVerification(userId, deviceId, null, null, known);\n  }\n  setDeviceVerification(userId, deviceId, verified, blocked, known) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this14.crypto) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      yield _this14.crypto.setDeviceVerification(userId, deviceId, verified, blocked, known);\n    })();\n  }\n\n  /**\n   * Request a key verification from another user, using a DM.\n   *\n   * @param userId - the user to request verification with\n   * @param roomId - the room to use for verification\n   *\n   * @returns resolves to a VerificationRequest\n   *    when the request has been sent to the other party.\n   *\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.requestVerificationDM}.\n   */\n  requestVerificationDM(userId, roomId) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.requestVerificationDM(userId, roomId);\n  }\n\n  /**\n   * Finds a DM verification request that is already in progress for the given room id\n   *\n   * @param roomId - the room to use for verification\n   *\n   * @returns the VerificationRequest that is in progress, if any\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.findVerificationRequestDMInProgress}.\n   */\n  findVerificationRequestDMInProgress(roomId) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    } else if (!this.crypto) {\n      // Hack for element-R to avoid breaking the cypress tests. We can get rid of this once the react-sdk is\n      // updated to use CryptoApi.findVerificationRequestDMInProgress.\n      return undefined;\n    }\n    return this.crypto.findVerificationRequestDMInProgress(roomId);\n  }\n\n  /**\n   * Returns all to-device verification requests that are already in progress for the given user id\n   *\n   * @param userId - the ID of the user to query\n   *\n   * @returns the VerificationRequests that are in progress\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.getVerificationRequestsToDeviceInProgress}.\n   */\n  getVerificationRequestsToDeviceInProgress(userId) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.getVerificationRequestsToDeviceInProgress(userId);\n  }\n\n  /**\n   * Request a key verification from another user.\n   *\n   * @param userId - the user to request verification with\n   * @param devices - array of device IDs to send requests to.  Defaults to\n   *    all devices owned by the user\n   *\n   * @returns resolves to a VerificationRequest\n   *    when the request has been sent to the other party.\n   *\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi#requestOwnUserVerification} or {@link CryptoApi#requestDeviceVerification}.\n   */\n  requestVerification(userId, devices) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.requestVerification(userId, devices);\n  }\n\n  /**\n   * Begin a key verification.\n   *\n   * @param method - the verification method to use\n   * @param userId - the user to verify keys with\n   * @param deviceId - the device to verify\n   *\n   * @returns a verification object\n   * @deprecated Prefer {@link CryptoApi#requestOwnUserVerification} or {@link CryptoApi#requestDeviceVerification}.\n   */\n  beginKeyVerification(method, userId, deviceId) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.beginKeyVerification(method, userId, deviceId);\n  }\n\n  /**\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#checkKey}.\n   */\n  checkSecretStorageKey(key, info) {\n    return this.secretStorage.checkKey(key, info);\n  }\n\n  /**\n   * Set the global override for whether the client should ever send encrypted\n   * messages to unverified devices.  This provides the default for rooms which\n   * do not specify a value.\n   *\n   * @param value - whether to blacklist all unverified devices by default\n   *\n   * @deprecated Prefer direct access to {@link CryptoApi.globalBlacklistUnverifiedDevices}:\n   *\n   * ```javascript\n   * client.getCrypto().globalBlacklistUnverifiedDevices = value;\n   * ```\n   */\n  setGlobalBlacklistUnverifiedDevices(value) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    this.cryptoBackend.globalBlacklistUnverifiedDevices = value;\n    return value;\n  }\n\n  /**\n   * @returns whether to blacklist all unverified devices by default\n   *\n   * @deprecated Prefer direct access to {@link CryptoApi.globalBlacklistUnverifiedDevices}:\n   *\n   * ```javascript\n   * value = client.getCrypto().globalBlacklistUnverifiedDevices;\n   * ```\n   */\n  getGlobalBlacklistUnverifiedDevices() {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.globalBlacklistUnverifiedDevices;\n  }\n\n  /**\n   * Set whether sendMessage in a room with unknown and unverified devices\n   * should throw an error and not send them message. This has 'Global' for\n   * symmetry with setGlobalBlacklistUnverifiedDevices but there is currently\n   * no room-level equivalent for this setting.\n   *\n   * This API is currently UNSTABLE and may change or be removed without notice.\n   *\n   * It has no effect with the Rust crypto implementation.\n   *\n   * @param value - whether error on unknown devices\n   *\n   * ```ts\n   * client.getCrypto().globalErrorOnUnknownDevices = value;\n   * ```\n   */\n  setGlobalErrorOnUnknownDevices(value) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    this.cryptoBackend.globalErrorOnUnknownDevices = value;\n  }\n\n  /**\n   * @returns whether to error on unknown devices\n   *\n   * This API is currently UNSTABLE and may change or be removed without notice.\n   */\n  getGlobalErrorOnUnknownDevices() {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.globalErrorOnUnknownDevices;\n  }\n\n  /**\n   * Get the ID of one of the user's cross-signing keys\n   *\n   * @param type - The type of key to get the ID of.  One of\n   *     \"master\", \"self_signing\", or \"user_signing\".  Defaults to \"master\".\n   *\n   * @returns the key ID\n   * @deprecated Not supported for Rust Cryptography. prefer {@link Crypto.CryptoApi#getCrossSigningKeyId}\n   */\n  getCrossSigningId() {\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CrossSigningKey.Master;\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.getCrossSigningId(type);\n  }\n\n  /**\n   * Get the cross signing information for a given user.\n   *\n   * The cross-signing API is currently UNSTABLE and may change without notice.\n   *\n   * @param userId - the user ID to get the cross-signing info for.\n   *\n   * @returns the cross signing information for the user.\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi#userHasCrossSigningKeys}\n   */\n  getStoredCrossSigningForUser(userId) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.getStoredCrossSigningForUser(userId);\n  }\n\n  /**\n   * Check whether a given user is trusted.\n   *\n   * The cross-signing API is currently UNSTABLE and may change without notice.\n   *\n   * @param userId - The ID of the user to check.\n   *\n   * @deprecated Use {@link Crypto.CryptoApi.getUserVerificationStatus | `CryptoApi.getUserVerificationStatus`}\n   */\n  checkUserTrust(userId) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.checkUserTrust(userId);\n  }\n\n  /**\n   * Check whether a given device is trusted.\n   *\n   * The cross-signing API is currently UNSTABLE and may change without notice.\n   *\n   * @param userId - The ID of the user whose devices is to be checked.\n   * @param deviceId - The ID of the device to check\n   *\n   * @deprecated Use {@link Crypto.CryptoApi.getDeviceVerificationStatus | `CryptoApi.getDeviceVerificationStatus`}\n   */\n  checkDeviceTrust(userId, deviceId) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.checkDeviceTrust(userId, deviceId);\n  }\n\n  /**\n   * Check whether one of our own devices is cross-signed by our\n   * user's stored keys, regardless of whether we trust those keys yet.\n   *\n   * @param deviceId - The ID of the device to check\n   *\n   * @returns true if the device is cross-signed\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  checkIfOwnDeviceCrossSigned(deviceId) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.checkIfOwnDeviceCrossSigned(deviceId);\n  }\n\n  /**\n   * Check the copy of our cross-signing key that we have in the device list and\n   * see if we can get the private key. If so, mark it as trusted.\n   * @param opts - ICheckOwnCrossSigningTrustOpts object\n   *\n   * @deprecated Unneeded for the new crypto\n   */\n  checkOwnCrossSigningTrust(opts) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.checkOwnCrossSigningTrust(opts);\n  }\n\n  /**\n   * Checks that a given cross-signing private key matches a given public key.\n   * This can be used by the getCrossSigningKey callback to verify that the\n   * private key it is about to supply is the one that was requested.\n   * @param privateKey - The private key\n   * @param expectedPublicKey - The public key\n   * @returns true if the key matches, otherwise false\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  checkCrossSigningPrivateKey(privateKey, expectedPublicKey) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.checkCrossSigningPrivateKey(privateKey, expectedPublicKey);\n  }\n\n  /**\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi#requestDeviceVerification}.\n   */\n  legacyDeviceVerification(userId, deviceId, method) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.legacyDeviceVerification(userId, deviceId, method);\n  }\n\n  /**\n   * Perform any background tasks that can be done before a message is ready to\n   * send, in order to speed up sending of the message.\n   * @param room - the room the event is in\n   *\n   * @deprecated Prefer {@link CryptoApi.prepareToEncrypt | `CryptoApi.prepareToEncrypt`}:\n   *\n   * ```javascript\n   * client.getCrypto().prepareToEncrypt(room);\n   * ```\n   */\n  prepareToEncrypt(room) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    this.cryptoBackend.prepareToEncrypt(room);\n  }\n\n  /**\n   * Checks if the user has previously published cross-signing keys\n   *\n   * This means downloading the devicelist for the user and checking if the list includes\n   * the cross-signing pseudo-device.\n   *\n   * @deprecated Prefer {@link CryptoApi.userHasCrossSigningKeys | `CryptoApi.userHasCrossSigningKeys`}:\n   *\n   * ```javascript\n   * result = client.getCrypto().userHasCrossSigningKeys();\n   * ```\n   */\n  userHasCrossSigningKeys() {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.userHasCrossSigningKeys();\n  }\n\n  /**\n   * Checks whether cross signing:\n   * - is enabled on this account and trusted by this device\n   * - has private keys either cached locally or stored in secret storage\n   *\n   * If this function returns false, bootstrapCrossSigning() can be used\n   * to fix things such that it returns true. That is to say, after\n   * bootstrapCrossSigning() completes successfully, this function should\n   * return true.\n   * @returns True if cross-signing is ready to be used on this device\n   * @deprecated Prefer {@link CryptoApi.isCrossSigningReady | `CryptoApi.isCrossSigningReady`}:\n   */\n  isCrossSigningReady() {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.isCrossSigningReady();\n  }\n\n  /**\n   * Bootstrap cross-signing by creating keys if needed. If everything is already\n   * set up, then no changes are made, so this is safe to run to ensure\n   * cross-signing is ready for use.\n   *\n   * This function:\n   * - creates new cross-signing keys if they are not found locally cached nor in\n   *   secret storage (if it has been set up)\n   *\n   * @deprecated Prefer {@link CryptoApi.bootstrapCrossSigning | `CryptoApi.bootstrapCrossSigning`}.\n   */\n  bootstrapCrossSigning(opts) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.bootstrapCrossSigning(opts);\n  }\n\n  /**\n   * Whether to trust a others users signatures of their devices.\n   * If false, devices will only be considered 'verified' if we have\n   * verified that device individually (effectively disabling cross-signing).\n   *\n   * Default: true\n   *\n   * @returns True if trusting cross-signed devices\n   *\n   * @deprecated Prefer {@link CryptoApi.getTrustCrossSignedDevices | `CryptoApi.getTrustCrossSignedDevices`}.\n   */\n  getCryptoTrustCrossSignedDevices() {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.getTrustCrossSignedDevices();\n  }\n\n  /**\n   * See getCryptoTrustCrossSignedDevices\n   *\n   * @param val - True to trust cross-signed devices\n   *\n   * @deprecated Prefer {@link CryptoApi.setTrustCrossSignedDevices | `CryptoApi.setTrustCrossSignedDevices`}.\n   */\n  setCryptoTrustCrossSignedDevices(val) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    this.cryptoBackend.setTrustCrossSignedDevices(val);\n  }\n\n  /**\n   * Counts the number of end to end session keys that are waiting to be backed up\n   * @returns Promise which resolves to the number of sessions requiring backup\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  countSessionsNeedingBackup() {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.countSessionsNeedingBackup();\n  }\n\n  /**\n   * Get information about the encryption of an event\n   *\n   * @param event - event to be checked\n   * @returns The event information.\n   * @deprecated Prefer {@link Crypto.CryptoApi.getEncryptionInfoForEvent | `CryptoApi.getEncryptionInfoForEvent`}.\n   */\n  getEventEncryptionInfo(event) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.getEventEncryptionInfo(event);\n  }\n\n  /**\n   * Create a recovery key from a user-supplied passphrase.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param password - Passphrase string that can be entered by the user\n   *     when restoring the backup as an alternative to entering the recovery key.\n   *     Optional.\n   * @returns Object with public key metadata, encoded private\n   *     recovery key which should be disposed of after displaying to the user,\n   *     and raw private key to avoid round tripping if needed.\n   *\n   * @deprecated Prefer {@link CryptoApi.createRecoveryKeyFromPassphrase | `CryptoApi.createRecoveryKeyFromPassphrase`}.\n   */\n  createRecoveryKeyFromPassphrase(password) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.createRecoveryKeyFromPassphrase(password);\n  }\n\n  /**\n   * Checks whether secret storage:\n   * - is enabled on this account\n   * - is storing cross-signing private keys\n   * - is storing session backup key (if enabled)\n   *\n   * If this function returns false, bootstrapSecretStorage() can be used\n   * to fix things such that it returns true. That is to say, after\n   * bootstrapSecretStorage() completes successfully, this function should\n   * return true.\n   *\n   * @returns True if secret storage is ready to be used on this device\n   * @deprecated Prefer {@link CryptoApi.isSecretStorageReady | `CryptoApi.isSecretStorageReady`}.\n   */\n  isSecretStorageReady() {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.isSecretStorageReady();\n  }\n\n  /**\n   * Bootstrap Secure Secret Storage if needed by creating a default key. If everything is\n   * already set up, then no changes are made, so this is safe to run to ensure secret\n   * storage is ready for use.\n   *\n   * This function\n   * - creates a new Secure Secret Storage key if no default key exists\n   *   - if a key backup exists, it is migrated to store the key in the Secret\n   *     Storage\n   * - creates a backup if none exists, and one is requested\n   * - migrates Secure Secret Storage to use the latest algorithm, if an outdated\n   *   algorithm is found\n   *\n   * @deprecated Use {@link CryptoApi.bootstrapSecretStorage | `CryptoApi.bootstrapSecretStorage`}.\n   */\n  bootstrapSecretStorage(opts) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.bootstrapSecretStorage(opts);\n  }\n\n  /**\n   * Add a key for encrypting secrets.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param algorithm - the algorithm used by the key\n   * @param opts - the options for the algorithm.  The properties used\n   *     depend on the algorithm given.\n   * @param keyName - the name of the key.  If not given, a random name will be generated.\n   *\n   * @returns An object with:\n   *     keyId: the ID of the key\n   *     keyInfo: details about the key (iv, mac, passphrase)\n   *\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#addKey}.\n   */\n  addSecretStorageKey(algorithm, opts, keyName) {\n    return this.secretStorage.addKey(algorithm, opts, keyName);\n  }\n\n  /**\n   * Check whether we have a key with a given ID.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param keyId - The ID of the key to check\n   *     for. Defaults to the default key ID if not provided.\n   * @returns Whether we have the key.\n   *\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#hasKey}.\n   */\n  hasSecretStorageKey(keyId) {\n    return this.secretStorage.hasKey(keyId);\n  }\n\n  /**\n   * Store an encrypted secret on the server.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param name - The name of the secret\n   * @param secret - The secret contents.\n   * @param keys - The IDs of the keys to use to encrypt the secret or null/undefined\n   *     to use the default (will throw if no default key is set).\n   *\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#store}.\n   */\n  storeSecret(name, secret, keys) {\n    return this.secretStorage.store(name, secret, keys);\n  }\n\n  /**\n   * Get a secret from storage.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param name - the name of the secret\n   *\n   * @returns the contents of the secret\n   *\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#get}.\n   */\n  getSecret(name) {\n    return this.secretStorage.get(name);\n  }\n\n  /**\n   * Check if a secret is stored on the server.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param name - the name of the secret\n   * @returns map of key name to key info the secret is encrypted\n   *     with, or null if it is not present or not encrypted with a trusted\n   *     key\n   *\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#isStored}.\n   */\n  isSecretStored(name) {\n    return this.secretStorage.isStored(name);\n  }\n\n  /**\n   * Request a secret from another device.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param name - the name of the secret to request\n   * @param devices - the devices to request the secret from\n   *\n   * @returns the secret request object\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  requestSecret(name, devices) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.requestSecret(name, devices);\n  }\n\n  /**\n   * Get the current default key ID for encrypting secrets.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @returns The default key ID or null if no default key ID is set\n   *\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#getDefaultKeyId}.\n   */\n  getDefaultSecretStorageKeyId() {\n    return this.secretStorage.getDefaultKeyId();\n  }\n\n  /**\n   * Set the current default key ID for encrypting secrets.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param keyId - The new default key ID\n   *\n   * @deprecated Use {@link MatrixClient#secretStorage} and {@link SecretStorage.ServerSideSecretStorage#setDefaultKeyId}.\n   */\n  setDefaultSecretStorageKeyId(keyId) {\n    return this.secretStorage.setDefaultKeyId(keyId);\n  }\n\n  /**\n   * Checks that a given secret storage private key matches a given public key.\n   * This can be used by the getSecretStorageKey callback to verify that the\n   * private key it is about to supply is the one that was requested.\n   *\n   * The Secure Secret Storage API is currently UNSTABLE and may change without notice.\n   *\n   * @param privateKey - The private key\n   * @param expectedPublicKey - The public key\n   * @returns true if the key matches, otherwise false\n   *\n   * @deprecated The use of asymmetric keys for SSSS is deprecated.\n   *     Use {@link SecretStorage.ServerSideSecretStorage#checkKey} for symmetric keys.\n   */\n  checkSecretStoragePrivateKey(privateKey, expectedPublicKey) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.checkSecretStoragePrivateKey(privateKey, expectedPublicKey);\n  }\n\n  /**\n   * Get e2e information on the device that sent an event\n   *\n   * @param event - event to be checked\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  getEventSenderDeviceInfo(event) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this15.crypto) {\n        return null;\n      }\n      return _this15.crypto.getEventSenderDeviceInfo(event);\n    })();\n  }\n\n  /**\n   * Check if the sender of an event is verified\n   *\n   * @param event - event to be checked\n   *\n   * @returns true if the sender of this event has been verified using\n   * {@link MatrixClient#setDeviceVerified}.\n   */\n  isEventSenderVerified(event) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      var device = yield _this16.getEventSenderDeviceInfo(event);\n      if (!device) {\n        return false;\n      }\n      return device.isVerified();\n    })();\n  }\n\n  /**\n   * Get outgoing room key request for this event if there is one.\n   * @param event - The event to check for\n   *\n   * @returns A room key request, or null if there is none\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  getOutgoingRoomKeyRequest(event) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-End encryption disabled\");\n    }\n    var wireContent = event.getWireContent();\n    var requestBody = {\n      session_id: wireContent.session_id,\n      sender_key: wireContent.sender_key,\n      algorithm: wireContent.algorithm,\n      room_id: event.getRoomId()\n    };\n    if (!requestBody.session_id || !requestBody.sender_key || !requestBody.algorithm || !requestBody.room_id) {\n      return Promise.resolve(null);\n    }\n    return this.crypto.cryptoStore.getOutgoingRoomKeyRequest(requestBody);\n  }\n\n  /**\n   * Cancel a room key request for this event if one is ongoing and resend the\n   * request.\n   * @param event - event of which to cancel and resend the room\n   *                            key request.\n   * @returns A promise that will resolve when the key request is queued\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  cancelAndResendEventRoomKeyRequest(event) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-End encryption disabled\");\n    }\n    return event.cancelAndResendKeyRequest(this.crypto, this.getUserId());\n  }\n\n  /**\n   * Enable end-to-end encryption for a room. This does not modify room state.\n   * Any messages sent before the returned promise resolves will be sent unencrypted.\n   * @param roomId - The room ID to enable encryption in.\n   * @param config - The encryption config for the room.\n   * @returns A promise that will resolve when encryption is set up.\n   *\n   * @deprecated Not supported for Rust Cryptography. To enable encryption in a room, send an `m.room.encryption`\n   * state event.\n   */\n  setRoomEncryption(roomId, config) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-End encryption disabled\");\n    }\n    return this.crypto.setRoomEncryption(roomId, config);\n  }\n\n  /**\n   * Whether encryption is enabled for a room.\n   * @param roomId - the room id to query.\n   * @returns whether encryption is enabled.\n   *\n   * @deprecated Not correctly supported for Rust Cryptography. Use {@link CryptoApi.isEncryptionEnabledInRoom} and/or\n   *    {@link Room.hasEncryptionStateEvent}.\n   */\n  isRoomEncrypted(roomId) {\n    var _this$crypto$isRoomEn, _this$crypto3;\n    var room = this.getRoom(roomId);\n    if (!room) {\n      // we don't know about this room, so can't determine if it should be\n      // encrypted. Let's assume not.\n      return false;\n    }\n\n    // if there is an 'm.room.encryption' event in this room, it should be\n    // encrypted (independently of whether we actually support encryption)\n    if (room.hasEncryptionStateEvent()) {\n      return true;\n    }\n\n    // we don't have an m.room.encrypted event, but that might be because\n    // the server is hiding it from us. Check the store to see if it was\n    // previously encrypted.\n    return (_this$crypto$isRoomEn = (_this$crypto3 = this.crypto) === null || _this$crypto3 === void 0 ? void 0 : _this$crypto3.isRoomEncrypted(roomId)) !== null && _this$crypto$isRoomEn !== void 0 ? _this$crypto$isRoomEn : false;\n  }\n\n  /**\n   * Encrypts and sends a given object via Olm to-device messages to a given\n   * set of devices.\n   *\n   * @param userDeviceInfoArr - list of deviceInfo objects representing the devices to send to\n   *\n   * @param payload - fields to include in the encrypted payload\n   *\n   * @returns Promise which\n   *     resolves once the message has been encrypted and sent to the given\n   *     userDeviceMap, and returns the `{ contentMap, deviceInfoByDeviceId }`\n   *     of the successfully sent messages.\n   *\n   * @deprecated Instead use {@link CryptoApi.encryptToDeviceMessages} followed by {@link queueToDevice}.\n   */\n  encryptAndSendToDevices(userDeviceInfoArr, payload) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-End encryption disabled\");\n    }\n    return this.crypto.encryptAndSendToDevices(userDeviceInfoArr, payload);\n  }\n\n  /**\n   * Forces the current outbound group session to be discarded such\n   * that another one will be created next time an event is sent.\n   *\n   * @param roomId - The ID of the room to discard the session for\n   *\n   * @deprecated Prefer {@link CryptoApi.forceDiscardSession | `CryptoApi.forceDiscardSession`}:\n   */\n  forceDiscardSession(roomId) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-End encryption disabled\");\n    }\n    this.cryptoBackend.forceDiscardSession(roomId);\n  }\n\n  /**\n   * Get a list containing all of the room keys\n   *\n   * This should be encrypted before returning it to the user.\n   *\n   * @returns a promise which resolves to a list of session export objects\n   *\n   * @deprecated Prefer {@link CryptoApi.exportRoomKeys | `CryptoApi.exportRoomKeys`}:\n   *\n   * ```javascript\n   * sessionData = await client.getCrypto().exportRoomKeys();\n   * ```\n   */\n  exportRoomKeys() {\n    if (!this.cryptoBackend) {\n      return Promise.reject(new Error(\"End-to-end encryption disabled\"));\n    }\n    return this.cryptoBackend.exportRoomKeys();\n  }\n\n  /**\n   * Import a list of room keys previously exported by exportRoomKeys\n   *\n   * @param keys - a list of session export objects\n   * @param opts - options object\n   *\n   * @returns a promise which resolves when the keys have been imported\n   *\n   * @deprecated Prefer {@link CryptoApi.importRoomKeys | `CryptoApi.importRoomKeys`}:\n   * ```javascript\n   *  await client.getCrypto()?.importRoomKeys([..]);\n   * ```\n   */\n  importRoomKeys(keys, opts) {\n    if (!this.cryptoBackend) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.cryptoBackend.importRoomKeys(keys, opts);\n  }\n\n  /**\n   * Force a re-check of the local key backup status against\n   * what's on the server.\n   *\n   * @returns Object with backup info (as returned by\n   *     getKeyBackupVersion) in backupInfo and\n   *     trust information (as returned by isKeyBackupTrusted)\n   *     in trustInfo.\n   *\n   * @deprecated Prefer {@link Crypto.CryptoApi.checkKeyBackupAndEnable}.\n   */\n  checkKeyBackup() {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.backupManager.checkKeyBackup();\n  }\n\n  /**\n   * Get information about the current key backup from the server.\n   *\n   * Performs some basic validity checks on the shape of the result, and raises an error if it is not as expected.\n   *\n   * **Note**: there is no (supported) way to distinguish between \"failure to talk to the server\" and \"another client\n   * uploaded a key backup version using an algorithm I don't understand.\n   *\n   * @returns Information object from API, or null if no backup is present on the server.\n   */\n  getKeyBackupVersion() {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      var res;\n      try {\n        res = yield _this17.http.authedRequest(Method.Get, \"/room_keys/version\", undefined, undefined, {\n          prefix: ClientPrefix.V3\n        });\n      } catch (e) {\n        if (e.errcode === \"M_NOT_FOUND\") {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n      BackupManager.checkBackupVersion(res);\n      return res;\n    })();\n  }\n\n  /**\n   * @param info - key backup info dict from getKeyBackupVersion()\n   *\n   * @deprecated Not supported for Rust Cryptography. Prefer {@link CryptoApi.isKeyBackupTrusted | `CryptoApi.isKeyBackupTrusted`}.\n   */\n  isKeyBackupTrusted(info) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.backupManager.isKeyBackupTrusted(info);\n  }\n\n  /**\n   * @returns true if the client is configured to back up keys to\n   *     the server, otherwise false. If we haven't completed a successful check\n   *     of key backup status yet, returns null.\n   *\n   * @deprecated Not supported for Rust Cryptography. Prefer direct access to {@link Crypto.CryptoApi.getActiveSessionBackupVersion}:\n   *\n   * ```javascript\n   * let enabled = (await client.getCrypto().getActiveSessionBackupVersion()) !== null;\n   * ```\n   */\n  getKeyBackupEnabled() {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.backupManager.getKeyBackupEnabled();\n  }\n\n  /**\n   * Enable backing up of keys, using data previously returned from\n   * getKeyBackupVersion.\n   *\n   * @param info - Backup information object as returned by getKeyBackupVersion\n   * @returns Promise which resolves when complete.\n   *\n   * @deprecated Do not call this directly. Instead call {@link Crypto.CryptoApi.checkKeyBackupAndEnable}.\n   */\n  enableKeyBackup(info) {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.backupManager.enableKeyBackup(info);\n  }\n\n  /**\n   * Disable backing up of keys.\n   *\n   * @deprecated Not supported for Rust Cryptography. It should be unnecessary to disable key backup.\n   */\n  disableKeyBackup() {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    this.crypto.backupManager.disableKeyBackup();\n  }\n\n  /**\n   * Set up the data required to create a new backup version.  The backup version\n   * will not be created and enabled until createKeyBackupVersion is called.\n   *\n   * @param password - Passphrase string that can be entered by the user\n   *     when restoring the backup as an alternative to entering the recovery key.\n   *     Optional.\n   *\n   * @returns Object that can be passed to createKeyBackupVersion and\n   *     additionally has a 'recovery_key' member with the user-facing recovery key string.\n   *\n   * @deprecated Not supported for Rust cryptography. Use {@link Crypto.CryptoApi.resetKeyBackup | `CryptoApi.resetKeyBackup`}.\n   */\n  prepareKeyBackupVersion(password) {\n    var _arguments2 = arguments,\n      _this18 = this;\n    return _asyncToGenerator(function* () {\n      var opts = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {\n        secureSecretStorage: false\n      };\n      if (!_this18.crypto) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n\n      // eslint-disable-next-line camelcase\n      var {\n        algorithm,\n        auth_data,\n        recovery_key,\n        privateKey\n      } = yield _this18.crypto.backupManager.prepareKeyBackupVersion(password);\n      if (opts.secureSecretStorage) {\n        yield _this18.secretStorage.store(\"m.megolm_backup.v1\", encodeBase64(privateKey));\n        _this18.logger.info(\"Key backup private key stored in secret storage\");\n      }\n      return {\n        algorithm,\n        /* eslint-disable camelcase */\n        auth_data,\n        recovery_key\n        /* eslint-enable camelcase */\n      };\n    })();\n  }\n\n  /**\n   * Check whether the key backup private key is stored in secret storage.\n   * @returns map of key name to key info the secret is\n   *     encrypted with, or null if it is not present or not encrypted with a\n   *     trusted key\n   */\n  isKeyBackupKeyStored() {\n    return Promise.resolve(this.secretStorage.isStored(\"m.megolm_backup.v1\"));\n  }\n\n  /**\n   * Create a new key backup version and enable it, using the information return\n   * from prepareKeyBackupVersion.\n   *\n   * @param info - Info object from prepareKeyBackupVersion\n   * @returns Object with 'version' param indicating the version created\n   *\n   * @deprecated Use {@link Crypto.CryptoApi.resetKeyBackup | `CryptoApi.resetKeyBackup`}.\n   */\n  createKeyBackupVersion(info) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this19.crypto) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      yield _this19.crypto.backupManager.createKeyBackupVersion(info);\n      var data = {\n        algorithm: info.algorithm,\n        auth_data: info.auth_data\n      };\n\n      // Sign the backup auth data with the device key for backwards compat with\n      // older devices with cross-signing. This can probably go away very soon in\n      // favour of just signing with the cross-singing master key.\n      // XXX: Private member access\n      yield _this19.crypto.signObject(data.auth_data);\n      if (_this19.cryptoCallbacks.getCrossSigningKey &&\n      // XXX: Private member access\n      _this19.crypto.crossSigningInfo.getId()) {\n        // now also sign the auth data with the cross-signing master key\n        // we check for the callback explicitly here because we still want to be able\n        // to create an un-cross-signed key backup if there is a cross-signing key but\n        // no callback supplied.\n        // XXX: Private member access\n        yield _this19.crypto.crossSigningInfo.signObject(data.auth_data, \"master\");\n      }\n      var res = yield _this19.http.authedRequest(Method.Post, \"/room_keys/version\", undefined, data);\n\n      // We could assume everything's okay and enable directly, but this ensures\n      // we run the same signature verification that will be used for future\n      // sessions.\n      yield _this19.checkKeyBackup();\n      if (!_this19.getKeyBackupEnabled()) {\n        _this19.logger.error(\"Key backup not usable even though we just created it\");\n      }\n      return res;\n    })();\n  }\n\n  /**\n   * @deprecated Use {@link Crypto.CryptoApi.deleteKeyBackupVersion | `CryptoApi.deleteKeyBackupVersion`}.\n   */\n  deleteKeyBackupVersion(version) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this20.cryptoBackend) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      yield _this20.cryptoBackend.deleteKeyBackupVersion(version);\n    })();\n  }\n  makeKeyBackupPath(roomId, sessionId, version) {\n    var path;\n    if (sessionId !== undefined) {\n      path = utils.encodeUri(\"/room_keys/keys/$roomId/$sessionId\", {\n        $roomId: roomId,\n        $sessionId: sessionId\n      });\n    } else if (roomId !== undefined) {\n      path = utils.encodeUri(\"/room_keys/keys/$roomId\", {\n        $roomId: roomId\n      });\n    } else {\n      path = \"/room_keys/keys\";\n    }\n    var queryData = version === undefined ? undefined : {\n      version\n    };\n    return {\n      path,\n      queryData\n    };\n  }\n\n  /**\n   * Back up session keys to the homeserver.\n   * @param roomId - ID of the room that the keys are for Optional.\n   * @param sessionId - ID of the session that the keys are for Optional.\n   * @param version - backup version Optional.\n   * @param data - Object keys to send\n   * @returns a promise that will resolve when the keys\n   * are uploaded\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n\n  sendKeyBackup(roomId, sessionId, version, data) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this21.crypto) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      var path = _this21.makeKeyBackupPath(roomId, sessionId, version);\n      yield _this21.http.authedRequest(Method.Put, path.path, path.queryData, data, {\n        prefix: ClientPrefix.V3\n      });\n    })();\n  }\n\n  /**\n   * Marks all group sessions as needing to be backed up and schedules them to\n   * upload in the background as soon as possible.\n   *\n   * @deprecated Not supported for Rust Cryptography. This is done automatically as part of\n   * {@link CryptoApi.resetKeyBackup}, so there is probably no need to call this manually.\n   */\n  scheduleAllGroupSessionsForBackup() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this22.crypto) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      yield _this22.crypto.backupManager.scheduleAllGroupSessionsForBackup();\n    })();\n  }\n\n  /**\n   * Marks all group sessions as needing to be backed up without scheduling\n   * them to upload in the background.\n   *\n   * (This is done automatically as part of {@link CryptoApi.resetKeyBackup},\n   * so there is probably no need to call this manually.)\n   *\n   * @returns Promise which resolves to the number of sessions requiring a backup.\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  flagAllGroupSessionsForBackup() {\n    if (!this.crypto) {\n      throw new Error(\"End-to-end encryption disabled\");\n    }\n    return this.crypto.backupManager.flagAllGroupSessionsForBackup();\n  }\n\n  /**\n   * Return true if recovery key is valid.\n   * Try to decode the recovery key and check if it's successful.\n   * @param recoveryKey\n   * @deprecated Use {@link decodeRecoveryKey} directly\n   */\n  isValidRecoveryKey(recoveryKey) {\n    try {\n      decodeRecoveryKey(recoveryKey);\n      return true;\n    } catch (_unused2) {\n      return false;\n    }\n  }\n\n  /**\n   * Get the raw key for a key backup from the password\n   * Used when migrating key backups into SSSS\n   *\n   * The cross-signing API is currently UNSTABLE and may change without notice.\n   *\n   * @param password - Passphrase\n   * @param backupInfo - Backup metadata from `checkKeyBackup`\n   * @returns key backup key\n   * @deprecated Deriving a backup key from a passphrase is not part of the matrix spec. Instead, a random key is generated and stored/shared via 4S.\n   */\n  keyBackupKeyFromPassword(password, backupInfo) {\n    return keyFromAuthData(backupInfo.auth_data, password);\n  }\n\n  /**\n   * Get the raw key for a key backup from the recovery key\n   * Used when migrating key backups into SSSS\n   *\n   * The cross-signing API is currently UNSTABLE and may change without notice.\n   *\n   * @param recoveryKey - The recovery key\n   * @returns key backup key\n   * @deprecated Use {@link decodeRecoveryKey} directly\n   */\n  keyBackupKeyFromRecoveryKey(recoveryKey) {\n    return decodeRecoveryKey(recoveryKey);\n  }\n\n  /**\n   * Restore from an existing key backup via a passphrase.\n   *\n   * @param password - Passphrase\n   * @param targetRoomId - Room ID to target a specific room.\n   * Restores all rooms if omitted.\n   * @param targetSessionId - Session ID to target a specific session.\n   * Restores all sessions if omitted.\n   * @param backupInfo - Backup metadata from `getKeyBackupVersion` or `checkKeyBackup`.`backupInfo`\n   * @param opts - Optional params such as callbacks\n   * @returns Status of restoration with `total` and `imported`\n   * key counts.\n   */\n\n  restoreKeyBackupWithPassword(password, targetRoomId, targetSessionId, backupInfo, opts) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      var privKey = yield keyFromAuthData(backupInfo.auth_data, password);\n      return _this23.restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts);\n    })();\n  }\n\n  /**\n   * Restore from an existing key backup via a private key stored in secret\n   * storage.\n   *\n   * @param backupInfo - Backup metadata from `checkKeyBackup`\n   * @param targetRoomId - Room ID to target a specific room.\n   * Restores all rooms if omitted.\n   * @param targetSessionId - Session ID to target a specific session.\n   * Restores all sessions if omitted.\n   * @param opts - Optional params such as callbacks\n   * @returns Status of restoration with `total` and `imported`\n   * key counts.\n   */\n  restoreKeyBackupWithSecretStorage(backupInfo, targetRoomId, targetSessionId, opts) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this24.cryptoBackend) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      var storedKey = yield _this24.secretStorage.get(\"m.megolm_backup.v1\");\n\n      // ensure that the key is in the right format.  If not, fix the key and\n      // store the fixed version\n      var fixedKey = fixBackupKey(storedKey);\n      if (fixedKey) {\n        var keys = yield _this24.secretStorage.getKey();\n        yield _this24.secretStorage.store(\"m.megolm_backup.v1\", fixedKey, [keys[0]]);\n      }\n      var privKey = decodeBase64(fixedKey || storedKey);\n      return _this24.restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts);\n    })();\n  }\n\n  /**\n   * Restore from an existing key backup via an encoded recovery key.\n   *\n   * @param recoveryKey - Encoded recovery key\n   * @param targetRoomId - Room ID to target a specific room.\n   * Restores all rooms if omitted.\n   * @param targetSessionId - Session ID to target a specific session.\n   * Restores all sessions if omitted.\n   * @param backupInfo - Backup metadata from `checkKeyBackup`\n   * @param opts - Optional params such as callbacks\n    * @returns Status of restoration with `total` and `imported`\n   * key counts.\n   */\n\n  restoreKeyBackupWithRecoveryKey(recoveryKey, targetRoomId, targetSessionId, backupInfo, opts) {\n    var privKey = decodeRecoveryKey(recoveryKey);\n    return this.restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts);\n  }\n  restoreKeyBackupWithCache(targetRoomId, targetSessionId, backupInfo, opts) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this25.cryptoBackend) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      var privKey = yield _this25.cryptoBackend.getSessionBackupPrivateKey();\n      if (!privKey) {\n        throw new Error(\"Couldn't get key\");\n      }\n      return _this25.restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts);\n    })();\n  }\n  restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      var cacheCompleteCallback = opts === null || opts === void 0 ? void 0 : opts.cacheCompleteCallback;\n      var progressCallback = opts === null || opts === void 0 ? void 0 : opts.progressCallback;\n      if (!_this26.cryptoBackend) {\n        throw new Error(\"End-to-end encryption disabled\");\n      }\n      if (!backupInfo.version) {\n        throw new Error(\"Backup version must be defined\");\n      }\n      var backupVersion = backupInfo.version;\n      var totalKeyCount = 0;\n      var totalFailures = 0;\n      var totalImported = 0;\n      var path = _this26.makeKeyBackupPath(targetRoomId, targetSessionId, backupVersion);\n      var backupDecryptor = yield _this26.cryptoBackend.getBackupDecryptor(backupInfo, privKey);\n      var untrusted = !backupDecryptor.sourceTrusted;\n      try {\n        if (!(privKey instanceof Uint8Array)) {\n          // eslint-disable-next-line @typescript-eslint/no-base-to-string\n          throw new Error(\"restoreKeyBackup expects Uint8Array, got \".concat(privKey));\n        }\n        // Cache the key, if possible.\n        // This is async.\n        _this26.cryptoBackend.storeSessionBackupPrivateKey(privKey, backupVersion).catch(e => {\n          _this26.logger.warn(\"Error caching session backup key:\", e);\n        }).then(cacheCompleteCallback);\n        if (progressCallback) {\n          progressCallback({\n            stage: \"fetch\"\n          });\n        }\n        var res = yield _this26.http.authedRequest(Method.Get, path.path, path.queryData, undefined, {\n          prefix: ClientPrefix.V3\n        });\n\n        // We have finished fetching the backup, go to next step\n        if (progressCallback) {\n          progressCallback({\n            stage: \"load_keys\"\n          });\n        }\n        if (res.rooms) {\n          // We have a full backup here, it can get quite big, so we need to decrypt and import it in chunks.\n\n          // Get the total count as a first pass\n          totalKeyCount = _this26.getTotalKeyCount(res);\n          // Now decrypt and import the keys in chunks\n          yield _this26.handleDecryptionOfAFullBackup(res, backupDecryptor, 200, /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(function* (chunk) {\n              // We have a chunk of decrypted keys: import them\n              try {\n                var _backupVersion = backupInfo.version;\n                yield _this26.cryptoBackend.importBackedUpRoomKeys(chunk, _backupVersion, {\n                  untrusted\n                });\n                totalImported += chunk.length;\n              } catch (e) {\n                totalFailures += chunk.length;\n                // We failed to import some keys, but we should still try to import the rest?\n                // Log the error and continue\n                logger.error(\"Error importing keys from backup\", e);\n              }\n              if (progressCallback) {\n                progressCallback({\n                  total: totalKeyCount,\n                  successes: totalImported,\n                  stage: \"load_keys\",\n                  failures: totalFailures\n                });\n              }\n            });\n            return function (_x2) {\n              return _ref3.apply(this, arguments);\n            };\n          }());\n        } else if (res.sessions) {\n          // For now we don't chunk for a single room backup, but we could in the future.\n          // Currently it is not used by the application.\n          var sessions = res.sessions;\n          totalKeyCount = Object.keys(sessions).length;\n          var keys = yield backupDecryptor.decryptSessions(sessions);\n          for (var _k of keys) {\n            _k.room_id = targetRoomId;\n          }\n          yield _this26.cryptoBackend.importBackedUpRoomKeys(keys, backupVersion, {\n            progressCallback,\n            untrusted\n          });\n          totalImported = keys.length;\n        } else {\n          totalKeyCount = 1;\n          try {\n            var [_key2] = yield backupDecryptor.decryptSessions({\n              [targetSessionId]: res\n            });\n            _key2.room_id = targetRoomId;\n            _key2.session_id = targetSessionId;\n            yield _this26.cryptoBackend.importBackedUpRoomKeys([_key2], backupVersion, {\n              progressCallback,\n              untrusted\n            });\n            totalImported = 1;\n          } catch (e) {\n            _this26.logger.debug(\"Failed to decrypt megolm session from backup\", e);\n          }\n        }\n      } finally {\n        backupDecryptor.free();\n      }\n\n      /// in case entering the passphrase would add a new signature?\n      yield _this26.cryptoBackend.checkKeyBackupAndEnable();\n      return {\n        total: totalKeyCount,\n        imported: totalImported\n      };\n    })();\n  }\n\n  /**\n   * This method calculates the total number of keys present in the response of a `/room_keys/keys` call.\n   *\n   * @param res - The response from the server containing the keys to be counted.\n   *\n   * @returns The total number of keys in the backup.\n   */\n  getTotalKeyCount(res) {\n    var rooms = res.rooms;\n    var totalKeyCount = 0;\n    for (var roomData of Object.values(rooms)) {\n      if (!roomData.sessions) continue;\n      totalKeyCount += Object.keys(roomData.sessions).length;\n    }\n    return totalKeyCount;\n  }\n\n  /**\n   * This method handles the decryption of a full backup, i.e a call to `/room_keys/keys`.\n   * It will decrypt the keys in chunks and call the `block` callback for each chunk.\n   *\n   * @param res - The response from the server containing the keys to be decrypted.\n   * @param backupDecryptor - An instance of the BackupDecryptor class used to decrypt the keys.\n   * @param chunkSize - The size of the chunks to be processed at a time.\n   * @param block - A callback function that is called for each chunk of keys.\n   *\n   * @returns A promise that resolves when the decryption is complete.\n   */\n  handleDecryptionOfAFullBackup(res, backupDecryptor, chunkSize, block) {\n    return _asyncToGenerator(function* () {\n      var rooms = res.rooms;\n      var groupChunkCount = 0;\n      var chunkGroupByRoom = new Map();\n      var handleChunkCallback = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (roomChunks) {\n          var currentChunk = [];\n          for (var _roomId of roomChunks.keys()) {\n            var decryptedSessions = yield backupDecryptor.decryptSessions(roomChunks.get(_roomId));\n            for (var _sessionId in decryptedSessions) {\n              var _k2 = decryptedSessions[_sessionId];\n              _k2.room_id = _roomId;\n              currentChunk.push(_k2);\n            }\n          }\n          yield block(currentChunk);\n        });\n        return function handleChunkCallback(_x3) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      for (var [_roomId2, roomData] of Object.entries(rooms)) {\n        if (!roomData.sessions) continue;\n        chunkGroupByRoom.set(_roomId2, {});\n        for (var [_sessionId2, session] of Object.entries(roomData.sessions)) {\n          var sessionsForRoom = chunkGroupByRoom.get(_roomId2);\n          sessionsForRoom[_sessionId2] = session;\n          groupChunkCount += 1;\n          if (groupChunkCount >= chunkSize) {\n            // We have enough chunks to decrypt\n            yield handleChunkCallback(chunkGroupByRoom);\n            chunkGroupByRoom = new Map();\n            // There might be remaining keys for that room, so add back an entry for the current room.\n            chunkGroupByRoom.set(_roomId2, {});\n            groupChunkCount = 0;\n          }\n        }\n      }\n\n      // Handle remaining chunk if needed\n      if (groupChunkCount > 0) {\n        yield handleChunkCallback(chunkGroupByRoom);\n      }\n    })();\n  }\n  deleteKeysFromBackup(roomId, sessionId, version) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      var path = _this27.makeKeyBackupPath(roomId, sessionId, version);\n      yield _this27.http.authedRequest(Method.Delete, path.path, path.queryData, undefined, {\n        prefix: ClientPrefix.V3\n      });\n    })();\n  }\n\n  /**\n   * Get the config for the media repository.\n   * @returns Promise which resolves with an object containing the config.\n   */\n  getMediaConfig() {\n    return this.http.authedRequest(Method.Get, \"/config\", undefined, undefined, {\n      prefix: MediaPrefix.V3\n    });\n  }\n\n  /**\n   * Get the room for the given room ID.\n   * This function will return a valid room for any room for which a Room event\n   * has been emitted. Note in particular that other events, eg. RoomState.members\n   * will be emitted for a room before this function will return the given room.\n   * @param roomId - The room ID\n   * @returns The Room or null if it doesn't exist or there is no data store.\n   */\n  getRoom(roomId) {\n    if (!roomId) {\n      return null;\n    }\n    return this.store.getRoom(roomId);\n  }\n\n  /**\n   * Retrieve all known rooms.\n   * @returns A list of rooms, or an empty list if there is no data store.\n   */\n  getRooms() {\n    return this.store.getRooms();\n  }\n\n  /**\n   * Retrieve all rooms that should be displayed to the user\n   * This is essentially getRooms() with some rooms filtered out, eg. old versions\n   * of rooms that have been replaced or (in future) other rooms that have been\n   * marked at the protocol level as not to be displayed to the user.\n   *\n   * @param msc3946ProcessDynamicPredecessor - if true, look for an\n   *                                           m.room.predecessor state event and\n   *                                           use it if found (MSC3946).\n   * @returns A list of rooms, or an empty list if there is no data store.\n   */\n  getVisibleRooms() {\n    var msc3946ProcessDynamicPredecessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var allRooms = this.store.getRooms();\n    var replacedRooms = new Set();\n    for (var r of allRooms) {\n      var _r$findPredecessor;\n      var predecessor = (_r$findPredecessor = r.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _r$findPredecessor === void 0 ? void 0 : _r$findPredecessor.roomId;\n      if (predecessor) {\n        replacedRooms.add(predecessor);\n      }\n    }\n    return allRooms.filter(r => {\n      var tombstone = r.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n      if (tombstone && replacedRooms.has(r.roomId)) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Retrieve a user.\n   * @param userId - The user ID to retrieve.\n   * @returns A user or null if there is no data store or the user does\n   * not exist.\n   */\n  getUser(userId) {\n    return this.store.getUser(userId);\n  }\n\n  /**\n   * Retrieve all known users.\n   * @returns A list of users, or an empty list if there is no data store.\n   */\n  getUsers() {\n    return this.store.getUsers();\n  }\n\n  /**\n   * Set account data event for the current user.\n   * It will retry the request up to 5 times.\n   * @param eventType - The event type\n   * @param content - the contents object for the event\n   * @returns Promise which resolves: an empty object\n   * @returns Rejects: with an error response.\n   */\n  setAccountData(eventType, content) {\n    var path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n      $userId: this.credentials.userId,\n      $type: eventType\n    });\n    return retryNetworkOperation(5, () => {\n      return this.http.authedRequest(Method.Put, path, undefined, content);\n    });\n  }\n\n  /**\n   * Get account data event of given type for the current user.\n   * @param eventType - The event type\n   * @returns The contents of the given account data event\n   */\n  getAccountData(eventType) {\n    return this.store.getAccountData(eventType);\n  }\n\n  /**\n   * Get account data event of given type for the current user. This variant\n   * gets account data directly from the homeserver if the local store is not\n   * ready, which can be useful very early in startup before the initial sync.\n   * @param eventType - The event type\n   * @returns Promise which resolves: The contents of the given account data event.\n   * @returns Rejects: with an error response.\n   */\n  getAccountDataFromServer(eventType) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      if (_this28.isInitialSyncComplete()) {\n        var _event = _this28.store.getAccountData(eventType);\n        if (!_event) {\n          return null;\n        }\n        // The network version below returns just the content, so this branch\n        // does the same to match.\n        return _event.getContent();\n      }\n      var path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n        $userId: _this28.credentials.userId,\n        $type: eventType\n      });\n      try {\n        return yield _this28.http.authedRequest(Method.Get, path);\n      } catch (e) {\n        var _data;\n        if (((_data = e.data) === null || _data === void 0 ? void 0 : _data.errcode) === \"M_NOT_FOUND\") {\n          return null;\n        }\n        throw e;\n      }\n    })();\n  }\n  deleteAccountData(eventType) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      var msc3391DeleteAccountDataServerSupport = _this29.canSupport.get(Feature.AccountDataDeletion);\n      // if deletion is not supported overwrite with empty content\n      if (msc3391DeleteAccountDataServerSupport === ServerSupport.Unsupported) {\n        yield _this29.setAccountData(eventType, {});\n        return;\n      }\n      var path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n        $userId: _this29.getSafeUserId(),\n        $type: eventType\n      });\n      var options = msc3391DeleteAccountDataServerSupport === ServerSupport.Unstable ? {\n        prefix: \"/_matrix/client/unstable/org.matrix.msc3391\"\n      } : undefined;\n      return yield _this29.http.authedRequest(Method.Delete, path, undefined, undefined, options);\n    })();\n  }\n\n  /**\n   * Gets the users that are ignored by this client\n   * @returns The array of users that are ignored (empty if none)\n   */\n  getIgnoredUsers() {\n    var event = this.getAccountData(\"m.ignored_user_list\");\n    if (!event || !event.getContent() || !event.getContent()[\"ignored_users\"]) return [];\n    return Object.keys(event.getContent()[\"ignored_users\"]);\n  }\n\n  /**\n   * Sets the users that the current user should ignore.\n   * @param userIds - the user IDs to ignore\n   * @returns Promise which resolves: an empty object\n   * @returns Rejects: with an error response.\n   */\n  setIgnoredUsers(userIds) {\n    var content = {\n      ignored_users: {}\n    };\n    userIds.forEach(u => {\n      content.ignored_users[u] = {};\n    });\n    return this.setAccountData(\"m.ignored_user_list\", content);\n  }\n\n  /**\n   * Gets whether or not a specific user is being ignored by this client.\n   * @param userId - the user ID to check\n   * @returns true if the user is ignored, false otherwise\n   */\n  isUserIgnored(userId) {\n    return this.getIgnoredUsers().includes(userId);\n  }\n\n  /**\n   * Join a room. If you have already joined the room, this will no-op.\n   * @param roomIdOrAlias - The room ID or room alias to join.\n   * @param opts - Options when joining the room.\n   * @returns Promise which resolves: Room object.\n   * @returns Rejects: with an error response.\n   */\n  joinRoom(roomIdOrAlias) {\n    var _arguments3 = arguments,\n      _this30 = this;\n    return _asyncToGenerator(function* () {\n      var opts = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : {};\n      if (opts.syncRoom === undefined) {\n        opts.syncRoom = true;\n      }\n      var room = _this30.getRoom(roomIdOrAlias);\n      if (room !== null && room !== void 0 && room.hasMembershipState(_this30.credentials.userId, KnownMembership.Join)) return room;\n      var signPromise = Promise.resolve();\n      if (opts.inviteSignUrl) {\n        var _url = new URL(opts.inviteSignUrl);\n        _url.searchParams.set(\"mxid\", _this30.credentials.userId);\n        signPromise = _this30.http.requestOtherUrl(Method.Post, _url);\n      }\n      var queryParams = {};\n      if (opts.viaServers) {\n        // server_name has been deprecated in favour of via with Matrix >1.11 (MSC4156)\n        queryParams.server_name = opts.viaServers;\n        queryParams.via = opts.viaServers;\n      }\n      var data = {};\n      var signedInviteObj = yield signPromise;\n      if (signedInviteObj) {\n        data.third_party_signed = signedInviteObj;\n      }\n      var path = utils.encodeUri(\"/join/$roomid\", {\n        $roomid: roomIdOrAlias\n      });\n      var res = yield _this30.http.authedRequest(Method.Post, path, queryParams, data);\n      var roomId = res.room_id;\n      // In case we were originally given an alias, check the room cache again\n      // with the resolved ID - this method is supposed to no-op if we already\n      // were in the room, after all.\n      var resolvedRoom = _this30.getRoom(roomId);\n      if (resolvedRoom !== null && resolvedRoom !== void 0 && resolvedRoom.hasMembershipState(_this30.credentials.userId, KnownMembership.Join)) return resolvedRoom;\n      var syncApi = new SyncApi(_this30, _this30.clientOpts, _this30.buildSyncApiOptions());\n      var syncRoom = syncApi.createRoom(roomId);\n      if (opts.syncRoom) {\n        // v2 will do this for us\n        // return syncApi.syncRoom(room);\n      }\n      return syncRoom;\n    })();\n  }\n\n  /**\n   * Knock a room. If you have already knocked the room, this will no-op.\n   * @param roomIdOrAlias - The room ID or room alias to knock.\n   * @param opts - Options when knocking the room.\n   * @returns Promise which resolves: `{room_id: {string}}`\n   * @returns Rejects: with an error response.\n   */\n  knockRoom(roomIdOrAlias) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var room = this.getRoom(roomIdOrAlias);\n    if (room !== null && room !== void 0 && room.hasMembershipState(this.credentials.userId, KnownMembership.Knock)) {\n      return Promise.resolve({\n        room_id: room.roomId\n      });\n    }\n    var path = utils.encodeUri(\"/knock/$roomIdOrAlias\", {\n      $roomIdOrAlias: roomIdOrAlias\n    });\n    var queryParams = {};\n    if (opts.viaServers) {\n      // server_name has been deprecated in favour of via with Matrix >1.11 (MSC4156)\n      queryParams.server_name = opts.viaServers;\n      queryParams.via = opts.viaServers;\n    }\n    var body = {};\n    if (opts.reason) {\n      body.reason = opts.reason;\n    }\n    return this.http.authedRequest(Method.Post, path, queryParams, body);\n  }\n\n  /**\n   * Resend an event. Will also retry any to-device messages waiting to be sent.\n   * @param event - The event to resend.\n   * @param room - Optional. The room the event is in. Will update the\n   * timeline entry if provided.\n   * @returns Promise which resolves: to an ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n  resendEvent(event, room) {\n    // also kick the to-device queue to retry\n    this.toDeviceMessageQueue.sendQueue();\n    this.updatePendingEventStatus(room, event, EventStatus.SENDING);\n    return this.encryptAndSendEvent(room, event);\n  }\n\n  /**\n   * Cancel a queued or unsent event.\n   *\n   * @param event -   Event to cancel\n   * @throws Error if the event is not in QUEUED, NOT_SENT or ENCRYPTING state\n   */\n  cancelPendingEvent(event) {\n    if (![EventStatus.QUEUED, EventStatus.NOT_SENT, EventStatus.ENCRYPTING].includes(event.status)) {\n      throw new Error(\"cannot cancel an event with status \" + event.status);\n    }\n\n    // If the event is currently being encrypted then remove it from the pending list, to indicate that it should\n    // not be sent.\n    if (event.status === EventStatus.ENCRYPTING) {\n      this.eventsBeingEncrypted.delete(event.getId());\n    } else if (this.scheduler && event.status === EventStatus.QUEUED) {\n      // tell the scheduler to forget about it, if it's queued\n      this.scheduler.removeEventFromQueue(event);\n    }\n\n    // then tell the room about the change of state, which will remove it\n    // from the room's list of pending events.\n    var room = this.getRoom(event.getRoomId());\n    this.updatePendingEventStatus(room, event, EventStatus.CANCELLED);\n  }\n\n  /**\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  setRoomName(roomId, name) {\n    return this.sendStateEvent(roomId, EventType.RoomName, {\n      name: name\n    });\n  }\n\n  /**\n   * @param htmlTopic - Optional.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  setRoomTopic(roomId, topic, htmlTopic) {\n    var content = ContentHelpers.makeTopicContent(topic, htmlTopic);\n    return this.sendStateEvent(roomId, EventType.RoomTopic, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to an object keyed by tagId with objects containing a numeric order field.\n   * @returns Rejects: with an error response.\n   */\n  getRoomTags(roomId) {\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * @param tagName - name of room tag to be set\n   * @param metadata - associated with that tag to be stored\n   * @returns Promise which resolves: to an empty object\n   * @returns Rejects: with an error response.\n   */\n  setRoomTag(roomId, tagName) {\n    var metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId,\n      $tag: tagName\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, metadata);\n  }\n\n  /**\n   * @param tagName - name of room tag to be removed\n   * @returns Promise which resolves: to an empty object\n   * @returns Rejects: with an error response.\n   */\n  deleteRoomTag(roomId, tagName) {\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId,\n      $tag: tagName\n    });\n    return this.http.authedRequest(Method.Delete, path);\n  }\n\n  /**\n   * @param eventType - event type to be set\n   * @param content - event content\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setRoomAccountData(roomId, eventType, content) {\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/account_data/$type\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId,\n      $type: eventType\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, content);\n  }\n\n  /**\n   * Set a power level to one or multiple users.\n   * Will apply changes atop of current power level event from local state if running & synced, falling back\n   * to fetching latest from the `/state/` API.\n   * @param roomId - the room to update power levels in\n   * @param userId - the ID of the user or users to update power levels of\n   * @param powerLevel - the numeric power level to update given users to\n   * @returns Promise which resolves: to an ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n  setPowerLevel(roomId, userId, powerLevel) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      var _content;\n      var content;\n      if (_this31.clientRunning && _this31.isInitialSyncComplete()) {\n        var _this31$getRoom;\n        content = (_this31$getRoom = _this31.getRoom(roomId)) === null || _this31$getRoom === void 0 || (_this31$getRoom = _this31$getRoom.currentState) === null || _this31$getRoom === void 0 || (_this31$getRoom = _this31$getRoom.getStateEvents(EventType.RoomPowerLevels, \"\")) === null || _this31$getRoom === void 0 ? void 0 : _this31$getRoom.getContent();\n      }\n      if (!content) {\n        try {\n          content = yield _this31.getStateEvent(roomId, EventType.RoomPowerLevels, \"\");\n        } catch (e) {\n          // It is possible for a Matrix room to not have a power levels event\n          if (e instanceof MatrixError && e.errcode === \"M_NOT_FOUND\") {\n            content = {};\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      // take a copy of the content to ensure we don't corrupt\n      // existing client state with a failed power level change\n      content = utils.deepCopy(content);\n      if (!((_content = content) !== null && _content !== void 0 && _content.users)) {\n        content.users = {};\n      }\n      var users = Array.isArray(userId) ? userId : [userId];\n      for (var user of users) {\n        if (powerLevel == null) {\n          delete content.users[user];\n        } else {\n          content.users[user] = powerLevel;\n        }\n      }\n      return _this31.sendStateEvent(roomId, EventType.RoomPowerLevels, content, \"\");\n    })();\n  }\n\n  /**\n   * Create an m.beacon_info event\n   * @returns\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  unstable_createLiveBeacon(roomId, beaconInfoContent) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      return _this32.unstable_setLiveBeacon(roomId, beaconInfoContent);\n    })();\n  }\n\n  /**\n   * Upsert a live beacon event\n   * using a specific m.beacon_info.* event variable type\n   * @param roomId - string\n   * @returns\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  unstable_setLiveBeacon(roomId, beaconInfoContent) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      return _this33.sendStateEvent(roomId, M_BEACON_INFO.name, beaconInfoContent, _this33.getUserId());\n    })();\n  }\n  sendEvent(roomId, threadIdOrEventType, eventTypeOrContent, contentOrTxnId, txnIdOrVoid) {\n    var threadId;\n    var eventType;\n    var content;\n    var txnId;\n    if (!(threadIdOrEventType !== null && threadIdOrEventType !== void 0 && threadIdOrEventType.startsWith(EVENT_ID_PREFIX)) && threadIdOrEventType !== null) {\n      txnId = contentOrTxnId;\n      content = eventTypeOrContent;\n      eventType = threadIdOrEventType;\n      threadId = null;\n    } else {\n      txnId = txnIdOrVoid;\n      content = contentOrTxnId;\n      eventType = eventTypeOrContent;\n      threadId = threadIdOrEventType;\n    }\n    this.addThreadRelationIfNeeded(content, threadId, roomId);\n    return this.sendCompleteEvent(roomId, threadId, {\n      type: eventType,\n      content\n    }, txnId);\n  }\n\n  /**\n   * If we expect that an event is part of a thread but is missing the relation\n   * we need to add it manually, as well as the reply fallback\n   */\n  addThreadRelationIfNeeded(content, threadId, roomId) {\n    var _content$mRelates_to;\n    if (threadId && !((_content$mRelates_to = content[\"m.relates_to\"]) !== null && _content$mRelates_to !== void 0 && _content$mRelates_to.rel_type)) {\n      var _content$mRelates_to2, _this$getRoom;\n      var isReply = !!((_content$mRelates_to2 = content[\"m.relates_to\"]) !== null && _content$mRelates_to2 !== void 0 && _content$mRelates_to2[\"m.in_reply_to\"]);\n      content[\"m.relates_to\"] = _objectSpread(_objectSpread({}, content[\"m.relates_to\"]), {}, {\n        rel_type: THREAD_RELATION_TYPE.name,\n        event_id: threadId,\n        // Set is_falling_back to true unless this is actually intended to be a reply\n        is_falling_back: !isReply\n      });\n      var thread = (_this$getRoom = this.getRoom(roomId)) === null || _this$getRoom === void 0 ? void 0 : _this$getRoom.getThread(threadId);\n      if (thread && !isReply) {\n        var _thread$lastReply$get, _thread$lastReply;\n        content[\"m.relates_to\"][\"m.in_reply_to\"] = {\n          event_id: (_thread$lastReply$get = (_thread$lastReply = thread.lastReply(ev => {\n            return ev.isRelation(THREAD_RELATION_TYPE.name) && !ev.status;\n          })) === null || _thread$lastReply === void 0 ? void 0 : _thread$lastReply.getId()) !== null && _thread$lastReply$get !== void 0 ? _thread$lastReply$get : threadId\n        };\n      }\n    }\n  }\n\n  /**\n   * @param eventObject - An object with the partial structure of an event, to which event_id, user_id, room_id and origin_server_ts will be added.\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n\n  /**\n   * Sends a delayed event (MSC4140).\n   * @param eventObject - An object with the partial structure of an event, to which event_id, user_id, room_id and origin_server_ts will be added.\n   * @param delayOpts - Properties of the delay for this event.\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n\n  sendCompleteEvent(roomId, threadId, eventObject, delayOptsOrTxnId, txnIdOrVoid) {\n    var delayOpts;\n    var txnId;\n    if (typeof delayOptsOrTxnId === \"string\") {\n      txnId = delayOptsOrTxnId;\n    } else {\n      delayOpts = delayOptsOrTxnId;\n      txnId = txnIdOrVoid;\n    }\n    if (!txnId) {\n      txnId = this.makeTxnId();\n    }\n\n    // We always construct a MatrixEvent when sending because the store and scheduler use them.\n    // We'll extract the params back out if it turns out the client has no scheduler or store.\n    var localEvent = new MatrixEvent(Object.assign(eventObject, {\n      event_id: \"~\" + roomId + \":\" + txnId,\n      user_id: this.credentials.userId,\n      sender: this.credentials.userId,\n      room_id: roomId,\n      origin_server_ts: new Date().getTime()\n    }));\n    var room = this.getRoom(roomId);\n    var thread = threadId ? room === null || room === void 0 ? void 0 : room.getThread(threadId) : undefined;\n    if (thread) {\n      localEvent.setThread(thread);\n    }\n    if (!delayOpts) {\n      // set up re-emitter for this new event - this is normally the job of EventMapper but we don't use it here\n      this.reEmitter.reEmit(localEvent, [MatrixEventEvent.Replaced, MatrixEventEvent.VisibilityChange]);\n      room === null || room === void 0 || room.reEmitter.reEmit(localEvent, [MatrixEventEvent.BeforeRedaction]);\n    }\n\n    // if this is a relation or redaction of an event\n    // that hasn't been sent yet (e.g. with a local id starting with a ~)\n    // then listen for the remote echo of that event so that by the time\n    // this event does get sent, we have the correct event_id\n    var targetId = localEvent.getAssociatedId();\n    if (targetId !== null && targetId !== void 0 && targetId.startsWith(\"~\")) {\n      var target = room === null || room === void 0 ? void 0 : room.getPendingEvents().find(e => e.getId() === targetId);\n      target === null || target === void 0 || target.once(MatrixEventEvent.LocalEventIdReplaced, () => {\n        localEvent.updateAssociatedId(target.getId());\n      });\n    }\n    var type = localEvent.getType();\n    this.logger.debug(\"sendEvent of type \".concat(type, \" in \").concat(roomId, \" with txnId \").concat(txnId).concat(delayOpts ? \" (delayed event)\" : \"\"));\n    localEvent.setTxnId(txnId);\n    localEvent.setStatus(EventStatus.SENDING);\n\n    // TODO: separate store for delayed events?\n    if (!delayOpts) {\n      // add this event immediately to the local store as 'sending'.\n      room === null || room === void 0 || room.addPendingEvent(localEvent, txnId);\n\n      // addPendingEvent can change the state to NOT_SENT if it believes\n      // that there's other events that have failed. We won't bother to\n      // try sending the event if the state has changed as such.\n      if (localEvent.status === EventStatus.NOT_SENT) {\n        return Promise.reject(new Error(\"Event blocked by other events not yet sent\"));\n      }\n      return this.encryptAndSendEvent(room, localEvent);\n    } else {\n      return this.encryptAndSendEvent(room, localEvent, delayOpts);\n    }\n  }\n\n  /**\n   * encrypts the event if necessary; adds the event to the queue, or sends it; marks the event as sent/unsent\n   * @returns returns a promise which resolves with the result of the send request\n   */\n\n  /**\n   * Simply sends a delayed event without encrypting it.\n   * TODO: Allow encrypted delayed events, and encrypt them properly\n   * @param delayOpts - Properties of the delay for this event.\n   * @returns returns a promise which resolves with the result of the delayed send request\n   */\n\n  encryptAndSendEvent(room, event, delayOpts) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      if (delayOpts) {\n        return _this34.sendEventHttpRequest(event, delayOpts);\n      }\n      try {\n        var cancelled;\n        _this34.eventsBeingEncrypted.add(event.getId());\n        try {\n          yield _this34.encryptEventIfNeeded(event, room !== null && room !== void 0 ? room : undefined);\n        } finally {\n          cancelled = !_this34.eventsBeingEncrypted.delete(event.getId());\n        }\n        if (cancelled) {\n          // cancelled via MatrixClient::cancelPendingEvent\n          return {};\n        }\n\n        // encryptEventIfNeeded may have updated the status from SENDING to ENCRYPTING. If so, we need\n        // to put it back.\n        if (event.status === EventStatus.ENCRYPTING) {\n          _this34.updatePendingEventStatus(room, event, EventStatus.SENDING);\n        }\n        var promise = null;\n        if (_this34.scheduler) {\n          // if this returns a promise then the scheduler has control now and will\n          // resolve/reject when it is done. Internally, the scheduler will invoke\n          // processFn which is set to this._sendEventHttpRequest so the same code\n          // path is executed regardless.\n          promise = _this34.scheduler.queueEvent(event);\n          if (promise && _this34.scheduler.getQueueForEvent(event).length > 1) {\n            // event is processed FIFO so if the length is 2 or more we know\n            // this event is stuck behind an earlier event.\n            _this34.updatePendingEventStatus(room, event, EventStatus.QUEUED);\n          }\n        }\n        if (!promise) {\n          promise = _this34.sendEventHttpRequest(event);\n          if (room) {\n            promise = promise.then(res => {\n              room.updatePendingEvent(event, EventStatus.SENT, res[\"event_id\"]);\n              return res;\n            });\n          }\n        }\n        return yield promise;\n      } catch (err) {\n        _this34.logger.error(\"Error sending event\", err);\n        try {\n          // set the error on the event before we update the status:\n          // updating the status emits the event, so the state should be\n          // consistent at that point.\n          event.error = err;\n          _this34.updatePendingEventStatus(room, event, EventStatus.NOT_SENT);\n        } catch (e) {\n          _this34.logger.error(\"Exception in error handler!\", e);\n        }\n        if (err instanceof MatrixError) {\n          err.event = event;\n        }\n        throw err;\n      }\n    })();\n  }\n  encryptEventIfNeeded(event, room) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      // If the room is unknown, we cannot encrypt for it\n      if (!room) return;\n      if (!(yield _this35.shouldEncryptEventForRoom(event, room))) return;\n      if (!_this35.cryptoBackend && _this35.usingExternalCrypto) {\n        // The client has opted to allow sending messages to encrypted\n        // rooms even if the room is encrypted, and we haven't set up\n        // crypto. This is useful for users of matrix-org/pantalaimon\n        return;\n      }\n      if (!_this35.cryptoBackend) {\n        throw new Error(\"This room is configured to use encryption, but your client does not support encryption.\");\n      }\n      _this35.updatePendingEventStatus(room, event, EventStatus.ENCRYPTING);\n      yield _this35.cryptoBackend.encryptEvent(event, room);\n    })();\n  }\n\n  /**\n   * Determine whether a given event should be encrypted when we send it to the given room.\n   *\n   * This takes into account event type and room configuration.\n   */\n  shouldEncryptEventForRoom(event, room) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      var _this36$cryptoBackend;\n      if (event.isEncrypted()) {\n        // this event has already been encrypted; this happens if the\n        // encryption step succeeded, but the send step failed on the first\n        // attempt.\n        return false;\n      }\n      if (event.getType() === EventType.Reaction) {\n        // For reactions, there is a very little gained by encrypting the entire\n        // event, as relation data is already kept in the clear. Event\n        // encryption for a reaction effectively only obscures the event type,\n        // but the purpose is still obvious from the relation data, so nothing\n        // is really gained. It also causes quite a few problems, such as:\n        //   * triggers notifications via default push rules\n        //   * prevents server-side bundling for reactions\n        // The reaction key / content / emoji value does warrant encrypting, but\n        // this will be handled separately by encrypting just this value.\n        // See https://github.com/matrix-org/matrix-doc/pull/1849#pullrequestreview-248763642\n        return false;\n      }\n      if (event.isRedaction()) {\n        // Redactions do not support encryption in the spec at this time.\n        // Whilst it mostly worked in some clients, it wasn't compliant.\n        return false;\n      }\n\n      // If the room has an m.room.encryption event, we should encrypt.\n      if (room.hasEncryptionStateEvent()) return true;\n\n      // If we have a crypto impl, and *it* thinks we should encrypt, then we should.\n      if (yield (_this36$cryptoBackend = _this36.cryptoBackend) === null || _this36$cryptoBackend === void 0 ? void 0 : _this36$cryptoBackend.isEncryptionEnabledInRoom(room.roomId)) return true;\n\n      // Otherwise, no need to encrypt.\n      return false;\n    })();\n  }\n\n  /**\n   * Returns the eventType that should be used taking encryption into account\n   * for a given eventType.\n   * @param roomId - the room for the events `eventType` relates to\n   * @param eventType - the event type\n   * @returns the event type taking encryption into account\n   */\n  getEncryptedIfNeededEventType(roomId, eventType) {\n    var _this$getRoom2;\n    if (eventType === EventType.Reaction) return eventType;\n    return (_this$getRoom2 = this.getRoom(roomId)) !== null && _this$getRoom2 !== void 0 && _this$getRoom2.hasEncryptionStateEvent() ? EventType.RoomMessageEncrypted : eventType;\n  }\n  updatePendingEventStatus(room, event, newStatus) {\n    if (room) {\n      room.updatePendingEvent(event, newStatus);\n    } else {\n      event.setStatus(newStatus);\n    }\n  }\n  sendEventHttpRequest(event, delayOpts) {\n    var txnId = event.getTxnId();\n    if (!txnId) {\n      txnId = this.makeTxnId();\n      event.setTxnId(txnId);\n    }\n    var pathParams = {\n      $roomId: event.getRoomId(),\n      $eventType: event.getWireType(),\n      $stateKey: event.getStateKey(),\n      $txnId: txnId\n    };\n    var path;\n    if (event.isState()) {\n      var pathTemplate = \"/rooms/$roomId/state/$eventType\";\n      if (event.getStateKey() && event.getStateKey().length > 0) {\n        pathTemplate = \"/rooms/$roomId/state/$eventType/$stateKey\";\n      }\n      path = utils.encodeUri(pathTemplate, pathParams);\n    } else if (event.isRedaction() && event.event.redacts) {\n      var _pathTemplate = \"/rooms/$roomId/redact/$redactsEventId/$txnId\";\n      path = utils.encodeUri(_pathTemplate, _objectSpread({\n        $redactsEventId: event.event.redacts\n      }, pathParams));\n    } else {\n      path = utils.encodeUri(\"/rooms/$roomId/send/$eventType/$txnId\", pathParams);\n    }\n    var content = event.getWireContent();\n    if (!delayOpts) {\n      return this.http.authedRequest(Method.Put, path, undefined, content).then(res => {\n        this.logger.debug(\"Event sent to \".concat(event.getRoomId(), \" with event id \").concat(res.event_id));\n        return res;\n      });\n    } else {\n      return this.http.authedRequest(Method.Put, path, getUnstableDelayQueryOpts(delayOpts), content);\n    }\n  }\n\n  /**\n   * @param txnId -  transaction id. One will be made up if not supplied.\n   * @param opts - Redact options\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   * @throws Error if called with `with_rel_types` (MSC3912) but the server does not support it.\n   *         Callers should check whether the server supports MSC3912 via `MatrixClient.canSupport`.\n   */\n\n  redactEvent(roomId, threadId, eventId, txnId, opts) {\n    var _eventId, _opts, _opts2;\n    if (!((_eventId = eventId) !== null && _eventId !== void 0 && _eventId.startsWith(EVENT_ID_PREFIX))) {\n      opts = txnId;\n      txnId = eventId;\n      eventId = threadId;\n      threadId = null;\n    }\n    var reason = (_opts = opts) === null || _opts === void 0 ? void 0 : _opts.reason;\n    var content = {\n      reason\n    };\n    if (((_opts2 = opts) === null || _opts2 === void 0 ? void 0 : _opts2.with_rel_types) !== undefined) {\n      if (this.canSupport.get(Feature.RelationBasedRedactions) === ServerSupport.Unsupported) {\n        throw new Error(\"Server does not support relation based redactions \" + \"roomId \".concat(roomId, \" eventId \").concat(eventId, \" txnId: \").concat(txnId, \" threadId \").concat(threadId));\n      }\n      var withRelTypesPropName = this.canSupport.get(Feature.RelationBasedRedactions) === ServerSupport.Stable ? MSC3912_RELATION_BASED_REDACTIONS_PROP.stable : MSC3912_RELATION_BASED_REDACTIONS_PROP.unstable;\n      content[withRelTypesPropName] = opts.with_rel_types;\n    }\n    return this.sendCompleteEvent(roomId, threadId, {\n      type: EventType.RoomRedaction,\n      content,\n      redacts: eventId\n    }, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to an ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendMessage(roomId, threadId, content, txnId) {\n    if (typeof threadId !== \"string\" && threadId !== null) {\n      txnId = content;\n      content = threadId;\n      threadId = null;\n    }\n    var eventType = EventType.RoomMessage;\n    var sendContent = content;\n    return this.sendEvent(roomId, threadId, eventType, sendContent, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns\n   * @returns Rejects: with an error response.\n   */\n\n  sendTextMessage(roomId, threadId, body, txnId) {\n    var _threadId;\n    if (!((_threadId = threadId) !== null && _threadId !== void 0 && _threadId.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      txnId = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeTextMessage(body);\n    return this.sendMessage(roomId, threadId, content, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendNotice(roomId, threadId, body, txnId) {\n    var _threadId2;\n    if (!((_threadId2 = threadId) !== null && _threadId2 !== void 0 && _threadId2.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      txnId = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeNotice(body);\n    return this.sendMessage(roomId, threadId, content, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendEmoteMessage(roomId, threadId, body, txnId) {\n    var _threadId3;\n    if (!((_threadId3 = threadId) !== null && _threadId3 !== void 0 && _threadId3.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      txnId = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeEmoteMessage(body);\n    return this.sendMessage(roomId, threadId, content, txnId);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendImageMessage(roomId, threadId, url, info) {\n    var _threadId4;\n    var text = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"Image\";\n    if (!((_threadId4 = threadId) !== null && _threadId4 !== void 0 && _threadId4.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      text = info || \"Image\";\n      info = url;\n      url = threadId;\n      threadId = null;\n    }\n    var content = {\n      msgtype: MsgType.Image,\n      url: url,\n      info: info,\n      body: text\n    };\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendStickerMessage(roomId, threadId, url, info) {\n    var _threadId5;\n    var text = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"Sticker\";\n    if (!((_threadId5 = threadId) !== null && _threadId5 !== void 0 && _threadId5.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      text = info || \"Sticker\";\n      info = url;\n      url = threadId;\n      threadId = null;\n    }\n    var content = {\n      url: url,\n      info: info,\n      body: text\n    };\n    return this.sendEvent(roomId, threadId, EventType.Sticker, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendHtmlMessage(roomId, threadId, body, htmlBody) {\n    var _threadId6;\n    if (!((_threadId6 = threadId) !== null && _threadId6 !== void 0 && _threadId6.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      htmlBody = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeHtmlMessage(body, htmlBody);\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendHtmlNotice(roomId, threadId, body, htmlBody) {\n    var _threadId7;\n    if (!((_threadId7 = threadId) !== null && _threadId7 !== void 0 && _threadId7.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      htmlBody = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeHtmlNotice(body, htmlBody);\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendHtmlEmote(roomId, threadId, body, htmlBody) {\n    var _threadId8;\n    if (!((_threadId8 = threadId) !== null && _threadId8 !== void 0 && _threadId8.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      htmlBody = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeHtmlEmote(body, htmlBody);\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * Send a delayed timeline event.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_sendDelayedEvent(roomId, delayOpts, threadId, eventType, content, txnId) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this37.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw Error(\"Server does not support the delayed events API\");\n      }\n      _this37.addThreadRelationIfNeeded(content, threadId, roomId);\n      return _this37.sendCompleteEvent(roomId, threadId, {\n        type: eventType,\n        content\n      }, delayOpts, txnId);\n    })();\n  }\n\n  /**\n   * Send a delayed state event.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_sendDelayedStateEvent(roomId, delayOpts, eventType, content) {\n    var _arguments4 = arguments,\n      _this38 = this;\n    return _asyncToGenerator(function* () {\n      var stateKey = _arguments4.length > 4 && _arguments4[4] !== undefined ? _arguments4[4] : \"\";\n      var opts = _arguments4.length > 5 && _arguments4[5] !== undefined ? _arguments4[5] : {};\n      if (!(yield _this38.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw Error(\"Server does not support the delayed events API\");\n      }\n      var pathParams = {\n        $roomId: roomId,\n        $eventType: eventType,\n        $stateKey: stateKey\n      };\n      var path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n      if (stateKey !== undefined) {\n        path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n      }\n      return _this38.http.authedRequest(Method.Put, path, getUnstableDelayQueryOpts(delayOpts), content, opts);\n    })();\n  }\n\n  /**\n   * Get all pending delayed events for the calling user.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_getDelayedEvents(fromToken) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this39.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw Error(\"Server does not support the delayed events API\");\n      }\n      var queryDict = fromToken ? {\n        from: fromToken\n      } : undefined;\n      return yield _this39.http.authedRequest(Method.Get, \"/delayed_events\", queryDict, undefined, {\n        prefix: \"\".concat(ClientPrefix.Unstable, \"/\").concat(UNSTABLE_MSC4140_DELAYED_EVENTS)\n      });\n    })();\n  }\n\n  /**\n   * Manage a delayed event associated with the given delay_id.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_updateDelayedEvent(delayId, action) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this40.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw Error(\"Server does not support the delayed events API\");\n      }\n      var path = utils.encodeUri(\"/delayed_events/$delayId\", {\n        $delayId: delayId\n      });\n      var data = {\n        action\n      };\n      return yield _this40.http.authedRequest(Method.Post, path, undefined, data, {\n        prefix: \"\".concat(ClientPrefix.Unstable, \"/\").concat(UNSTABLE_MSC4140_DELAYED_EVENTS)\n      });\n    })();\n  }\n\n  /**\n   * Send a receipt.\n   * @param event - The event being acknowledged\n   * @param receiptType - The kind of receipt e.g. \"m.read\". Other than\n   * ReceiptType.Read are experimental!\n   * @param body - Additional content to send alongside the receipt.\n   * @param unthreaded - An unthreaded receipt will clear room+thread notifications\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  sendReceipt(event, receiptType, body) {\n    var _arguments5 = arguments,\n      _this41 = this;\n    return _asyncToGenerator(function* () {\n      var unthreaded = _arguments5.length > 3 && _arguments5[3] !== undefined ? _arguments5[3] : false;\n      if (_this41.isGuest()) {\n        return Promise.resolve({}); // guests cannot send receipts so don't bother.\n      }\n      var path = utils.encodeUri(\"/rooms/$roomId/receipt/$receiptType/$eventId\", {\n        $roomId: event.getRoomId(),\n        $receiptType: receiptType,\n        $eventId: event.getId()\n      });\n\n      // Unless we're explicitly making an unthreaded receipt or we don't\n      // support threads, include the `thread_id` property in the body.\n      var shouldAddThreadId = !unthreaded && _this41.supportsThreads();\n      var fullBody = shouldAddThreadId ? _objectSpread(_objectSpread({}, body), {}, {\n        thread_id: threadIdForReceipt(event)\n      }) : body;\n      var promise = _this41.http.authedRequest(Method.Post, path, undefined, fullBody || {});\n      var room = _this41.getRoom(event.getRoomId());\n      if (room && _this41.credentials.userId) {\n        room.addLocalEchoReceipt(_this41.credentials.userId, event, receiptType, unthreaded);\n      }\n      return promise;\n    })();\n  }\n\n  /**\n   * Send a read receipt.\n   * @param event - The event that has been read.\n   * @param receiptType - other than ReceiptType.Read are experimental! Optional.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  sendReadReceipt(event) {\n    var _arguments6 = arguments,\n      _this42 = this;\n    return _asyncToGenerator(function* () {\n      var receiptType = _arguments6.length > 1 && _arguments6[1] !== undefined ? _arguments6[1] : ReceiptType.Read;\n      var unthreaded = _arguments6.length > 2 && _arguments6[2] !== undefined ? _arguments6[2] : false;\n      if (!event) return;\n      var eventId = event.getId();\n      var room = _this42.getRoom(event.getRoomId());\n      if (room !== null && room !== void 0 && room.hasPendingEvent(eventId)) {\n        throw new Error(\"Cannot set read receipt to a pending event (\".concat(eventId, \")\"));\n      }\n      return _this42.sendReceipt(event, receiptType, {}, unthreaded);\n    })();\n  }\n\n  /**\n   * Set a marker to indicate the point in a room before which the user has read every\n   * event. This can be retrieved from room account data (the event type is `m.fully_read`)\n   * and displayed as a horizontal line in the timeline that is visually distinct to the\n   * position of the user's own read receipt.\n   * @param roomId - ID of the room that has been read\n   * @param rmEventId - ID of the event that has been read\n   * @param rrEvent - the event tracked by the read receipt. This is here for\n   * convenience because the RR and the RM are commonly updated at the same time as each\n   * other. The local echo of this receipt will be done if set. Optional.\n   * @param rpEvent - the m.read.private read receipt event for when we don't\n   * want other users to see the read receipts. This is experimental. Optional.\n   * @returns Promise which resolves: the empty object, `{}`.\n   */\n  setRoomReadMarkers(roomId, rmEventId, rrEvent, rpEvent) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      var room = _this43.getRoom(roomId);\n      if (room !== null && room !== void 0 && room.hasPendingEvent(rmEventId)) {\n        throw new Error(\"Cannot set read marker to a pending event (\".concat(rmEventId, \")\"));\n      }\n\n      // Add the optional RR update, do local echo like `sendReceipt`\n      var rrEventId;\n      if (rrEvent) {\n        rrEventId = rrEvent.getId();\n        if (room !== null && room !== void 0 && room.hasPendingEvent(rrEventId)) {\n          throw new Error(\"Cannot set read receipt to a pending event (\".concat(rrEventId, \")\"));\n        }\n        room === null || room === void 0 || room.addLocalEchoReceipt(_this43.credentials.userId, rrEvent, ReceiptType.Read);\n      }\n\n      // Add the optional private RR update, do local echo like `sendReceipt`\n      var rpEventId;\n      if (rpEvent) {\n        rpEventId = rpEvent.getId();\n        if (room !== null && room !== void 0 && room.hasPendingEvent(rpEventId)) {\n          throw new Error(\"Cannot set read receipt to a pending event (\".concat(rpEventId, \")\"));\n        }\n        room === null || room === void 0 || room.addLocalEchoReceipt(_this43.credentials.userId, rpEvent, ReceiptType.ReadPrivate);\n      }\n      return yield _this43.setRoomReadMarkersHttpRequest(roomId, rmEventId, rrEventId, rpEventId);\n    })();\n  }\n\n  /**\n   * Get a preview of the given URL as of (roughly) the given point in time,\n   * described as an object with OpenGraph keys and associated values.\n   * Attributes may be synthesized where actual OG metadata is lacking.\n   * Caches results to prevent hammering the server.\n   * @param url - The URL to get preview data for\n   * @param ts - The preferred point in time that the preview should\n   * describe (ms since epoch).  The preview returned will either be the most\n   * recent one preceding this timestamp if available, or failing that the next\n   * most recent available preview.\n   * @returns Promise which resolves: Object of OG metadata.\n   * @returns Rejects: with an error response.\n   * May return synthesized attributes if the URL lacked OG meta.\n   */\n  getUrlPreview(url, ts) {\n    // bucket the timestamp to the nearest minute to prevent excessive spam to the server\n    // Surely 60-second accuracy is enough for anyone.\n    ts = Math.floor(ts / 60000) * 60000;\n    var parsed = new URL(url);\n    parsed.hash = \"\"; // strip the hash as it won't affect the preview\n    url = parsed.toString();\n    var key = ts + \"_\" + url;\n\n    // If there's already a request in flight (or we've handled it), return that instead.\n    if (key in this.urlPreviewCache) {\n      return this.urlPreviewCache[key];\n    }\n    var resp = this.http.authedRequest(Method.Get, \"/preview_url\", {\n      url,\n      ts: ts.toString()\n    }, undefined, {\n      prefix: MediaPrefix.V3,\n      priority: \"low\"\n    });\n    // TODO: Expire the URL preview cache sometimes\n    this.urlPreviewCache[key] = resp;\n    return resp;\n  }\n\n  /**\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  sendTyping(roomId, isTyping, timeoutMs) {\n    if (this.isGuest()) {\n      return Promise.resolve({}); // guests cannot send typing notifications so don't bother.\n    }\n    var path = utils.encodeUri(\"/rooms/$roomId/typing/$userId\", {\n      $roomId: roomId,\n      $userId: this.getUserId()\n    });\n    var data = {\n      typing: isTyping\n    };\n    if (isTyping) {\n      data.timeout = timeoutMs ? timeoutMs : 20000;\n    }\n    return this.http.authedRequest(Method.Put, path, undefined, data);\n  }\n\n  /**\n   * Determines the history of room upgrades for a given room, as far as the\n   * client can see. Returns an array of Rooms where the first entry is the\n   * oldest and the last entry is the newest (likely current) room. If the\n   * provided room is not found, this returns an empty list. This works in\n   * both directions, looking for older and newer rooms of the given room.\n   * @param roomId - The room ID to search from\n   * @param verifyLinks - If true, the function will only return rooms\n   * which can be proven to be linked. For example, rooms which have a create\n   * event pointing to an old room which the client is not aware of or doesn't\n   * have a matching tombstone would not be returned.\n   * @param msc3946ProcessDynamicPredecessor - if true, look for\n   * m.room.predecessor state events as well as create events, and prefer\n   * predecessor events where they exist (MSC3946).\n   * @returns An array of rooms representing the upgrade\n   * history.\n   */\n  getRoomUpgradeHistory(roomId) {\n    var verifyLinks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var msc3946ProcessDynamicPredecessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var currentRoom = this.getRoom(roomId);\n    if (!currentRoom) return [];\n    var before = this.findPredecessorRooms(currentRoom, verifyLinks, msc3946ProcessDynamicPredecessor);\n    var after = this.findSuccessorRooms(currentRoom, verifyLinks, msc3946ProcessDynamicPredecessor);\n    return [...before, currentRoom, ...after];\n  }\n  findPredecessorRooms(room, verifyLinks, msc3946ProcessDynamicPredecessor) {\n    var _room$findPredecessor;\n    var ret = [];\n    var seenRoomIDs = new Set([room.roomId]);\n\n    // Work backwards from newer to older rooms\n    var predecessorRoomId = (_room$findPredecessor = room.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _room$findPredecessor === void 0 ? void 0 : _room$findPredecessor.roomId;\n    while (predecessorRoomId !== null) {\n      var _room$findPredecessor2;\n      if (predecessorRoomId) {\n        if (seenRoomIDs.has(predecessorRoomId)) break;\n        seenRoomIDs.add(predecessorRoomId);\n      }\n      var predecessorRoom = this.getRoom(predecessorRoomId);\n      if (predecessorRoom === null) {\n        break;\n      }\n      if (verifyLinks) {\n        var tombstone = predecessorRoom.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n        if (!tombstone || tombstone.getContent()[\"replacement_room\"] !== room.roomId) {\n          break;\n        }\n      }\n\n      // Insert at the front because we're working backwards from the currentRoom\n      ret.splice(0, 0, predecessorRoom);\n      room = predecessorRoom;\n      predecessorRoomId = (_room$findPredecessor2 = room.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _room$findPredecessor2 === void 0 ? void 0 : _room$findPredecessor2.roomId;\n    }\n    return ret;\n  }\n  findSuccessorRooms(room, verifyLinks, msc3946ProcessDynamicPredecessor) {\n    var ret = [];\n\n    // Work forwards, looking at tombstone events\n    var tombstoneEvent = room.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n    while (tombstoneEvent) {\n      var successorRoom = this.getRoom(tombstoneEvent.getContent()[\"replacement_room\"]);\n      if (!successorRoom) break; // end of the chain\n      if (successorRoom.roomId === room.roomId) break; // Tombstone is referencing its own room\n\n      if (verifyLinks) {\n        var _successorRoom$findPr;\n        var predecessorRoomId = (_successorRoom$findPr = successorRoom.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _successorRoom$findPr === void 0 ? void 0 : _successorRoom$findPr.roomId;\n        if (!predecessorRoomId || predecessorRoomId !== room.roomId) {\n          break;\n        }\n      }\n\n      // Push to the end because we're looking forwards\n      ret.push(successorRoom);\n      var roomIds = new Set(ret.map(ref => ref.roomId));\n      if (roomIds.size < ret.length) {\n        // The last room added to the list introduced a previous roomId\n        // To avoid recursion, return the last rooms - 1\n        return ret.slice(0, ret.length - 1);\n      }\n\n      // Set the current room to the reference room so we know where we're at\n      room = successorRoom;\n      tombstoneEvent = room.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n    }\n    return ret;\n  }\n\n  /**\n   * @param reason - Optional.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  invite(roomId, userId, reason) {\n    return this.membershipChange(roomId, userId, KnownMembership.Invite, reason);\n  }\n\n  /**\n   * Invite a user to a room based on their email address.\n   * @param roomId - The room to invite the user to.\n   * @param email - The email address to invite.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  inviteByEmail(roomId, email) {\n    return this.inviteByThreePid(roomId, \"email\", email);\n  }\n\n  /**\n   * Invite a user to a room based on a third-party identifier.\n   * @param roomId - The room to invite the user to.\n   * @param medium - The medium to invite the user e.g. \"email\".\n   * @param address - The address for the specified medium.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  inviteByThreePid(roomId, medium, address) {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      var _this44$identityServe;\n      var path = utils.encodeUri(\"/rooms/$roomId/invite\", {\n        $roomId: roomId\n      });\n      var identityServerUrl = _this44.getIdentityServerUrl(true);\n      if (!identityServerUrl) {\n        return Promise.reject(new MatrixError({\n          error: \"No supplied identity server URL\",\n          errcode: \"ORG.MATRIX.JSSDK_MISSING_PARAM\"\n        }));\n      }\n      var params = {\n        id_server: identityServerUrl,\n        medium: medium,\n        address: address\n      };\n      if ((_this44$identityServe = _this44.identityServer) !== null && _this44$identityServe !== void 0 && _this44$identityServe.getAccessToken) {\n        var identityAccessToken = yield _this44.identityServer.getAccessToken();\n        if (identityAccessToken) {\n          params[\"id_access_token\"] = identityAccessToken;\n        }\n      }\n      return _this44.http.authedRequest(Method.Post, path, undefined, params);\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  leave(roomId) {\n    return this.membershipChange(roomId, undefined, KnownMembership.Leave);\n  }\n\n  /**\n   * Leaves all rooms in the chain of room upgrades based on the given room. By\n   * default, this will leave all the previous and upgraded rooms, including the\n   * given room. To only leave the given room and any previous rooms, keeping the\n   * upgraded (modern) rooms untouched supply `false` to `includeFuture`.\n   * @param roomId - The room ID to start leaving at\n   * @param includeFuture - If true, the whole chain (past and future) of\n   * upgraded rooms will be left.\n   * @returns Promise which resolves when completed with an object keyed\n   * by room ID and value of the error encountered when leaving or null.\n   */\n  leaveRoomChain(roomId) {\n    var includeFuture = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var upgradeHistory = this.getRoomUpgradeHistory(roomId);\n    var eligibleToLeave = upgradeHistory;\n    if (!includeFuture) {\n      eligibleToLeave = [];\n      for (var _room2 of upgradeHistory) {\n        eligibleToLeave.push(_room2);\n        if (_room2.roomId === roomId) {\n          break;\n        }\n      }\n    }\n    var populationResults = {};\n    var promises = [];\n    var doLeave = roomId => {\n      return this.leave(roomId).then(() => {\n        delete populationResults[roomId];\n      }).catch(err => {\n        // suppress error\n        populationResults[roomId] = err;\n      });\n    };\n    for (var _room3 of eligibleToLeave) {\n      promises.push(doLeave(_room3.roomId));\n    }\n    return Promise.all(promises).then(() => populationResults);\n  }\n\n  /**\n   * @param reason - Optional.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  ban(roomId, userId, reason) {\n    return this.membershipChange(roomId, userId, KnownMembership.Ban, reason);\n  }\n\n  /**\n   * @param deleteRoom - True to delete the room from the store on success.\n   * Default: true.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  forget(roomId) {\n    var deleteRoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var promise = this.membershipChange(roomId, undefined, \"forget\");\n    if (!deleteRoom) {\n      return promise;\n    }\n    return promise.then(response => {\n      this.store.removeRoom(roomId);\n      this.emit(ClientEvent.DeleteRoom, roomId);\n      return response;\n    });\n  }\n\n  /**\n   * @returns Promise which resolves: Object (currently empty)\n   * @returns Rejects: with an error response.\n   */\n  unban(roomId, userId) {\n    // unbanning != set their state to leave: this used to be\n    // the case, but was then changed so that leaving was always\n    // a revoking of privilege, otherwise two people racing to\n    // kick / ban someone could end up banning and then un-banning\n    // them.\n    var path = utils.encodeUri(\"/rooms/$roomId/unban\", {\n      $roomId: roomId\n    });\n    var data = {\n      user_id: userId\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, data);\n  }\n\n  /**\n   * @param reason - Optional.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  kick(roomId, userId, reason) {\n    var path = utils.encodeUri(\"/rooms/$roomId/kick\", {\n      $roomId: roomId\n    });\n    var data = {\n      user_id: userId,\n      reason: reason\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, data);\n  }\n  membershipChange(roomId, userId, membership, reason) {\n    // API returns an empty object\n    var path = utils.encodeUri(\"/rooms/$room_id/$membership\", {\n      $room_id: roomId,\n      $membership: membership\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      user_id: userId,\n      // may be undefined e.g. on leave\n      reason: reason\n    });\n  }\n\n  /**\n   * Obtain a dict of actions which should be performed for this event according\n   * to the push rules for this user.  Caches the dict on the event.\n   * @param event - The event to get push actions for.\n   * @param forceRecalculate - forces to recalculate actions for an event\n   * Useful when an event just got decrypted\n   * @returns A dict of actions to perform.\n   */\n  getPushActionsForEvent(event) {\n    var forceRecalculate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!event.getPushActions() || forceRecalculate) {\n      var {\n        actions,\n        rule\n      } = this.pushProcessor.actionsAndRuleForEvent(event);\n      event.setPushDetails(actions, rule);\n    }\n    return event.getPushActions();\n  }\n\n  /**\n   * Obtain a dict of actions which should be performed for this event according\n   * to the push rules for this user.  Caches the dict on the event.\n   * @param event - The event to get push actions for.\n   * @param forceRecalculate - forces to recalculate actions for an event\n   * Useful when an event just got decrypted\n   * @returns A dict of actions to perform.\n   */\n  getPushDetailsForEvent(event) {\n    var forceRecalculate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!event.getPushDetails() || forceRecalculate) {\n      var {\n        actions,\n        rule\n      } = this.pushProcessor.actionsAndRuleForEvent(event);\n      event.setPushDetails(actions, rule);\n    }\n    return event.getPushDetails();\n  }\n\n  /**\n   * @param info - The kind of info to set (e.g. 'avatar_url')\n   * @param data - The JSON object to set.\n   * @returns\n   * @returns Rejects: with an error response.\n   */\n  // eslint-disable-next-line camelcase\n\n  setProfileInfo(info, data) {\n    var path = utils.encodeUri(\"/profile/$userId/$info\", {\n      $userId: this.credentials.userId,\n      $info: info\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, data);\n  }\n\n  /**\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  setDisplayName(name) {\n    var _this45 = this;\n    return _asyncToGenerator(function* () {\n      var prom = yield _this45.setProfileInfo(\"displayname\", {\n        displayname: name\n      });\n      // XXX: synthesise a profile update for ourselves because Synapse is broken and won't\n      var user = _this45.getUser(_this45.getUserId());\n      if (user) {\n        user.displayName = name;\n        user.emit(UserEvent.DisplayName, user.events.presence, user);\n      }\n      return prom;\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  setAvatarUrl(url) {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      var prom = yield _this46.setProfileInfo(\"avatar_url\", {\n        avatar_url: url\n      });\n      // XXX: synthesise a profile update for ourselves because Synapse is broken and won't\n      var user = _this46.getUser(_this46.getUserId());\n      if (user) {\n        user.avatarUrl = url;\n        user.emit(UserEvent.AvatarUrl, user.events.presence, user);\n      }\n      return prom;\n    })();\n  }\n\n  /**\n   * Turn an MXC URL into an HTTP one. <strong>This method is experimental and\n   * may change.</strong>\n   * @param mxcUrl - The MXC URL\n   * @param width - The desired width of the thumbnail.\n   * @param height - The desired height of the thumbnail.\n   * @param resizeMethod - The thumbnail resize method to use, either\n   * \"crop\" or \"scale\".\n   * @param allowDirectLinks - If true, return any non-mxc URLs\n   * directly. Fetching such URLs will leak information about the user to\n   * anyone they share a room with. If false, will return null for such URLs.\n   * @param allowRedirects - If true, the caller supports the URL being 307 or\n   * 308 redirected to another resource upon request. If false, redirects\n   * are not expected. Implied `true` when `useAuthentication` is `true`.\n   * @param useAuthentication - If true, the caller supports authenticated\n   * media and wants an authentication-required URL. Note that server support\n   * for authenticated media will *not* be checked - it is the caller's responsibility\n   * to do so before calling this function. Note also that `useAuthentication`\n   * implies `allowRedirects`. Defaults to false (unauthenticated endpoints).\n   * @returns the avatar URL or null.\n   */\n  mxcUrlToHttp(mxcUrl, width, height, resizeMethod, allowDirectLinks, allowRedirects, useAuthentication) {\n    return getHttpUriForMxc(this.baseUrl, mxcUrl, width, height, resizeMethod, allowDirectLinks, allowRedirects, useAuthentication);\n  }\n\n  /**\n   * Specify the set_presence value to be used for subsequent calls to the Sync API.\n   * This has an advantage over calls to the PUT /presence API in that it\n   * doesn't clobber status_msg set by other devices.\n   * @param presence - the presence to specify to set_presence of sync calls\n   */\n  setSyncPresence(presence) {\n    var _this47 = this;\n    return _asyncToGenerator(function* () {\n      var _this47$syncApi;\n      (_this47$syncApi = _this47.syncApi) === null || _this47$syncApi === void 0 || _this47$syncApi.setPresence(presence);\n    })();\n  }\n\n  /**\n   * @param opts - Options to apply\n   * @returns Promise which resolves\n   * @returns Rejects: with an error response.\n   * @throws If 'presence' isn't a valid presence enum value.\n   */\n  setPresence(opts) {\n    var _this48 = this;\n    return _asyncToGenerator(function* () {\n      var path = utils.encodeUri(\"/presence/$userId/status\", {\n        $userId: _this48.credentials.userId\n      });\n      var validStates = [\"offline\", \"online\", \"unavailable\"];\n      if (validStates.indexOf(opts.presence) === -1) {\n        throw new Error(\"Bad presence value: \" + opts.presence);\n      }\n      yield _this48.http.authedRequest(Method.Put, path, undefined, opts);\n    })();\n  }\n\n  /**\n   * @param userId - The user to get presence for\n   * @returns Promise which resolves: The presence state for this user.\n   * @returns Rejects: with an error response.\n   */\n  getPresence(userId) {\n    var path = utils.encodeUri(\"/presence/$userId/status\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Retrieve older messages from the given room and put them in the timeline.\n   *\n   * If this is called multiple times whilst a request is ongoing, the <i>same</i>\n   * Promise will be returned. If there was a problem requesting scrollback, there\n   * will be a small delay before another request can be made (to prevent tight-looping\n   * when there is no connection).\n   *\n   * @param room - The room to get older messages in.\n   * @param limit - Optional. The maximum number of previous events to\n   * pull in. Default: 30.\n   * @returns Promise which resolves: Room. If you are at the beginning\n   * of the timeline, `Room.oldState.paginationToken` will be\n   * `null`.\n   * @returns Rejects: with an error response.\n   */\n  scrollback(room) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n    var timeToWaitMs = 0;\n    var info = this.ongoingScrollbacks[room.roomId] || {};\n    if (info.promise) {\n      return info.promise;\n    } else if (info.errorTs) {\n      var timeWaitedMs = Date.now() - info.errorTs;\n      timeToWaitMs = Math.max(SCROLLBACK_DELAY_MS - timeWaitedMs, 0);\n    }\n    if (room.oldState.paginationToken === null) {\n      return Promise.resolve(room); // already at the start.\n    }\n    // attempt to grab more events from the store first\n    var numAdded = this.store.scrollback(room, limit).length;\n    if (numAdded === limit) {\n      // store contained everything we needed.\n      return Promise.resolve(room);\n    }\n    // reduce the required number of events appropriately\n    limit = limit - numAdded;\n    var promise = new Promise((resolve, reject) => {\n      // wait for a time before doing this request\n      // (which may be 0 in order not to special case the code paths)\n      sleep(timeToWaitMs).then(() => {\n        return this.createMessagesRequest(room.roomId, room.oldState.paginationToken, limit, Direction.Backward);\n      }).then(res => {\n        var _res$end, _res$end2;\n        var matrixEvents = res.chunk.map(this.getEventMapper());\n        if (res.state) {\n          var stateEvents = res.state.map(this.getEventMapper());\n          room.currentState.setUnknownStateEvents(stateEvents);\n        }\n        var [timelineEvents, threadedEvents, unknownRelations] = room.partitionThreadedEvents(matrixEvents);\n        this.processAggregatedTimelineEvents(room, timelineEvents);\n        room.addEventsToTimeline(timelineEvents, true, room.getLiveTimeline());\n        this.processThreadEvents(room, threadedEvents, true);\n        unknownRelations.forEach(event => room.relations.aggregateChildEvent(event));\n        room.oldState.paginationToken = (_res$end = res.end) !== null && _res$end !== void 0 ? _res$end : null;\n        if (res.chunk.length === 0) {\n          room.oldState.paginationToken = null;\n        }\n        this.store.storeEvents(room, matrixEvents, (_res$end2 = res.end) !== null && _res$end2 !== void 0 ? _res$end2 : null, true);\n        delete this.ongoingScrollbacks[room.roomId];\n        resolve(room);\n      }).catch(err => {\n        this.ongoingScrollbacks[room.roomId] = {\n          errorTs: Date.now()\n        };\n        reject(err);\n      });\n    });\n    info = {\n      promise\n    };\n    this.ongoingScrollbacks[room.roomId] = info;\n    return promise;\n  }\n  getEventMapper(options) {\n    return eventMapperFor(this, options || {});\n  }\n\n  /**\n   * Get an EventTimeline for the given event\n   *\n   * <p>If the EventTimelineSet object already has the given event in its store, the\n   * corresponding timeline will be returned. Otherwise, a /context request is\n   * made, and used to construct an EventTimeline.\n   * If the event does not belong to this EventTimelineSet then undefined will be returned.\n   *\n   * @param timelineSet -  The timelineSet to look for the event in, must be bound to a room\n   * @param eventId -  The ID of the event to look for\n   *\n   * @returns Promise which resolves:\n   *    {@link EventTimeline} including the given event\n   */\n  getEventTimeline(timelineSet, eventId) {\n    var _this49 = this;\n    return _asyncToGenerator(function* () {\n      var _this49$clientOpts, _ref5, _timelineSet$getTimel, _timelineSet$room$fin;\n      // don't allow any timeline support unless it's been enabled.\n      if (!_this49.timelineSupport) {\n        throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" + \" parameter to true when creating MatrixClient to enable it.\");\n      }\n      if (!(timelineSet !== null && timelineSet !== void 0 && timelineSet.room)) {\n        throw new Error(\"getEventTimeline only supports room timelines\");\n      }\n      if (timelineSet.getTimelineForEvent(eventId)) {\n        return timelineSet.getTimelineForEvent(eventId);\n      }\n      if (timelineSet.thread && _this49.supportsThreads()) {\n        return _this49.getThreadTimeline(timelineSet, eventId);\n      }\n      var path = utils.encodeUri(\"/rooms/$roomId/context/$eventId\", {\n        $roomId: timelineSet.room.roomId,\n        $eventId: eventId\n      });\n      var params = undefined;\n      if ((_this49$clientOpts = _this49.clientOpts) !== null && _this49$clientOpts !== void 0 && _this49$clientOpts.lazyLoadMembers) {\n        params = {\n          filter: JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER)\n        };\n      }\n\n      // TODO: we should implement a backoff (as per scrollback()) to deal more nicely with HTTP errors.\n      var res = yield _this49.http.authedRequest(Method.Get, path, params);\n      if (!res.event) {\n        throw new Error(\"'event' not in '/context' result - homeserver too old?\");\n      }\n\n      // by the time the request completes, the event might have ended up in the timeline.\n      if (timelineSet.getTimelineForEvent(eventId)) {\n        return timelineSet.getTimelineForEvent(eventId);\n      }\n      var mapper = _this49.getEventMapper();\n      var event = mapper(res.event);\n      if (event.isRelation(THREAD_RELATION_TYPE.name)) {\n        _this49.logger.warn(\"Tried loading a regular timeline at the position of a thread event\");\n        return undefined;\n      }\n      var events = [\n      // Order events from most recent to oldest (reverse-chronological).\n      // We start with the last event, since that's the point at which we have known state.\n      // events_after is already backwards; events_before is forwards.\n      ...res.events_after.reverse().map(mapper), event, ...res.events_before.map(mapper)];\n\n      // Here we handle non-thread timelines only, but still process any thread events to populate thread summaries.\n      var timeline = timelineSet.getTimelineForEvent(events[0].getId());\n      if (timeline) {\n        timeline.getState(EventTimeline.BACKWARDS).setUnknownStateEvents(res.state.map(mapper));\n      } else {\n        timeline = timelineSet.addTimeline();\n        timeline.initialiseState(res.state.map(mapper));\n        timeline.getState(EventTimeline.FORWARDS).paginationToken = res.end;\n      }\n      var [timelineEvents, threadedEvents, unknownRelations] = timelineSet.room.partitionThreadedEvents(events);\n      timelineSet.addEventsToTimeline(timelineEvents, true, timeline, res.start);\n      // The target event is not in a thread but process the contextual events, so we can show any threads around it.\n      _this49.processThreadEvents(timelineSet.room, threadedEvents, true);\n      _this49.processAggregatedTimelineEvents(timelineSet.room, timelineEvents);\n      unknownRelations.forEach(event => timelineSet.relations.aggregateChildEvent(event));\n\n      // There is no guarantee that the event ended up in \"timeline\" (we might have switched to a neighbouring\n      // timeline) - so check the room's index again. On the other hand, there's no guarantee the event ended up\n      // anywhere, if it was later redacted, so we just return the timeline we first thought of.\n      return (_ref5 = (_timelineSet$getTimel = timelineSet.getTimelineForEvent(eventId)) !== null && _timelineSet$getTimel !== void 0 ? _timelineSet$getTimel : (_timelineSet$room$fin = timelineSet.room.findThreadForEvent(event)) === null || _timelineSet$room$fin === void 0 ? void 0 : _timelineSet$room$fin.liveTimeline) !== null && _ref5 !== void 0 ? _ref5 :\n      // for Threads degraded support\n      timeline;\n    })();\n  }\n  getThreadTimeline(timelineSet, eventId) {\n    var _this50 = this;\n    return _asyncToGenerator(function* () {\n      var _this50$clientOpts;\n      if (!_this50.supportsThreads()) {\n        throw new Error(\"could not get thread timeline: no client support\");\n      }\n      if (!timelineSet.room) {\n        throw new Error(\"could not get thread timeline: not a room timeline\");\n      }\n      if (!timelineSet.thread) {\n        throw new Error(\"could not get thread timeline: not a thread timeline\");\n      }\n      var path = utils.encodeUri(\"/rooms/$roomId/context/$eventId\", {\n        $roomId: timelineSet.room.roomId,\n        $eventId: eventId\n      });\n      var params = {\n        limit: \"0\"\n      };\n      if ((_this50$clientOpts = _this50.clientOpts) !== null && _this50$clientOpts !== void 0 && _this50$clientOpts.lazyLoadMembers) {\n        params.filter = JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER);\n      }\n\n      // TODO: we should implement a backoff (as per scrollback()) to deal more nicely with HTTP errors.\n      var res = yield _this50.http.authedRequest(Method.Get, path, params);\n      var mapper = _this50.getEventMapper();\n      var event = mapper(res.event);\n      if (!timelineSet.canContain(event)) {\n        return undefined;\n      }\n      var recurse = _this50.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n      if (Thread.hasServerSideSupport) {\n        if (Thread.hasServerSideFwdPaginationSupport) {\n          var _resOlder$next_batch, _resNewer$next_batch, _timelineSet$getTimel2;\n          if (!timelineSet.thread) {\n            throw new Error(\"could not get thread timeline: not a thread timeline\");\n          }\n          var thread = timelineSet.thread;\n          var resOlder = yield _this50.fetchRelations(timelineSet.room.roomId, thread.id, null, null, {\n            dir: Direction.Backward,\n            from: res.start,\n            recurse: recurse || undefined\n          });\n          var resNewer = yield _this50.fetchRelations(timelineSet.room.roomId, thread.id, null, null, {\n            dir: Direction.Forward,\n            from: res.end,\n            recurse: recurse || undefined\n          });\n          var events = [\n          // Order events from most recent to oldest (reverse-chronological).\n          // We start with the last event, since that's the point at which we have known state.\n          // events_after is already backwards; events_before is forwards.\n          ...resNewer.chunk.reverse().filter(getRelationsThreadFilter(thread.id)).map(mapper), event, ...resOlder.chunk.filter(getRelationsThreadFilter(thread.id)).map(mapper)];\n          for (var _event2 of events) {\n            var _timelineSet$thread;\n            yield (_timelineSet$thread = timelineSet.thread) === null || _timelineSet$thread === void 0 ? void 0 : _timelineSet$thread.processEvent(_event2);\n          }\n\n          // Here we handle non-thread timelines only, but still process any thread events to populate thread summaries.\n          var timeline = timelineSet.getTimelineForEvent(event.getId());\n          if (timeline) {\n            timeline.getState(EventTimeline.BACKWARDS).setUnknownStateEvents(res.state.map(mapper));\n          } else {\n            timeline = timelineSet.addTimeline();\n            timeline.initialiseState(res.state.map(mapper));\n          }\n          timelineSet.addEventsToTimeline(events, true, timeline, resNewer.next_batch);\n          if (!resOlder.next_batch) {\n            var originalEvent = yield _this50.fetchRoomEvent(timelineSet.room.roomId, thread.id);\n            timelineSet.addEventsToTimeline([mapper(originalEvent)], true, timeline, null);\n          }\n          timeline.setPaginationToken((_resOlder$next_batch = resOlder.next_batch) !== null && _resOlder$next_batch !== void 0 ? _resOlder$next_batch : null, Direction.Backward);\n          timeline.setPaginationToken((_resNewer$next_batch = resNewer.next_batch) !== null && _resNewer$next_batch !== void 0 ? _resNewer$next_batch : null, Direction.Forward);\n          _this50.processAggregatedTimelineEvents(timelineSet.room, events);\n\n          // There is no guarantee that the event ended up in \"timeline\" (we might have switched to a neighbouring\n          // timeline) - so check the room's index again. On the other hand, there's no guarantee the event ended up\n          // anywhere, if it was later redacted, so we just return the timeline we first thought of.\n          return (_timelineSet$getTimel2 = timelineSet.getTimelineForEvent(eventId)) !== null && _timelineSet$getTimel2 !== void 0 ? _timelineSet$getTimel2 : timeline;\n        } else {\n          var _resOlder$next_batch2;\n          // Where the event is a thread reply (not a root) and running in MSC-enabled mode the Thread timeline only\n          // functions contiguously, so we have to jump through some hoops to get our target event in it.\n          // XXX: workaround for https://github.com/vector-im/element-meta/issues/150\n\n          var _thread = timelineSet.thread;\n          var _resOlder = yield _this50.fetchRelations(timelineSet.room.roomId, _thread.id, THREAD_RELATION_TYPE.name, null, {\n            dir: Direction.Backward,\n            from: res.start,\n            recurse: recurse || undefined\n          });\n          var eventsNewer = [];\n          var nextBatch = res.end;\n          while (nextBatch) {\n            var _resNewer$next_batch2;\n            var _resNewer = yield _this50.fetchRelations(timelineSet.room.roomId, _thread.id, THREAD_RELATION_TYPE.name, null, {\n              dir: Direction.Forward,\n              from: nextBatch,\n              recurse: recurse || undefined\n            });\n            nextBatch = (_resNewer$next_batch2 = _resNewer.next_batch) !== null && _resNewer$next_batch2 !== void 0 ? _resNewer$next_batch2 : null;\n            eventsNewer.push(..._resNewer.chunk);\n          }\n          var _events = [\n          // Order events from most recent to oldest (reverse-chronological).\n          // We start with the last event, since that's the point at which we have known state.\n          // events_after is already backwards; events_before is forwards.\n          ...eventsNewer.reverse().map(mapper), event, ..._resOlder.chunk.map(mapper)];\n          for (var _event3 of _events) {\n            var _timelineSet$thread2;\n            yield (_timelineSet$thread2 = timelineSet.thread) === null || _timelineSet$thread2 === void 0 ? void 0 : _timelineSet$thread2.processEvent(_event3);\n          }\n\n          // Here we handle non-thread timelines only, but still process any thread events to populate thread\n          // summaries.\n          var _timeline = timelineSet.getLiveTimeline();\n          _timeline.getState(EventTimeline.BACKWARDS).setUnknownStateEvents(res.state.map(mapper));\n          timelineSet.addEventsToTimeline(_events, true, _timeline, null);\n          if (!_resOlder.next_batch) {\n            var _originalEvent = yield _this50.fetchRoomEvent(timelineSet.room.roomId, _thread.id);\n            timelineSet.addEventsToTimeline([mapper(_originalEvent)], true, _timeline, null);\n          }\n          _timeline.setPaginationToken((_resOlder$next_batch2 = _resOlder.next_batch) !== null && _resOlder$next_batch2 !== void 0 ? _resOlder$next_batch2 : null, Direction.Backward);\n          _timeline.setPaginationToken(null, Direction.Forward);\n          _this50.processAggregatedTimelineEvents(timelineSet.room, _events);\n          return _timeline;\n        }\n      }\n    })();\n  }\n\n  /**\n   * Get an EventTimeline for the latest events in the room. This will just\n   * call `/messages` to get the latest message in the room, then use\n   * `client.getEventTimeline(...)` to construct a new timeline from it.\n   *\n   * @param timelineSet -  The timelineSet to find or add the timeline to\n   *\n   * @returns Promise which resolves:\n   *    {@link EventTimeline} timeline with the latest events in the room\n   */\n  getLatestTimeline(timelineSet) {\n    var _this51 = this;\n    return _asyncToGenerator(function* () {\n      // don't allow any timeline support unless it's been enabled.\n      if (!_this51.timelineSupport) {\n        throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" + \" parameter to true when creating MatrixClient to enable it.\");\n      }\n      if (!timelineSet.room) {\n        throw new Error(\"getLatestTimeline only supports room timelines\");\n      }\n      var event;\n      if (timelineSet.threadListType !== null) {\n        var _res$chunk;\n        var res = yield _this51.createThreadListMessagesRequest(timelineSet.room.roomId, null, 1, Direction.Backward, timelineSet.threadListType, timelineSet.getFilter());\n        event = (_res$chunk = res.chunk) === null || _res$chunk === void 0 ? void 0 : _res$chunk[0];\n      } else if (timelineSet.thread && Thread.hasServerSideSupport) {\n        var _res$chunk2;\n        var recurse = _this51.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n        var _res = yield _this51.fetchRelations(timelineSet.room.roomId, timelineSet.thread.id, THREAD_RELATION_TYPE.name, null, {\n          dir: Direction.Backward,\n          limit: 1,\n          recurse: recurse || undefined\n        });\n        event = (_res$chunk2 = _res.chunk) === null || _res$chunk2 === void 0 ? void 0 : _res$chunk2[0];\n      } else {\n        var _this51$clientOpts, _res2$chunk;\n        var messagesPath = utils.encodeUri(\"/rooms/$roomId/messages\", {\n          $roomId: timelineSet.room.roomId\n        });\n        var params = {\n          dir: \"b\"\n        };\n        if ((_this51$clientOpts = _this51.clientOpts) !== null && _this51$clientOpts !== void 0 && _this51$clientOpts.lazyLoadMembers) {\n          params.filter = JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER);\n        }\n        var _res2 = yield _this51.http.authedRequest(Method.Get, messagesPath, params);\n        event = (_res2$chunk = _res2.chunk) === null || _res2$chunk === void 0 ? void 0 : _res2$chunk[0];\n      }\n      if (!event) {\n        throw new Error(\"No message returned when trying to construct getLatestTimeline\");\n      }\n      return _this51.getEventTimeline(timelineSet, event.event_id);\n    })();\n  }\n\n  /**\n   * Makes a request to /messages with the appropriate lazy loading filter set.\n   * XXX: if we do get rid of scrollback (as it's not used at the moment),\n   * we could inline this method again in paginateEventTimeline as that would\n   * then be the only call-site\n   * @param limit - the maximum amount of events the retrieve\n   * @param dir - 'f' or 'b'\n   * @param timelineFilter - the timeline filter to pass\n   */\n  // XXX: Intended private, used in code.\n  createMessagesRequest(roomId, fromToken) {\n    var _this$clientOpts;\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30;\n    var dir = arguments.length > 3 ? arguments[3] : undefined;\n    var timelineFilter = arguments.length > 4 ? arguments[4] : undefined;\n    var path = utils.encodeUri(\"/rooms/$roomId/messages\", {\n      $roomId: roomId\n    });\n    var params = {\n      limit: limit.toString(),\n      dir: dir\n    };\n    if (fromToken) {\n      params.from = fromToken;\n    }\n    var filter = null;\n    if ((_this$clientOpts = this.clientOpts) !== null && _this$clientOpts !== void 0 && _this$clientOpts.lazyLoadMembers) {\n      // create a shallow copy of LAZY_LOADING_MESSAGES_FILTER,\n      // so the timelineFilter doesn't get written into it below\n      filter = Object.assign({}, Filter.LAZY_LOADING_MESSAGES_FILTER);\n    }\n    if (timelineFilter) {\n      var _timelineFilter$getRo;\n      // XXX: it's horrific that /messages' filter parameter doesn't match\n      // /sync's one - see https://matrix.org/jira/browse/SPEC-451\n      filter = filter || {};\n      Object.assign(filter, (_timelineFilter$getRo = timelineFilter.getRoomTimelineFilterComponent()) === null || _timelineFilter$getRo === void 0 ? void 0 : _timelineFilter$getRo.toJSON());\n    }\n    if (filter) {\n      params.filter = JSON.stringify(filter);\n    }\n    return this.http.authedRequest(Method.Get, path, params);\n  }\n\n  /**\n   * Makes a request to /messages with the appropriate lazy loading filter set.\n   * XXX: if we do get rid of scrollback (as it's not used at the moment),\n   * we could inline this method again in paginateEventTimeline as that would\n   * then be the only call-site\n   * @param limit - the maximum amount of events the retrieve\n   * @param dir - 'f' or 'b'\n   * @param timelineFilter - the timeline filter to pass\n   */\n  // XXX: Intended private, used by room.fetchRoomThreads\n  createThreadListMessagesRequest(roomId, fromToken) {\n    var _this$clientOpts2;\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30;\n    var dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Direction.Backward;\n    var threadListType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ThreadFilterType.All;\n    var timelineFilter = arguments.length > 5 ? arguments[5] : undefined;\n    var path = utils.encodeUri(\"/rooms/$roomId/threads\", {\n      $roomId: roomId\n    });\n    var params = {\n      limit: limit.toString(),\n      dir: dir,\n      include: threadFilterTypeToFilter(threadListType)\n    };\n    if (fromToken) {\n      params.from = fromToken;\n    }\n    var filter = {};\n    if ((_this$clientOpts2 = this.clientOpts) !== null && _this$clientOpts2 !== void 0 && _this$clientOpts2.lazyLoadMembers) {\n      // create a shallow copy of LAZY_LOADING_MESSAGES_FILTER,\n      // so the timelineFilter doesn't get written into it below\n      filter = _objectSpread({}, Filter.LAZY_LOADING_MESSAGES_FILTER);\n    }\n    if (timelineFilter) {\n      var _timelineFilter$getRo2;\n      // XXX: it's horrific that /messages' filter parameter doesn't match\n      // /sync's one - see https://matrix.org/jira/browse/SPEC-451\n      filter = _objectSpread(_objectSpread({}, filter), (_timelineFilter$getRo2 = timelineFilter.getRoomTimelineFilterComponent()) === null || _timelineFilter$getRo2 === void 0 ? void 0 : _timelineFilter$getRo2.toJSON());\n    }\n    if (Object.keys(filter).length) {\n      params.filter = JSON.stringify(filter);\n    }\n    var opts = {\n      prefix: Thread.hasServerSideListSupport === FeatureSupport.Stable ? ClientPrefix.V1 : \"/_matrix/client/unstable/org.matrix.msc3856\"\n    };\n    return this.http.authedRequest(Method.Get, path, params, undefined, opts).then(res => {\n      var _res$chunk3;\n      return _objectSpread(_objectSpread({}, res), {}, {\n        chunk: (_res$chunk3 = res.chunk) === null || _res$chunk3 === void 0 ? void 0 : _res$chunk3.reverse(),\n        start: res.prev_batch,\n        end: res.next_batch\n      });\n    });\n  }\n\n  /**\n   * Take an EventTimeline, and back/forward-fill results.\n   *\n   * @param eventTimeline - timeline object to be updated\n   *\n   * @returns Promise which resolves to a boolean: false if there are no\n   *    events and we reached either end of the timeline; else true.\n   */\n  paginateEventTimeline(eventTimeline, opts) {\n    var _this52 = this;\n    var isNotifTimeline = eventTimeline.getTimelineSet() === this.notifTimelineSet;\n    var room = this.getRoom(eventTimeline.getRoomId());\n    var threadListType = eventTimeline.getTimelineSet().threadListType;\n    var thread = eventTimeline.getTimelineSet().thread;\n\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n    opts = opts || {};\n    var backwards = opts.backwards || false;\n    if (isNotifTimeline) {\n      if (!backwards) {\n        throw new Error(\"paginateNotifTimeline can only paginate backwards\");\n      }\n    }\n    var dir = backwards ? EventTimeline.BACKWARDS : EventTimeline.FORWARDS;\n    var token = eventTimeline.getPaginationToken(dir);\n    var pendingRequest = eventTimeline.paginationRequests[dir];\n    if (pendingRequest) {\n      // already a request in progress - return the existing promise\n      return pendingRequest;\n    }\n    var path;\n    var params;\n    var promise;\n    if (isNotifTimeline) {\n      var _opts$limit;\n      path = \"/notifications\";\n      params = {\n        limit: ((_opts$limit = opts.limit) !== null && _opts$limit !== void 0 ? _opts$limit : 30).toString(),\n        only: \"highlight\"\n      };\n      if (token && token !== \"end\") {\n        params.from = token;\n      }\n      promise = this.http.authedRequest(Method.Get, path, params).then(/*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (res) {\n          var token = res.next_token;\n          var matrixEvents = [];\n          res.notifications = res.notifications.filter(noUnsafeEventProps);\n          for (var i = 0; i < res.notifications.length; i++) {\n            var notification = res.notifications[i];\n            var _event4 = _this52.getEventMapper()(notification.event);\n\n            // @TODO(kerrya) reprocessing every notification is ugly\n            // remove if we get server MSC3994 support\n            _this52.getPushDetailsForEvent(_event4, true);\n            _event4.event.room_id = notification.room_id; // XXX: gutwrenching\n            matrixEvents[i] = _event4;\n          }\n\n          // No need to partition events for threads here, everything lives\n          // in the notification timeline set\n          var timelineSet = eventTimeline.getTimelineSet();\n          timelineSet.addEventsToTimeline(matrixEvents, backwards, eventTimeline, token);\n          _this52.processAggregatedTimelineEvents(timelineSet.room, matrixEvents);\n\n          // if we've hit the end of the timeline, we need to stop trying to\n          // paginate. We need to keep the 'forwards' token though, to make sure\n          // we can recover from gappy syncs.\n          if (backwards && !res.next_token) {\n            eventTimeline.setPaginationToken(null, dir);\n          }\n          return Boolean(res.next_token);\n        });\n        return function (_x4) {\n          return _ref6.apply(this, arguments);\n        };\n      }()).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    } else if (threadListType !== null) {\n      if (!room) {\n        throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n      }\n      if (!Thread.hasServerSideFwdPaginationSupport && dir === Direction.Forward) {\n        throw new Error(\"Cannot paginate threads forwards without server-side support for MSC 3715\");\n      }\n      promise = this.createThreadListMessagesRequest(eventTimeline.getRoomId(), token, opts.limit, dir, threadListType, eventTimeline.getFilter()).then(res => {\n        if (res.state) {\n          var roomState = eventTimeline.getState(dir);\n          var stateEvents = res.state.filter(noUnsafeEventProps).map(this.getEventMapper());\n          roomState.setUnknownStateEvents(stateEvents);\n        }\n        var token = res.end;\n        var matrixEvents = res.chunk.filter(noUnsafeEventProps).map(this.getEventMapper());\n        var timelineSet = eventTimeline.getTimelineSet();\n        timelineSet.addEventsToTimeline(matrixEvents, backwards, eventTimeline, token);\n        this.processAggregatedTimelineEvents(room, matrixEvents);\n        this.processThreadRoots(room, matrixEvents, backwards);\n\n        // if we've hit the end of the timeline, we need to stop trying to\n        // paginate. We need to keep the 'forwards' token though, to make sure\n        // we can recover from gappy syncs.\n        if (backwards && res.end == res.start) {\n          eventTimeline.setPaginationToken(null, dir);\n        }\n        return res.end !== res.start;\n      }).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    } else if (thread) {\n      var _eventTimeline$getRoo, _eventTimeline$getRoo2;\n      var _room4 = this.getRoom((_eventTimeline$getRoo = eventTimeline.getRoomId()) !== null && _eventTimeline$getRoo !== void 0 ? _eventTimeline$getRoo : undefined);\n      if (!_room4) {\n        throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n      }\n      var recurse = this.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n      promise = this.fetchRelations((_eventTimeline$getRoo2 = eventTimeline.getRoomId()) !== null && _eventTimeline$getRoo2 !== void 0 ? _eventTimeline$getRoo2 : \"\", thread.id, null, null, {\n        dir,\n        limit: opts.limit,\n        from: token !== null && token !== void 0 ? token : undefined,\n        recurse: recurse || undefined\n      }).then(/*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (res) {\n          var mapper = _this52.getEventMapper();\n          var matrixEvents = res.chunk.filter(noUnsafeEventProps).filter(getRelationsThreadFilter(thread.id)).map(mapper);\n\n          // Process latest events first\n          for (var _event5 of matrixEvents.slice().reverse()) {\n            yield thread === null || thread === void 0 ? void 0 : thread.processEvent(_event5);\n            var sender = _event5.getSender();\n            if (!backwards || (thread === null || thread === void 0 ? void 0 : thread.getEventReadUpTo(sender)) === null) {\n              _room4.addLocalEchoReceipt(sender, _event5, ReceiptType.Read);\n            }\n          }\n          var newToken = res.next_batch;\n          var timelineSet = eventTimeline.getTimelineSet();\n          timelineSet.addEventsToTimeline(matrixEvents, backwards, eventTimeline, newToken !== null && newToken !== void 0 ? newToken : null);\n          if (!newToken && backwards) {\n            var _thread$rootEvent, _eventTimeline$getRoo3;\n            var originalEvent = (_thread$rootEvent = thread.rootEvent) !== null && _thread$rootEvent !== void 0 ? _thread$rootEvent : mapper(yield _this52.fetchRoomEvent((_eventTimeline$getRoo3 = eventTimeline.getRoomId()) !== null && _eventTimeline$getRoo3 !== void 0 ? _eventTimeline$getRoo3 : \"\", thread.id));\n            timelineSet.addEventsToTimeline([originalEvent], true, eventTimeline, null);\n          }\n          _this52.processAggregatedTimelineEvents(timelineSet.room, matrixEvents);\n\n          // if we've hit the end of the timeline, we need to stop trying to\n          // paginate. We need to keep the 'forwards' token though, to make sure\n          // we can recover from gappy syncs.\n          if (backwards && !newToken) {\n            eventTimeline.setPaginationToken(null, dir);\n          }\n          return Boolean(newToken);\n        });\n        return function (_x5) {\n          return _ref7.apply(this, arguments);\n        };\n      }()).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    } else {\n      if (!room) {\n        throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n      }\n      promise = this.createMessagesRequest(eventTimeline.getRoomId(), token, opts.limit, dir, eventTimeline.getFilter()).then(res => {\n        if (res.state) {\n          var roomState = eventTimeline.getState(dir);\n          var stateEvents = res.state.filter(noUnsafeEventProps).map(this.getEventMapper());\n          roomState.setUnknownStateEvents(stateEvents);\n        }\n        var token = res.end;\n        var matrixEvents = res.chunk.filter(noUnsafeEventProps).map(this.getEventMapper());\n        var timelineSet = eventTimeline.getTimelineSet();\n        var [timelineEvents,, unknownRelations] = room.partitionThreadedEvents(matrixEvents);\n        timelineSet.addEventsToTimeline(timelineEvents, backwards, eventTimeline, token);\n        this.processAggregatedTimelineEvents(room, timelineEvents);\n        this.processThreadRoots(room, timelineEvents.filter(it => it.getServerAggregatedRelation(THREAD_RELATION_TYPE.name)), false);\n        unknownRelations.forEach(event => room.relations.aggregateChildEvent(event));\n        var atEnd = res.end === undefined || res.end === res.start;\n\n        // if we've hit the end of the timeline, we need to stop trying to\n        // paginate. We need to keep the 'forwards' token though, to make sure\n        // we can recover from gappy syncs.\n        if (backwards && atEnd) {\n          eventTimeline.setPaginationToken(null, dir);\n        }\n        return !atEnd;\n      }).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    }\n    return promise;\n  }\n\n  /**\n   * Reset the notifTimelineSet entirely, paginating in some historical notifs as\n   * a starting point for subsequent pagination.\n   */\n  resetNotifTimelineSet() {\n    if (!this.notifTimelineSet) {\n      return;\n    }\n\n    // FIXME: This thing is a total hack, and results in duplicate events being\n    // added to the timeline both from /sync and /notifications, and lots of\n    // slow and wasteful processing and pagination.  The correct solution is to\n    // extend /messages or /search or something to filter on notifications.\n\n    // use the fictitious token 'end'. in practice we would ideally give it\n    // the oldest backwards pagination token from /sync, but /sync doesn't\n    // know about /notifications, so we have no choice but to start paginating\n    // from the current point in time.  This may well overlap with historical\n    // notifs which are then inserted into the timeline by /sync responses.\n    this.notifTimelineSet.resetLiveTimeline(\"end\");\n\n    // we could try to paginate a single event at this point in order to get\n    // a more valid pagination token, but it just ends up with an out of order\n    // timeline. given what a mess this is and given we're going to have duplicate\n    // events anyway, just leave it with the dummy token for now.\n    /*\n    this.paginateNotifTimeline(this._notifTimelineSet.getLiveTimeline(), {\n        backwards: true,\n        limit: 1\n    });\n    */\n  }\n\n  /**\n   * Peek into a room and receive updates about the room. This only works if the\n   * history visibility for the room is world_readable.\n   * @param roomId - The room to attempt to peek into.\n   * @param limit - The number of timeline events to initially retrieve.\n   * @returns Promise which resolves: Room object\n   * @returns Rejects: with an error response.\n   */\n  peekInRoom(roomId) {\n    var _this$peekSync2;\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n    (_this$peekSync2 = this.peekSync) === null || _this$peekSync2 === void 0 || _this$peekSync2.stopPeeking();\n    this.peekSync = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n    return this.peekSync.peek(roomId, limit);\n  }\n\n  /**\n   * Stop any ongoing room peeking.\n   */\n  stopPeeking() {\n    if (this.peekSync) {\n      this.peekSync.stopPeeking();\n      this.peekSync = null;\n    }\n  }\n\n  /**\n   * Set r/w flags for guest access in a room.\n   * @param roomId - The room to configure guest access in.\n   * @param opts - Options\n   * @returns Promise which resolves\n   * @returns Rejects: with an error response.\n   */\n  setGuestAccess(roomId, opts) {\n    var writePromise = this.sendStateEvent(roomId, EventType.RoomGuestAccess, {\n      guest_access: opts.allowJoin ? GuestAccess.CanJoin : GuestAccess.Forbidden\n    }, \"\");\n    var readPromise = Promise.resolve();\n    if (opts.allowRead) {\n      readPromise = this.sendStateEvent(roomId, EventType.RoomHistoryVisibility, {\n        history_visibility: HistoryVisibility.WorldReadable\n      }, \"\");\n    }\n    return Promise.all([readPromise, writePromise]).then(); // .then() to hide results for contract\n  }\n\n  /**\n   * Requests an email verification token for the purposes of registration.\n   * This API requests a token from the homeserver.\n   * The doesServerRequireIdServerParam() method can be used to determine if\n   * the server requires the id_server parameter to be provided.\n   *\n   * Parameters and return value are as for requestEmailToken\n    * @param email - As requestEmailToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestRegisterEmailToken(email, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/register/email/requestToken\", {\n      email: email,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests a text message verification token for the purposes of registration.\n   * This API requests a token from the homeserver.\n   * The doesServerRequireIdServerParam() method can be used to determine if\n   * the server requires the id_server parameter to be provided.\n   *\n   * @param phoneCountry - The ISO 3166-1 alpha-2 code for the country in which\n   *    phoneNumber should be parsed relative to.\n   * @param phoneNumber - The phone number, in national or international format\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestRegisterMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/register/msisdn/requestToken\", {\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests an email verification token for the purposes of adding a\n   * third party identifier to an account.\n   * This API requests a token from the homeserver.\n   * The doesServerRequireIdServerParam() method can be used to determine if\n   * the server requires the id_server parameter to be provided.\n   * If an account with the given email address already exists and is\n   * associated with an account other than the one the user is authed as,\n   * it will either send an email to the address informing them of this\n   * or return M_THREEPID_IN_USE (which one is up to the homeserver).\n   *\n   * @param email - As requestEmailToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestAdd3pidEmailToken(email, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/3pid/email/requestToken\", {\n      email: email,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests a text message verification token for the purposes of adding a\n   * third party identifier to an account.\n   * This API proxies the identity server /validate/email/requestToken API,\n   * adding specific behaviour for the addition of phone numbers to an\n   * account, as requestAdd3pidEmailToken.\n   *\n   * @param phoneCountry - As requestRegisterMsisdnToken\n   * @param phoneNumber - As requestRegisterMsisdnToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestAdd3pidMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/3pid/msisdn/requestToken\", {\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests an email verification token for the purposes of resetting\n   * the password on an account.\n   * This API proxies the identity server /validate/email/requestToken API,\n   * adding specific behaviour for the password resetting. Specifically,\n   * if no account with the given email address exists, it may either\n   * return M_THREEPID_NOT_FOUND or send an email\n   * to the address informing them of this (which one is up to the homeserver).\n   *\n   * requestEmailToken calls the equivalent API directly on the identity server,\n   * therefore bypassing the password reset specific logic.\n   *\n   * @param email - As requestEmailToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestPasswordEmailToken(email, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/password/email/requestToken\", {\n      email: email,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests a text message verification token for the purposes of resetting\n   * the password on an account.\n   * This API proxies the identity server /validate/email/requestToken API,\n   * adding specific behaviour for the password resetting, as requestPasswordEmailToken.\n   *\n   * @param phoneCountry - As requestRegisterMsisdnToken\n   * @param phoneNumber - As requestRegisterMsisdnToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestPasswordMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/password/msisdn/requestToken\", {\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Internal utility function for requesting validation tokens from usage-specific\n   * requestToken endpoints.\n   *\n   * @param endpoint - The endpoint to send the request to\n   * @param params - Parameters for the POST request\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestTokenFromEndpoint(endpoint, params) {\n    var _this53 = this;\n    return _asyncToGenerator(function* () {\n      var postParams = Object.assign({}, params);\n      return _this53.http.request(Method.Post, endpoint, undefined, postParams);\n    })();\n  }\n\n  /**\n   * Get the room-kind push rule associated with a room.\n   * @param scope - \"global\" or device-specific.\n   * @param roomId - the id of the room.\n   * @returns the rule or undefined.\n   */\n  getRoomPushRule(scope, roomId) {\n    // There can be only room-kind push rule per room\n    // and its id is the room id.\n    if (this.pushRules) {\n      var _this$pushRules$scope;\n      return (_this$pushRules$scope = this.pushRules[scope]) === null || _this$pushRules$scope === void 0 || (_this$pushRules$scope = _this$pushRules$scope.room) === null || _this$pushRules$scope === void 0 ? void 0 : _this$pushRules$scope.find(rule => rule.rule_id === roomId);\n    } else {\n      throw new Error(\"SyncApi.sync() must be done before accessing to push rules.\");\n    }\n  }\n\n  /**\n   * Set a room-kind muting push rule in a room.\n   * The operation also updates MatrixClient.pushRules at the end.\n   * @param scope - \"global\" or device-specific.\n   * @param roomId - the id of the room.\n   * @param mute - the mute state.\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  setRoomMutePushRule(scope, roomId, mute) {\n    var promise;\n    var hasDontNotifyRule = false;\n\n    // Get the existing room-kind push rule if any\n    var roomPushRule = this.getRoomPushRule(scope, roomId);\n    if (roomPushRule !== null && roomPushRule !== void 0 && roomPushRule.actions.includes(PushRuleActionName.DontNotify)) {\n      hasDontNotifyRule = true;\n    }\n    if (!mute) {\n      // Remove the rule only if it is a muting rule\n      if (hasDontNotifyRule) {\n        promise = this.deletePushRule(scope, PushRuleKind.RoomSpecific, roomPushRule.rule_id);\n      }\n    } else {\n      if (!roomPushRule) {\n        promise = this.addPushRule(scope, PushRuleKind.RoomSpecific, roomId, {\n          actions: [PushRuleActionName.DontNotify]\n        });\n      } else if (!hasDontNotifyRule) {\n        // Remove the existing one before setting the mute push rule\n        // This is a workaround to SYN-590 (Push rule update fails)\n        var deferred = utils.defer();\n        this.deletePushRule(scope, PushRuleKind.RoomSpecific, roomPushRule.rule_id).then(() => {\n          this.addPushRule(scope, PushRuleKind.RoomSpecific, roomId, {\n            actions: [PushRuleActionName.DontNotify]\n          }).then(() => {\n            deferred.resolve();\n          }).catch(err => {\n            deferred.reject(err);\n          });\n        }).catch(err => {\n          deferred.reject(err);\n        });\n        promise = deferred.promise;\n      }\n    }\n    if (promise) {\n      return new Promise((resolve, reject) => {\n        // Update this.pushRules when the operation completes\n        promise.then(() => {\n          this.getPushRules().then(result => {\n            this.pushRules = result;\n            resolve();\n          }).catch(err => {\n            reject(err);\n          });\n        }).catch(err => {\n          // Update it even if the previous operation fails. This can help the\n          // app to recover when push settings has been modified from another client\n          this.getPushRules().then(result => {\n            this.pushRules = result;\n            reject(err);\n          }).catch(err2 => {\n            reject(err);\n          });\n        });\n      });\n    }\n  }\n  searchMessageText(opts) {\n    var roomEvents = {\n      search_term: opts.query\n    };\n    if (\"keys\" in opts) {\n      roomEvents.keys = opts.keys;\n    }\n    return this.search({\n      body: {\n        search_categories: {\n          room_events: roomEvents\n        }\n      }\n    });\n  }\n\n  /**\n   * Perform a server-side search for room events.\n   *\n   * The returned promise resolves to an object containing the fields:\n   *\n   *  * count:       estimate of the number of results\n   *  * next_batch:  token for back-pagination; if undefined, there are no more results\n   *  * highlights:  a list of words to highlight from the stemming algorithm\n   *  * results:     a list of results\n   *\n   * Each entry in the results list is a SearchResult.\n   *\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  searchRoomEvents(opts) {\n    // TODO: support search groups\n\n    var body = {\n      search_categories: {\n        room_events: {\n          search_term: opts.term,\n          filter: opts.filter,\n          order_by: SearchOrderBy.Recent,\n          event_context: {\n            before_limit: 1,\n            after_limit: 1,\n            include_profile: true\n          }\n        }\n      }\n    };\n    var searchResults = {\n      _query: body,\n      results: [],\n      highlights: []\n    };\n    return this.search({\n      body: body\n    }).then(res => this.processRoomEventsSearch(searchResults, res));\n  }\n\n  /**\n   * Take a result from an earlier searchRoomEvents call, and backfill results.\n   *\n   * @param searchResults -  the results object to be updated\n   * @returns Promise which resolves: updated result object\n   * @returns Rejects: with an error response.\n   */\n  backPaginateRoomEventsSearch(searchResults) {\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n\n    if (!searchResults.next_batch) {\n      return Promise.reject(new Error(\"Cannot backpaginate event search any further\"));\n    }\n    if (searchResults.pendingRequest) {\n      // already a request in progress - return the existing promise\n      return searchResults.pendingRequest;\n    }\n    var searchOpts = {\n      body: searchResults._query,\n      next_batch: searchResults.next_batch\n    };\n    var promise = this.search(searchOpts, searchResults.abortSignal).then(res => this.processRoomEventsSearch(searchResults, res)).finally(() => {\n      searchResults.pendingRequest = undefined;\n    });\n    searchResults.pendingRequest = promise;\n    return promise;\n  }\n\n  /**\n   * helper for searchRoomEvents and backPaginateRoomEventsSearch. Processes the\n   * response from the API call and updates the searchResults\n   *\n   * @returns searchResults\n   * @internal\n   */\n  // XXX: Intended private, used in code\n  processRoomEventsSearch(searchResults, response) {\n    var _roomEvents$results$l, _roomEvents$results;\n    var roomEvents = response.search_categories.room_events;\n    searchResults.count = roomEvents.count;\n    searchResults.next_batch = roomEvents.next_batch;\n\n    // combine the highlight list with our existing list;\n    var highlights = new Set(roomEvents.highlights);\n    searchResults.highlights.forEach(hl => {\n      highlights.add(hl);\n    });\n\n    // turn it back into a list.\n    searchResults.highlights = Array.from(highlights);\n    var mapper = this.getEventMapper();\n\n    // append the new results to our existing results\n    var resultsLength = (_roomEvents$results$l = (_roomEvents$results = roomEvents.results) === null || _roomEvents$results === void 0 ? void 0 : _roomEvents$results.length) !== null && _roomEvents$results$l !== void 0 ? _roomEvents$results$l : 0;\n    for (var i = 0; i < resultsLength; i++) {\n      var sr = SearchResult.fromJson(roomEvents.results[i], mapper);\n      var _room5 = this.getRoom(sr.context.getEvent().getRoomId());\n      if (_room5) {\n        // Copy over a known event sender if we can\n        for (var ev of sr.context.getTimeline()) {\n          var sender = _room5.getMember(ev.getSender());\n          if (!ev.sender && sender) ev.sender = sender;\n        }\n      }\n      searchResults.results.push(sr);\n    }\n    return searchResults;\n  }\n\n  /**\n   * Populate the store with rooms the user has left.\n   * @returns Promise which resolves: TODO - Resolved when the rooms have\n   * been added to the data store.\n   * @returns Rejects: with an error response.\n   */\n  syncLeftRooms() {\n    // Guard against multiple calls whilst ongoing and multiple calls post success\n    if (this.syncedLeftRooms) {\n      return Promise.resolve([]); // don't call syncRooms again if it succeeded.\n    }\n    if (this.syncLeftRoomsPromise) {\n      return this.syncLeftRoomsPromise; // return the ongoing request\n    }\n    var syncApi = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n    this.syncLeftRoomsPromise = syncApi.syncLeftRooms();\n\n    // cleanup locks\n    this.syncLeftRoomsPromise.then(() => {\n      this.logger.debug(\"Marking success of sync left room request\");\n      this.syncedLeftRooms = true; // flip the bit on success\n    }).finally(() => {\n      this.syncLeftRoomsPromise = undefined; // cleanup ongoing request state\n    });\n    return this.syncLeftRoomsPromise;\n  }\n\n  /**\n   * Create a new filter.\n   * @param content - The HTTP body for the request\n   * @returns Promise which resolves to a Filter object.\n   * @returns Rejects: with an error response.\n   */\n  createFilter(content) {\n    var path = utils.encodeUri(\"/user/$userId/filter\", {\n      $userId: this.credentials.userId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, content).then(response => {\n      // persist the filter\n      var filter = Filter.fromJson(this.credentials.userId, response.filter_id, content);\n      this.store.storeFilter(filter);\n      return filter;\n    });\n  }\n\n  /**\n   * Retrieve a filter.\n   * @param userId - The user ID of the filter owner\n   * @param filterId - The filter ID to retrieve\n   * @param allowCached - True to allow cached filters to be returned.\n   * Default: True.\n   * @returns Promise which resolves: a Filter object\n   * @returns Rejects: with an error response.\n   */\n  getFilter(userId, filterId, allowCached) {\n    if (allowCached) {\n      var filter = this.store.getFilter(userId, filterId);\n      if (filter) {\n        return Promise.resolve(filter);\n      }\n    }\n    var path = utils.encodeUri(\"/user/$userId/filter/$filterId\", {\n      $userId: userId,\n      $filterId: filterId\n    });\n    return this.http.authedRequest(Method.Get, path).then(response => {\n      // persist the filter\n      var filter = Filter.fromJson(userId, filterId, response);\n      this.store.storeFilter(filter);\n      return filter;\n    });\n  }\n\n  /**\n   * @returns Filter ID\n   */\n  getOrCreateFilter(filterName, filter) {\n    var _this54 = this;\n    return _asyncToGenerator(function* () {\n      var filterId = _this54.store.getFilterIdByName(filterName);\n      var existingId;\n      if (filterId) {\n        // check that the existing filter matches our expectations\n        try {\n          var existingFilter = yield _this54.getFilter(_this54.credentials.userId, filterId, true);\n          if (existingFilter) {\n            var oldDef = existingFilter.getDefinition();\n            var newDef = filter.getDefinition();\n            if (utils.deepCompare(oldDef, newDef)) {\n              // super, just use that.\n              // debuglog(\"Using existing filter ID %s: %s\", filterId,\n              //          JSON.stringify(oldDef));\n              existingId = filterId;\n            }\n          }\n        } catch (error) {\n          // Synapse currently returns the following when the filter cannot be found:\n          // {\n          //     errcode: \"M_UNKNOWN\",\n          //     name: \"M_UNKNOWN\",\n          //     message: \"No row found\",\n          // }\n          if (error.errcode !== \"M_UNKNOWN\" && error.errcode !== \"M_NOT_FOUND\") {\n            throw error;\n          }\n        }\n        // if the filter doesn't exist anymore on the server, remove from store\n        if (!existingId) {\n          _this54.store.setFilterIdByName(filterName, undefined);\n        }\n      }\n      if (existingId) {\n        return existingId;\n      }\n\n      // create a new filter\n      var createdFilter = yield _this54.createFilter(filter.getDefinition());\n      _this54.store.setFilterIdByName(filterName, createdFilter.filterId);\n      return createdFilter.filterId;\n    })();\n  }\n\n  /**\n   * Gets a bearer token from the homeserver that the user can\n   * present to a third party in order to prove their ownership\n   * of the Matrix account they are logged into.\n   * @returns Promise which resolves: Token object\n   * @returns Rejects: with an error response.\n   */\n  getOpenIdToken() {\n    var path = utils.encodeUri(\"/user/$userId/openid/request_token\", {\n      $userId: this.credentials.userId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {});\n  }\n  /**\n   * @returns Promise which resolves: ITurnServerResponse object\n   * @returns Rejects: with an error response.\n   */\n  turnServer() {\n    return this.http.authedRequest(Method.Get, \"/voip/turnServer\");\n  }\n\n  /**\n   * Get the TURN servers for this homeserver.\n   * @returns The servers or an empty list.\n   */\n  getTurnServers() {\n    return this.turnServers || [];\n  }\n\n  /**\n   * Get the unix timestamp (in milliseconds) at which the current\n   * TURN credentials (from getTurnServers) expire\n   * @returns The expiry timestamp in milliseconds\n   */\n  getTurnServersExpiry() {\n    return this.turnServersExpiry;\n  }\n  get pollingTurnServers() {\n    return this.checkTurnServersIntervalID !== undefined;\n  }\n\n  // XXX: Intended private, used in code.\n  checkTurnServers() {\n    var _this55 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this55.canSupportVoip) {\n        return;\n      }\n      var credentialsGood = false;\n      var remainingTime = _this55.turnServersExpiry - Date.now();\n      if (remainingTime > TURN_CHECK_INTERVAL) {\n        _this55.logger.debug(\"TURN creds are valid for another \" + remainingTime + \" ms: not fetching new ones.\");\n        credentialsGood = true;\n      } else {\n        _this55.logger.debug(\"Fetching new TURN credentials\");\n        try {\n          var res = yield _this55.turnServer();\n          if (res.uris) {\n            _this55.logger.debug(\"Got TURN URIs: \" + res.uris + \" refresh in \" + res.ttl + \" secs\");\n            // map the response to a format that can be fed to RTCPeerConnection\n            var servers = {\n              urls: res.uris,\n              username: res.username,\n              credential: res.password\n            };\n            _this55.turnServers = [servers];\n            // The TTL is in seconds but we work in ms\n            _this55.turnServersExpiry = Date.now() + res.ttl * 1000;\n            credentialsGood = true;\n            _this55.emit(ClientEvent.TurnServers, _this55.turnServers);\n          }\n        } catch (err) {\n          _this55.logger.error(\"Failed to get TURN URIs\", err);\n          if (err.httpStatus === 403) {\n            // We got a 403, so there's no point in looping forever.\n            _this55.logger.info(\"TURN access unavailable for this account: stopping credentials checks\");\n            if (_this55.checkTurnServersIntervalID !== null) global.clearInterval(_this55.checkTurnServersIntervalID);\n            _this55.checkTurnServersIntervalID = undefined;\n            _this55.emit(ClientEvent.TurnServersError, err, true); // fatal\n          } else {\n            // otherwise, if we failed for whatever reason, try again the next time we're called.\n            _this55.emit(ClientEvent.TurnServersError, err, false); // non-fatal\n          }\n        }\n      }\n      return credentialsGood;\n    })();\n  }\n\n  /**\n   * Set whether to allow a fallback ICE server should be used for negotiating a\n   * WebRTC connection if the homeserver doesn't provide any servers. Defaults to\n   * false.\n   *\n   */\n  setFallbackICEServerAllowed(allow) {\n    this.fallbackICEServerAllowed = allow;\n  }\n\n  /**\n   * Get whether to allow a fallback ICE server should be used for negotiating a\n   * WebRTC connection if the homeserver doesn't provide any servers. Defaults to\n   * false.\n   *\n   * @returns\n   */\n  isFallbackICEServerAllowed() {\n    return this.fallbackICEServerAllowed;\n  }\n\n  /**\n   * Determines if the current user is an administrator of the Synapse homeserver.\n   * Returns false if untrue or the homeserver does not appear to be a Synapse\n   * homeserver. <strong>This function is implementation specific and may change\n   * as a result.</strong>\n   * @returns true if the user appears to be a Synapse administrator.\n   */\n  isSynapseAdministrator() {\n    var path = utils.encodeUri(\"/_synapse/admin/v1/users/$userId/admin\", {\n      $userId: this.getUserId()\n    });\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix: \"\"\n    }).then(r => r.admin); // pull out the specific boolean we want\n  }\n\n  /**\n   * Performs a whois lookup on a user using Synapse's administrator API.\n   * <strong>This function is implementation specific and may change as a\n   * result.</strong>\n   * @param userId - the User ID to look up.\n   * @returns the whois response - see Synapse docs for information.\n   */\n  whoisSynapseUser(userId) {\n    var path = utils.encodeUri(\"/_synapse/admin/v1/whois/$userId\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix: \"\"\n    });\n  }\n\n  /**\n   * Deactivates a user using Synapse's administrator API. <strong>This\n   * function is implementation specific and may change as a result.</strong>\n   * @param userId - the User ID to deactivate.\n   * @returns the deactivate response - see Synapse docs for information.\n   */\n  deactivateSynapseUser(userId) {\n    var path = utils.encodeUri(\"/_synapse/admin/v1/deactivate/$userId\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, undefined, {\n      prefix: \"\"\n    });\n  }\n  fetchClientWellKnown() {\n    var _this56 = this;\n    return _asyncToGenerator(function* () {\n      var _this56$getDomain;\n      // `getRawClientConfig` does not throw or reject on network errors, instead\n      // it absorbs errors and returns `{}`.\n      _this56.clientWellKnownPromise = AutoDiscovery.getRawClientConfig((_this56$getDomain = _this56.getDomain()) !== null && _this56$getDomain !== void 0 ? _this56$getDomain : undefined);\n      _this56.clientWellKnown = yield _this56.clientWellKnownPromise;\n      _this56.emit(ClientEvent.ClientWellKnown, _this56.clientWellKnown);\n    })();\n  }\n  getClientWellKnown() {\n    return this.clientWellKnown;\n  }\n  waitForClientWellKnown() {\n    if (!this.clientRunning) {\n      throw new Error(\"Client is not running\");\n    }\n    return this.clientWellKnownPromise;\n  }\n\n  /**\n   * store client options with boolean/string/numeric values\n   * to know in the next session what flags the sync data was\n   * created with (e.g. lazy loading)\n   * @returns for store operation\n   */\n  storeClientOptions() {\n    // XXX: Intended private, used in code\n    var primTypes = [\"boolean\", \"string\", \"number\"];\n    var serializableOpts = Object.entries(this.clientOpts).filter(_ref8 => {\n      var [key, value] = _ref8;\n      return primTypes.includes(typeof value);\n    }).reduce((obj, _ref9) => {\n      var [key, value] = _ref9;\n      obj[key] = value;\n      return obj;\n    }, {});\n    return this.store.storeClientOptions(serializableOpts);\n  }\n\n  /**\n   * Gets a set of room IDs in common with another user.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC2666](https://github.com/matrix-org/matrix-spec-proposals/pull/2666) for more details.\n   *\n   * @param userId - The userId to check.\n   * @returns Promise which resolves to an array of rooms\n   * @returns Rejects: with an error response.\n   */\n  // TODO: on spec release, rename this to getMutualRooms\n  // eslint-disable-next-line\n  _unstable_getSharedRooms(userId) {\n    var _this57 = this;\n    return _asyncToGenerator(function* () {\n      // Initial variant of the MSC\n      var sharedRoomsSupport = yield _this57.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_SHARED_ROOMS);\n\n      // Newer variant that renamed shared rooms to mutual rooms\n      var mutualRoomsSupport = yield _this57.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_MUTUAL_ROOMS);\n\n      // Latest variant that changed from path elements to query elements\n      var queryMutualRoomsSupport = yield _this57.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_QUERY_MUTUAL_ROOMS);\n      if (!sharedRoomsSupport && !mutualRoomsSupport && !queryMutualRoomsSupport) {\n        throw Error(\"Server does not support the Mutual Rooms API\");\n      }\n      var path;\n      var query;\n\n      // Cascading unstable support switching.\n      if (queryMutualRoomsSupport) {\n        path = \"/uk.half-shot.msc2666/user/mutual_rooms\";\n        query = {\n          user_id: userId\n        };\n      } else {\n        path = utils.encodeUri(\"/uk.half-shot.msc2666/user/\".concat(mutualRoomsSupport ? \"mutual_rooms\" : \"shared_rooms\", \"/$userId\"), {\n          $userId: userId\n        });\n        query = {};\n      }\n\n      // Accumulated rooms\n      var rooms = [];\n      var token = null;\n      do {\n        var tokenQuery = {};\n        if (token != null && queryMutualRoomsSupport) {\n          tokenQuery[\"batch_token\"] = token;\n        }\n        var res = yield _this57.http.authedRequest(Method.Get, path, _objectSpread(_objectSpread({}, query), tokenQuery), undefined, {\n          prefix: ClientPrefix.Unstable\n        });\n        rooms.push(...res.joined);\n        if (res.next_batch_token !== undefined) {\n          token = res.next_batch_token;\n        } else {\n          token = null;\n        }\n      } while (token != null);\n      return rooms;\n    })();\n  }\n\n  /**\n   * Get the API versions supported by the server, along with any\n   * unstable APIs it supports\n   * @returns The server /versions response\n   */\n  getVersions() {\n    var _this58 = this;\n    return _asyncToGenerator(function* () {\n      if (_this58.serverVersionsPromise) {\n        return _this58.serverVersionsPromise;\n      }\n\n      // We send an authenticated request as of MSC4026\n      _this58.serverVersionsPromise = _this58.http.authedRequest(Method.Get, \"/_matrix/client/versions\", undefined, undefined, {\n        prefix: \"\"\n      }).catch(e => {\n        // Need to unset this if it fails, otherwise we'll never retry\n        _this58.serverVersionsPromise = undefined;\n        // but rethrow the exception to anything that was waiting\n        throw e;\n      });\n      var serverVersions = yield _this58.serverVersionsPromise;\n      _this58.canSupport = yield buildFeatureSupportMap(serverVersions);\n      return _this58.serverVersionsPromise;\n    })();\n  }\n\n  /**\n   * Check if a particular spec version is supported by the server.\n   * @param version - The spec version (such as \"r0.5.0\") to check for.\n   * @returns Whether it is supported\n   */\n  isVersionSupported(version) {\n    var _this59 = this;\n    return _asyncToGenerator(function* () {\n      var {\n        versions\n      } = yield _this59.getVersions();\n      return versions && versions.includes(version);\n    })();\n  }\n\n  /**\n   * Query the server to see if it lists support for an unstable feature\n   * in the /versions response\n   * @param feature - the feature name\n   * @returns true if the feature is supported\n   */\n  doesServerSupportUnstableFeature(feature) {\n    var _this60 = this;\n    return _asyncToGenerator(function* () {\n      var response = yield _this60.getVersions();\n      if (!response) return false;\n      var unstableFeatures = response[\"unstable_features\"];\n      return unstableFeatures && !!unstableFeatures[feature];\n    })();\n  }\n\n  /**\n   * Query the server to see if it is forcing encryption to be enabled for\n   * a given room preset, based on the /versions response.\n   * @param presetName - The name of the preset to check.\n   * @returns true if the server is forcing encryption\n   * for the preset.\n   */\n  doesServerForceEncryptionForPreset(presetName) {\n    var _this61 = this;\n    return _asyncToGenerator(function* () {\n      var response = yield _this61.getVersions();\n      if (!response) return false;\n      var unstableFeatures = response[\"unstable_features\"];\n\n      // The preset name in the versions response will be without the _chat suffix.\n      var versionsPresetName = presetName.includes(\"_chat\") ? presetName.substring(0, presetName.indexOf(\"_chat\")) : presetName;\n      return unstableFeatures && !!unstableFeatures[\"io.element.e2ee_forced.\".concat(versionsPresetName)];\n    })();\n  }\n  doesServerSupportThread() {\n    var _this62 = this;\n    return _asyncToGenerator(function* () {\n      if (yield _this62.isVersionSupported(\"v1.4\")) {\n        return {\n          threads: FeatureSupport.Stable,\n          list: FeatureSupport.Stable,\n          fwdPagination: FeatureSupport.Stable\n        };\n      }\n      try {\n        var [threadUnstable, threadStable, listUnstable, listStable, fwdPaginationUnstable, fwdPaginationStable] = yield Promise.all([_this62.doesServerSupportUnstableFeature(\"org.matrix.msc3440\"), _this62.doesServerSupportUnstableFeature(\"org.matrix.msc3440.stable\"), _this62.doesServerSupportUnstableFeature(\"org.matrix.msc3856\"), _this62.doesServerSupportUnstableFeature(\"org.matrix.msc3856.stable\"), _this62.doesServerSupportUnstableFeature(\"org.matrix.msc3715\"), _this62.doesServerSupportUnstableFeature(\"org.matrix.msc3715.stable\")]);\n        return {\n          threads: determineFeatureSupport(threadStable, threadUnstable),\n          list: determineFeatureSupport(listStable, listUnstable),\n          fwdPagination: determineFeatureSupport(fwdPaginationStable, fwdPaginationUnstable)\n        };\n      } catch (_unused3) {\n        return {\n          threads: FeatureSupport.None,\n          list: FeatureSupport.None,\n          fwdPagination: FeatureSupport.None\n        };\n      }\n    })();\n  }\n\n  /**\n   * Get if lazy loading members is being used.\n   * @returns Whether or not members are lazy loaded by this client\n   */\n  hasLazyLoadMembersEnabled() {\n    var _this$clientOpts3;\n    return !!((_this$clientOpts3 = this.clientOpts) !== null && _this$clientOpts3 !== void 0 && _this$clientOpts3.lazyLoadMembers);\n  }\n\n  /**\n   * Set a function which is called when /sync returns a 'limited' response.\n   * It is called with a room ID and returns a boolean. It should return 'true' if the SDK\n   * can SAFELY remove events from this room. It may not be safe to remove events if there\n   * are other references to the timelines for this room, e.g because the client is\n   * actively viewing events in this room.\n   * Default: returns false.\n   * @param cb - The callback which will be invoked.\n   */\n  setCanResetTimelineCallback(cb) {\n    this.canResetTimelineCallback = cb;\n  }\n\n  /**\n   * Get the callback set via `setCanResetTimelineCallback`.\n   * @returns The callback or null\n   */\n  getCanResetTimelineCallback() {\n    return this.canResetTimelineCallback;\n  }\n\n  /**\n   * Returns relations for a given event. Handles encryption transparently,\n   * with the caveat that the amount of events returned might be 0, even though you get a nextBatch.\n   * When the returned promise resolves, all messages should have finished trying to decrypt.\n   * @param roomId - the room of the event\n   * @param eventId - the id of the event\n   * @param relationType - the rel_type of the relations requested\n   * @param eventType - the event type of the relations requested\n   * @param opts - options with optional values for the request.\n   * @returns an object with `events` as `MatrixEvent[]` and optionally `nextBatch` if more relations are available.\n   */\n  relations(roomId, eventId, relationType, eventType) {\n    var _arguments7 = arguments,\n      _this63 = this;\n    return _asyncToGenerator(function* () {\n      var _result$next_batch, _result$prev_batch;\n      var opts = _arguments7.length > 4 && _arguments7[4] !== undefined ? _arguments7[4] : {\n        dir: Direction.Backward\n      };\n      var fetchedEventType = eventType ? _this63.getEncryptedIfNeededEventType(roomId, eventType) : null;\n      var [eventResult, result] = yield Promise.all([_this63.fetchRoomEvent(roomId, eventId), _this63.fetchRelations(roomId, eventId, relationType, fetchedEventType, opts)]);\n      var mapper = _this63.getEventMapper();\n      var originalEvent = eventResult ? mapper(eventResult) : undefined;\n      var events = result.chunk.map(mapper);\n      if (fetchedEventType === EventType.RoomMessageEncrypted) {\n        var allEvents = originalEvent ? events.concat(originalEvent) : events;\n        yield Promise.all(allEvents.map(e => _this63.decryptEventIfNeeded(e)));\n        if (eventType !== null) {\n          events = events.filter(e => e.getType() === eventType);\n        }\n      }\n      if (originalEvent && relationType === RelationType.Replace) {\n        events = events.filter(e => e.getSender() === originalEvent.getSender());\n      }\n      return {\n        originalEvent: originalEvent !== null && originalEvent !== void 0 ? originalEvent : null,\n        events,\n        nextBatch: (_result$next_batch = result.next_batch) !== null && _result$next_batch !== void 0 ? _result$next_batch : null,\n        prevBatch: (_result$prev_batch = result.prev_batch) !== null && _result$prev_batch !== void 0 ? _result$prev_batch : null\n      };\n    })();\n  }\n\n  /**\n   * The app may wish to see if we have a key cached without\n   * triggering a user interaction.\n   *\n   * @deprecated Not supported for Rust Cryptography.\n   */\n  getCrossSigningCacheCallbacks() {\n    var _this$crypto4;\n    // XXX: Private member access\n    return (_this$crypto4 = this.crypto) === null || _this$crypto4 === void 0 ? void 0 : _this$crypto4.crossSigningInfo.getCacheCallbacks();\n  }\n\n  /**\n   * Generates a random string suitable for use as a client secret. <strong>This\n   * method is experimental and may change.</strong>\n   * @returns A new client secret\n   */\n  generateClientSecret() {\n    return randomString(32);\n  }\n\n  /**\n   * Attempts to decrypt an event\n   * @param event - The event to decrypt\n   * @returns A decryption promise\n   */\n  decryptEventIfNeeded(event, options) {\n    if (event.shouldAttemptDecryption() && this.isCryptoEnabled()) {\n      event.attemptDecryption(this.cryptoBackend, options);\n    }\n    if (event.isBeingDecrypted()) {\n      return event.getDecryptionPromise();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  termsUrlForService(serviceType, baseUrl) {\n    switch (serviceType) {\n      case SERVICE_TYPES.IS:\n        return this.http.getUrl(\"/terms\", undefined, IdentityPrefix.V2, baseUrl);\n      case SERVICE_TYPES.IM:\n        return this.http.getUrl(\"/terms\", undefined, \"/_matrix/integrations/v1\", baseUrl);\n      default:\n        throw new Error(\"Unsupported service type\");\n    }\n  }\n\n  /**\n   * Get the Homeserver URL of this client\n   * @returns Homeserver URL of this client\n   */\n  getHomeserverUrl() {\n    return this.baseUrl;\n  }\n\n  /**\n   * Get the identity server URL of this client\n   * @param stripProto - whether or not to strip the protocol from the URL\n   * @returns Identity server URL of this client\n   */\n  getIdentityServerUrl() {\n    var _this$idBaseUrl, _this$idBaseUrl2;\n    var stripProto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (stripProto && ((_this$idBaseUrl = this.idBaseUrl) !== null && _this$idBaseUrl !== void 0 && _this$idBaseUrl.startsWith(\"http://\") || (_this$idBaseUrl2 = this.idBaseUrl) !== null && _this$idBaseUrl2 !== void 0 && _this$idBaseUrl2.startsWith(\"https://\"))) {\n      return this.idBaseUrl.split(\"://\")[1];\n    }\n    return this.idBaseUrl;\n  }\n\n  /**\n   * Set the identity server URL of this client\n   * @param url - New identity server URL\n   */\n  setIdentityServerUrl(url) {\n    this.idBaseUrl = utils.ensureNoTrailingSlash(url);\n    this.http.setIdBaseUrl(this.idBaseUrl);\n  }\n\n  /**\n   * Get the access token associated with this account.\n   * @returns The access_token or null\n   */\n  getAccessToken() {\n    return this.http.opts.accessToken || null;\n  }\n\n  /**\n   * Get the refresh token associated with this account.\n   * @returns The refresh_token or null\n   */\n  getRefreshToken() {\n    var _this$http$opts$refre;\n    return (_this$http$opts$refre = this.http.opts.refreshToken) !== null && _this$http$opts$refre !== void 0 ? _this$http$opts$refre : null;\n  }\n\n  /**\n   * Set the access token associated with this account.\n   * @param token - The new access token.\n   */\n  setAccessToken(token) {\n    this.http.opts.accessToken = token;\n    // The /versions response can vary for different users so clear the cache\n    this.serverVersionsPromise = undefined;\n  }\n\n  /**\n   * @returns true if there is a valid access_token for this client.\n   */\n  isLoggedIn() {\n    return this.http.opts.accessToken !== undefined;\n  }\n\n  /**\n   * Make up a new transaction id\n   *\n   * @returns a new, unique, transaction id\n   */\n  makeTxnId() {\n    return \"m\" + new Date().getTime() + \".\" + this.txnCtr++;\n  }\n\n  /**\n   * Check whether a username is available prior to registration. An error response\n   * indicates an invalid/unavailable username.\n   * @param username - The username to check the availability of.\n   * @returns Promise which resolves: to boolean of whether the username is available.\n   */\n  isUsernameAvailable(username) {\n    return this.http.authedRequest(Method.Get, \"/register/available\", {\n      username\n    }).then(response => {\n      return response.available;\n    }).catch(response => {\n      if (response.errcode === \"M_USER_IN_USE\") {\n        return false;\n      }\n      return Promise.reject(response);\n    });\n  }\n\n  /**\n   * @param bindThreepids - Set key 'email' to true to bind any email\n   *     threepid uses during registration in the identity server. Set 'msisdn' to\n   *     true to bind msisdn.\n   * @returns Promise which resolves to a RegisterResponse object\n   * @returns Rejects: with an error response.\n   */\n  register(username, password, sessionId, auth, bindThreepids, guestAccessToken, inhibitLogin) {\n    if (sessionId) {\n      auth.session = sessionId;\n    }\n    var params = {\n      auth: auth,\n      refresh_token: true // always ask for a refresh token - does nothing if unsupported\n    };\n    if (username !== undefined && username !== null) {\n      params.username = username;\n    }\n    if (password !== undefined && password !== null) {\n      params.password = password;\n    }\n    if (guestAccessToken !== undefined && guestAccessToken !== null) {\n      params.guest_access_token = guestAccessToken;\n    }\n    if (inhibitLogin !== undefined && inhibitLogin !== null) {\n      params.inhibit_login = inhibitLogin;\n    }\n    return this.registerRequest(params);\n  }\n\n  /**\n   * Register a guest account.\n   * This method returns the auth info needed to create a new authenticated client,\n   * Remember to call `setGuest(true)` on the (guest-)authenticated client, e.g:\n   * ```javascript\n   * const tmpClient = await sdk.createClient(MATRIX_INSTANCE);\n   * const { user_id, device_id, access_token } = tmpClient.registerGuest();\n   * const client = createClient({\n   *   baseUrl: MATRIX_INSTANCE,\n   *   accessToken: access_token,\n   *   userId: user_id,\n   *   deviceId: device_id,\n   * })\n   * client.setGuest(true);\n   * ```\n   *\n   * @param body - JSON HTTP body to provide.\n   * @returns Promise which resolves: JSON object that contains:\n   *                   `{ user_id, device_id, access_token, home_server }`\n   * @returns Rejects: with an error response.\n   */\n  registerGuest() {\n    var {\n      body\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.registerRequest(body || {}, \"guest\");\n  }\n\n  /**\n   * @param data - parameters for registration request\n   * @param kind - type of user to register. may be \"guest\"\n   * @returns Promise which resolves: to the /register response\n   * @returns Rejects: with an error response.\n   */\n  registerRequest(data, kind) {\n    var params = {};\n    if (kind) {\n      params.kind = kind;\n    }\n    return this.http.request(Method.Post, \"/register\", params, data);\n  }\n\n  /**\n   * Refreshes an access token using a provided refresh token. The refresh token\n   * must be valid for the current access token known to the client instance.\n   *\n   * Note that this function will not cause a logout if the token is deemed\n   * unknown by the server - the caller is responsible for managing logout\n   * actions on error.\n   * @param refreshToken - The refresh token.\n   * @returns Promise which resolves to the new token.\n   * @returns Rejects with an error response.\n   */\n  refreshToken(refreshToken) {\n    var performRefreshRequestWithPrefix = prefix => this.http.authedRequest(Method.Post, \"/refresh\", undefined, {\n      refresh_token: refreshToken\n    }, {\n      prefix,\n      inhibitLogoutEmit: true // we don't want to cause logout loops\n    });\n\n    // First try with the (specced) /v3/ prefix.\n    // However, before Synapse 1.72.0, Synapse incorrectly required a /v1/ prefix, so we fall\n    // back to that if the request fails, for backwards compatibility.\n    return performRefreshRequestWithPrefix(ClientPrefix.V3).catch(e => {\n      if (e.errcode === \"M_UNRECOGNIZED\") {\n        return performRefreshRequestWithPrefix(ClientPrefix.V1);\n      }\n      throw e;\n    });\n  }\n\n  /**\n   * @returns Promise which resolves to the available login flows\n   * @returns Rejects: with an error response.\n   */\n  loginFlows() {\n    return this.http.request(Method.Get, \"/login\");\n  }\n\n  /**\n   * @returns Promise which resolves to a LoginResponse object\n   * @returns Rejects: with an error response.\n   */\n  login(loginType, data) {\n    return this.http.authedRequest(Method.Post, \"/login\", undefined, _objectSpread(_objectSpread({}, data), {}, {\n      type: loginType\n    })).then(response => {\n      if (response.access_token && response.user_id) {\n        this.http.opts.accessToken = response.access_token;\n        this.credentials = {\n          userId: response.user_id\n        };\n      }\n      return response;\n    });\n  }\n\n  /**\n   * @returns Promise which resolves to a LoginResponse object\n   * @returns Rejects: with an error response.\n   */\n  loginWithPassword(user, password) {\n    return this.login(\"m.login.password\", {\n      user: user,\n      password: password\n    });\n  }\n\n  /**\n   * @param redirectUrl - The URL to redirect to after the HS\n   * authenticates with CAS.\n   * @returns The HS URL to hit to begin the CAS login process.\n   */\n  getCasLoginUrl(redirectUrl) {\n    return this.getSsoLoginUrl(redirectUrl, \"cas\");\n  }\n\n  /**\n   * @param redirectUrl - The URL to redirect to after the HS\n   *     authenticates with the SSO.\n   * @param loginType - The type of SSO login we are doing (sso or cas).\n   *     Defaults to 'sso'.\n   * @param idpId - The ID of the Identity Provider being targeted, optional.\n   * @param action - the SSO flow to indicate to the IdP, optional.\n   * @returns The HS URL to hit to begin the SSO login process.\n   */\n  getSsoLoginUrl(redirectUrl) {\n    var loginType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"sso\";\n    var idpId = arguments.length > 2 ? arguments[2] : undefined;\n    var action = arguments.length > 3 ? arguments[3] : undefined;\n    var url = \"/login/\" + loginType + \"/redirect\";\n    if (idpId) {\n      url += \"/\" + idpId;\n    }\n    var params = {\n      redirectUrl,\n      [SSO_ACTION_PARAM.unstable]: action\n    };\n    return this.http.getUrl(url, params).href;\n  }\n\n  /**\n   * @param token - Login token previously received from homeserver\n   * @returns Promise which resolves to a LoginResponse object\n   * @returns Rejects: with an error response.\n   */\n  loginWithToken(token) {\n    return this.login(\"m.login.token\", {\n      token: token\n    });\n  }\n\n  /**\n   * Logs out the current session.\n   * Obviously, further calls that require authorisation should fail after this\n   * method is called. The state of the MatrixClient object is not affected:\n   * it is up to the caller to either reset or destroy the MatrixClient after\n   * this method succeeds.\n   * @param stopClient - whether to stop the client before calling /logout to prevent invalid token errors.\n   * @returns Promise which resolves: On success, the empty object `{}`\n   */\n  logout() {\n    var _arguments8 = arguments,\n      _this64 = this;\n    return _asyncToGenerator(function* () {\n      var _this64$crypto;\n      var stopClient = _arguments8.length > 0 && _arguments8[0] !== undefined ? _arguments8[0] : false;\n      if ((_this64$crypto = _this64.crypto) !== null && _this64$crypto !== void 0 && (_this64$crypto = _this64$crypto.backupManager) !== null && _this64$crypto !== void 0 && _this64$crypto.getKeyBackupEnabled()) {\n        try {\n          while ((yield _this64.crypto.backupManager.backupPendingKeys(200)) > 0);\n        } catch (err) {\n          _this64.logger.error(\"Key backup request failed when logging out. Some keys may be missing from backup\", err);\n        }\n      }\n      if (stopClient) {\n        _this64.stopClient();\n        _this64.http.abort();\n      }\n      return _this64.http.authedRequest(Method.Post, \"/logout\");\n    })();\n  }\n\n  /**\n   * Deactivates the logged-in account.\n   * Obviously, further calls that require authorisation should fail after this\n   * method is called. The state of the MatrixClient object is not affected:\n   * it is up to the caller to either reset or destroy the MatrixClient after\n   * this method succeeds.\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @param erase - Optional. If set, send as `erase` attribute in the\n   * JSON request body, indicating whether the account should be erased. Defaults\n   * to false.\n   * @returns Promise which resolves: On success, the empty object\n   */\n  deactivateAccount(auth, erase) {\n    var body = {};\n    if (auth) {\n      body.auth = auth;\n    }\n    if (erase !== undefined) {\n      body.erase = erase;\n    }\n    return this.http.authedRequest(Method.Post, \"/account/deactivate\", undefined, body);\n  }\n\n  /**\n   * Make a request for an `m.login.token` to be issued as per\n   * https://spec.matrix.org/v1.7/client-server-api/#post_matrixclientv1loginget_token\n   *\n   * The server may require User-Interactive auth.\n   *\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @returns Promise which resolves: On success, the token response\n   * or UIA auth data.\n   */\n  requestLoginToken(auth) {\n    var _this65 = this;\n    return _asyncToGenerator(function* () {\n      var body = {\n        auth\n      };\n      return _this65.http.authedRequest(Method.Post, \"/login/get_token\", undefined,\n      // no query params\n      body, {\n        prefix: ClientPrefix.V1\n      });\n    })();\n  }\n\n  /**\n   * Get the fallback URL to use for unknown interactive-auth stages.\n   *\n   * @param loginType -     the type of stage being attempted\n   * @param authSessionId - the auth session ID provided by the homeserver\n   *\n   * @returns HS URL to hit to for the fallback interface\n   */\n  getFallbackAuthUrl(loginType, authSessionId) {\n    var path = utils.encodeUri(\"/auth/$loginType/fallback/web\", {\n      $loginType: loginType\n    });\n    return this.http.getUrl(path, {\n      session: authSessionId\n    }).href;\n  }\n\n  /**\n   * Create a new room.\n   * @param options - a list of options to pass to the /createRoom API.\n   * @returns Promise which resolves: `{room_id: {string}}`\n   * @returns Rejects: with an error response.\n   */\n  createRoom(options) {\n    var _this66 = this;\n    return _asyncToGenerator(function* () {\n      var _this66$identityServe;\n      // eslint-disable-line camelcase\n      // some valid options include: room_alias_name, visibility, invite\n\n      // inject the id_access_token if inviting 3rd party addresses\n      var invitesNeedingToken = (options.invite_3pid || []).filter(i => !i.id_access_token);\n      if (invitesNeedingToken.length > 0 && (_this66$identityServe = _this66.identityServer) !== null && _this66$identityServe !== void 0 && _this66$identityServe.getAccessToken) {\n        var identityAccessToken = yield _this66.identityServer.getAccessToken();\n        if (identityAccessToken) {\n          for (var invite of invitesNeedingToken) {\n            invite.id_access_token = identityAccessToken;\n          }\n        }\n      }\n      return _this66.http.authedRequest(Method.Post, \"/createRoom\", undefined, options);\n    })();\n  }\n\n  /**\n   * Fetches relations for a given event\n   * @param roomId - the room of the event\n   * @param eventId - the id of the event\n   * @param relationType - the rel_type of the relations requested\n   * @param eventType - the event type of the relations requested\n   * @param opts - options with optional values for the request.\n   * @returns the response, with chunk, prev_batch and, next_batch.\n   */\n  fetchRelations(roomId, eventId, relationType, eventType) {\n    var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      dir: Direction.Backward\n    };\n    var params = opts;\n    if (Thread.hasServerSideFwdPaginationSupport === FeatureSupport.Experimental) {\n      params = replaceParam(\"dir\", \"org.matrix.msc3715.dir\", params);\n    }\n    if (this.canSupport.get(Feature.RelationsRecursion) === ServerSupport.Unstable) {\n      params = replaceParam(\"recurse\", \"org.matrix.msc3981.recurse\", params);\n    }\n    var queryString = utils.encodeParams(params);\n    var templatedUrl = \"/rooms/$roomId/relations/$eventId\";\n    if (relationType !== null) {\n      templatedUrl += \"/$relationType\";\n      if (eventType !== null) {\n        templatedUrl += \"/$eventType\";\n      }\n    } else if (eventType !== null) {\n      this.logger.warn(\"eventType: \".concat(eventType, \" ignored when fetching\\n            relations as relationType is null\"));\n      eventType = null;\n    }\n    var path = utils.encodeUri(templatedUrl + \"?\" + queryString, {\n      $roomId: roomId,\n      $eventId: eventId,\n      $relationType: relationType,\n      $eventType: eventType\n    });\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix: ClientPrefix.V1\n    });\n  }\n\n  /**\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  roomState(roomId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/state\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Get an event in a room by its event id.\n   *\n   * @returns Promise which resolves to an object containing the event.\n   * @returns Rejects: with an error response.\n   */\n  fetchRoomEvent(roomId, eventId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/event/$eventId\", {\n      $roomId: roomId,\n      $eventId: eventId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * @param includeMembership - the membership type to include in the response\n   * @param excludeMembership - the membership type to exclude from the response\n   * @param atEventId - the id of the event for which moment in the timeline the members should be returned for\n   * @returns Promise which resolves: dictionary of userid to profile information\n   * @returns Rejects: with an error response.\n   */\n  members(roomId, includeMembership, excludeMembership, atEventId) {\n    var queryParams = {};\n    if (includeMembership) {\n      queryParams.membership = includeMembership;\n    }\n    if (excludeMembership) {\n      queryParams.not_membership = excludeMembership;\n    }\n    if (atEventId) {\n      queryParams.at = atEventId;\n    }\n    var queryString = utils.encodeParams(queryParams);\n    var path = utils.encodeUri(\"/rooms/$roomId/members?\" + queryString, {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Upgrades a room to a new protocol version\n   * @param newVersion - The target version to upgrade to\n   * @returns Promise which resolves: Object with key 'replacement_room'\n   * @returns Rejects: with an error response.\n   */\n  upgradeRoom(roomId, newVersion) {\n    // eslint-disable-line camelcase\n    var path = utils.encodeUri(\"/rooms/$roomId/upgrade\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      new_version: newVersion\n    });\n  }\n\n  /**\n   * Retrieve a state event.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  getStateEvent(roomId, eventType, stateKey) {\n    var pathParams = {\n      $roomId: roomId,\n      $eventType: eventType,\n      $stateKey: stateKey\n    };\n    var path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n    if (stateKey !== undefined) {\n      path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n    }\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Send a state event into a room\n   * @param roomId - ID of the room to send the event into\n   * @param eventType - type of the state event to send\n   * @param content - content of the event to send\n   * @param stateKey - the stateKey to send into the room\n   * @param opts - Options for the request function.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  sendStateEvent(roomId, eventType, content) {\n    var stateKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var pathParams = {\n      $roomId: roomId,\n      $eventType: eventType,\n      $stateKey: stateKey\n    };\n    var path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n    if (stateKey !== undefined) {\n      path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n    }\n    return this.http.authedRequest(Method.Put, path, undefined, content, opts);\n  }\n\n  /**\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  roomInitialSync(roomId, limit) {\n    var _limit$toString;\n    var path = utils.encodeUri(\"/rooms/$roomId/initialSync\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path, {\n      limit: (_limit$toString = limit === null || limit === void 0 ? void 0 : limit.toString()) !== null && _limit$toString !== void 0 ? _limit$toString : \"30\"\n    });\n  }\n\n  /**\n   * Set a marker to indicate the point in a room before which the user has read every\n   * event. This can be retrieved from room account data (the event type is `m.fully_read`)\n   * and displayed as a horizontal line in the timeline that is visually distinct to the\n   * position of the user's own read receipt.\n   * @param roomId - ID of the room that has been read\n   * @param rmEventId - ID of the event that has been read\n   * @param rrEventId - ID of the event tracked by the read receipt. This is here\n   * for convenience because the RR and the RM are commonly updated at the same time as\n   * each other. Optional.\n   * @param rpEventId - rpEvent the m.read.private read receipt event for when we\n   * don't want other users to see the read receipts. This is experimental. Optional.\n   * @returns Promise which resolves: the empty object, `{}`.\n   */\n  setRoomReadMarkersHttpRequest(roomId, rmEventId, rrEventId, rpEventId) {\n    var _this67 = this;\n    return _asyncToGenerator(function* () {\n      var path = utils.encodeUri(\"/rooms/$roomId/read_markers\", {\n        $roomId: roomId\n      });\n      var content = {\n        [ReceiptType.FullyRead]: rmEventId,\n        [ReceiptType.Read]: rrEventId\n      };\n      if ((yield _this67.doesServerSupportUnstableFeature(\"org.matrix.msc2285.stable\")) || (yield _this67.isVersionSupported(\"v1.4\"))) {\n        content[ReceiptType.ReadPrivate] = rpEventId;\n      }\n      return _this67.http.authedRequest(Method.Post, path, undefined, content);\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves: A list of the user's current rooms\n   * @returns Rejects: with an error response.\n   */\n  getJoinedRooms() {\n    var path = utils.encodeUri(\"/joined_rooms\", {});\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Retrieve membership info. for a room.\n   * @param roomId - ID of the room to get membership for\n   * @returns Promise which resolves: A list of currently joined users\n   *                                 and their profile data.\n   * @returns Rejects: with an error response.\n   */\n  getJoinedRoomMembers(roomId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/joined_members\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * @param params - Options for this request\n   * @returns Promise which resolves: IPublicRoomsResponse\n   * @returns Rejects: with an error response.\n   */\n  publicRooms() {\n    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var {\n        server,\n        limit,\n        since\n      } = _ref10,\n      options = _objectWithoutProperties(_ref10, _excluded);\n    if (Object.keys(options).length === 0) {\n      var queryParams = {\n        server,\n        limit,\n        since\n      };\n      return this.http.authedRequest(Method.Get, \"/publicRooms\", queryParams);\n    } else {\n      var _queryParams = {\n        server\n      };\n      var _body = _objectSpread({\n        limit,\n        since\n      }, options);\n      return this.http.authedRequest(Method.Post, \"/publicRooms\", _queryParams, _body);\n    }\n  }\n\n  /**\n   * Create an alias to room ID mapping.\n   * @param alias - The room alias to create.\n   * @param roomId - The room ID to link the alias to.\n   * @returns Promise which resolves: an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  createAlias(alias, roomId) {\n    var path = utils.encodeUri(\"/directory/room/$alias\", {\n      $alias: alias\n    });\n    var data = {\n      room_id: roomId\n    };\n    return this.http.authedRequest(Method.Put, path, undefined, data);\n  }\n\n  /**\n   * Delete an alias to room ID mapping. This alias must be on your local server,\n   * and you must have sufficient access to do this operation.\n   * @param alias - The room alias to delete.\n   * @returns Promise which resolves: an empty object `{}`.\n   * @returns Rejects: with an error response.\n   */\n  deleteAlias(alias) {\n    var path = utils.encodeUri(\"/directory/room/$alias\", {\n      $alias: alias\n    });\n    return this.http.authedRequest(Method.Delete, path);\n  }\n\n  /**\n   * Gets the local aliases for the room. Note: this includes all local aliases, unlike the\n   * curated list from the m.room.canonical_alias state event.\n   * @param roomId - The room ID to get local aliases for.\n   * @returns Promise which resolves: an object with an `aliases` property, containing an array of local aliases\n   * @returns Rejects: with an error response.\n   */\n  getLocalAliases(roomId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/aliases\", {\n      $roomId: roomId\n    });\n    var prefix = ClientPrefix.V3;\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix\n    });\n  }\n\n  /**\n   * Get room info for the given alias.\n   * @param alias - The room alias to resolve.\n   * @returns Promise which resolves: Object with room_id and servers.\n   * @returns Rejects: with an error response.\n   */\n  getRoomIdForAlias(alias) {\n    // eslint-disable-line camelcase\n    var path = utils.encodeUri(\"/directory/room/$alias\", {\n      $alias: alias\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Get the visibility of a room in the current HS's room directory\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  getRoomDirectoryVisibility(roomId) {\n    var path = utils.encodeUri(\"/directory/list/room/$roomId\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Set the visibility of a room in the current HS's room directory\n   * @param visibility - \"public\" to make the room visible\n   *                 in the public directory, or \"private\" to make\n   *                 it invisible.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setRoomDirectoryVisibility(roomId, visibility) {\n    var path = utils.encodeUri(\"/directory/list/room/$roomId\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, {\n      visibility\n    });\n  }\n\n  /**\n   * Query the user directory with a term matching user IDs, display names and domains.\n   * @param options\n   * @param options.term - the term with which to search.\n   * @param options.limit - the maximum number of results to return. The server will apply a limit if unspecified.\n   * @returns Promise which resolves: an array of results.\n   */\n  searchUserDirectory(_ref11) {\n    var {\n      term,\n      limit\n    } = _ref11;\n    var body = {\n      search_term: term\n    };\n    if (limit !== undefined) {\n      body.limit = limit;\n    }\n    return this.http.authedRequest(Method.Post, \"/user_directory/search\", undefined, body);\n  }\n\n  /**\n   * Upload a file to the media repository on the homeserver.\n   *\n   * @param file - The object to upload. On a browser, something that\n   *   can be sent to XMLHttpRequest.send (typically a File).  Under node.js,\n   *   a a Buffer, String or ReadStream.\n   *\n   * @param opts -  options object\n   *\n   * @returns Promise which resolves to response object, as\n   *    determined by this.opts.onlyData, opts.rawResponse, and\n   *    opts.onlyContentUri.  Rejects with an error (usually a MatrixError).\n   */\n  uploadContent(file, opts) {\n    return this.http.uploadContent(file, opts);\n  }\n\n  /**\n   * Cancel a file upload in progress\n   * @param upload - The object returned from uploadContent\n   * @returns true if canceled, otherwise false\n   */\n  cancelUpload(upload) {\n    return this.http.cancelUpload(upload);\n  }\n\n  /**\n   * Get a list of all file uploads in progress\n   * @returns Array of objects representing current uploads.\n   * Currently in progress is element 0. Keys:\n   *  - promise: The promise associated with the upload\n   *  - loaded: Number of bytes uploaded\n   *  - total: Total number of bytes to upload\n   */\n  getCurrentUploads() {\n    return this.http.getCurrentUploads();\n  }\n\n  /**\n   * @param info - The kind of info to retrieve (e.g. 'displayname',\n   * 'avatar_url').\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  getProfileInfo(userId, info\n  // eslint-disable-next-line camelcase\n  ) {\n    var path = info ? utils.encodeUri(\"/profile/$userId/$info\", {\n      $userId: userId,\n      $info: info\n    }) : utils.encodeUri(\"/profile/$userId\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Determine if the server supports extended profiles, as described by MSC4133.\n   *\n   * @returns `true` if supported, otherwise `false`\n   */\n  doesServerSupportExtendedProfiles() {\n    var _this68 = this;\n    return _asyncToGenerator(function* () {\n      return _this68.doesServerSupportUnstableFeature(UNSTABLE_MSC4133_EXTENDED_PROFILES);\n    })();\n  }\n\n  /**\n   * Get the prefix used for extended profile requests.\n   *\n   * @returns The prefix for use with `authedRequest`\n   */\n  getExtendedProfileRequestPrefix() {\n    var _this69 = this;\n    return _asyncToGenerator(function* () {\n      if (yield _this69.doesServerSupportUnstableFeature(\"uk.tcpip.msc4133.stable\")) {\n        return ClientPrefix.V3;\n      }\n      return \"/_matrix/client/unstable/uk.tcpip.msc4133\";\n    })();\n  }\n\n  /**\n   * Fetch a user's *extended* profile, which may include additonal keys.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param userId The user ID to fetch the profile of.\n   * @returns A set of keys to property values.\n   *\n   * @throws An error if the server does not support MSC4133.\n   * @throws A M_NOT_FOUND error if the profile could not be found.\n   */\n  getExtendedProfile(userId) {\n    var _this70 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this70.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      return _this70.http.authedRequest(Method.Get, utils.encodeUri(\"/profile/$userId\", {\n        $userId: userId\n      }), undefined, undefined, {\n        prefix: yield _this70.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Fetch a specific key from the user's *extended* profile.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param userId The user ID to fetch the profile of.\n   * @param key The key of the property to fetch.\n   * @returns The property value.\n   *\n   * @throws An error if the server does not support MSC4133.\n   * @throws A M_NOT_FOUND error if the key was not set OR the profile could not be found.\n   */\n  getExtendedProfileProperty(userId, key) {\n    var _this71 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this71.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var profile = yield _this71.http.authedRequest(Method.Get, utils.encodeUri(\"/profile/$userId/$key\", {\n        $userId: userId,\n        $key: key\n      }), undefined, undefined, {\n        prefix: yield _this71.getExtendedProfileRequestPrefix()\n      });\n      return profile[key];\n    })();\n  }\n\n  /**\n   * Set a property on your *extended* profile.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param key The key of the property to set.\n   * @param value The value to set on the propety.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  setExtendedProfileProperty(key, value) {\n    var _this72 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this72.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this72.getUserId();\n      yield _this72.http.authedRequest(Method.Put, utils.encodeUri(\"/profile/$userId/$key\", {\n        $userId: userId,\n        $key: key\n      }), undefined, {\n        [key]: value\n      }, {\n        prefix: yield _this72.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Delete a property on your *extended* profile.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param key The key of the property to delete.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  deleteExtendedProfileProperty(key) {\n    var _this73 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this73.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this73.getUserId();\n      yield _this73.http.authedRequest(Method.Delete, utils.encodeUri(\"/profile/$userId/$key\", {\n        $userId: userId,\n        $key: key\n      }), undefined, undefined, {\n        prefix: yield _this73.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Update multiple properties on your *extended* profile. This will\n   * merge with any existing keys.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param profile The profile object to merge with the existing profile.\n   * @returns The newly merged profile.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  patchExtendedProfile(profile) {\n    var _this74 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this74.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this74.getUserId();\n      return _this74.http.authedRequest(Method.Patch, utils.encodeUri(\"/profile/$userId\", {\n        $userId: userId\n      }), {}, profile, {\n        prefix: yield _this74.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Set multiple properties on your *extended* profile. This will completely\n   * replace the existing profile, removing any unspecified keys.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param profile The profile object to set.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  setExtendedProfile(profile) {\n    var _this75 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this75.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this75.getUserId();\n      yield _this75.http.authedRequest(Method.Put, utils.encodeUri(\"/profile/$userId\", {\n        $userId: userId\n      }), {}, profile, {\n        prefix: yield _this75.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves to a list of the user's threepids.\n   * @returns Rejects: with an error response.\n   */\n  getThreePids() {\n    return this.http.authedRequest(Method.Get, \"/account/3pid\");\n  }\n\n  /**\n   * Add a 3PID to your homeserver account. This API does not use an identity\n   * server, as the homeserver is expected to handle 3PID ownership validation.\n   *\n   * @param data - A object with 3PID validation data from having called\n   * `account/3pid/<medium>/requestToken` on the homeserver.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  addThreePidOnly(data) {\n    var _this76 = this;\n    return _asyncToGenerator(function* () {\n      var path = \"/account/3pid/add\";\n      return _this76.http.authedRequest(Method.Post, path, undefined, data);\n    })();\n  }\n\n  /**\n   * Bind a 3PID for discovery onto an identity server via the homeserver. The\n   * identity server handles 3PID ownership validation and the homeserver records\n   * the new binding to track where all 3PIDs for the account are bound.\n   *\n   * @param data - A object with 3PID validation data from having called\n   * `validate/<medium>/requestToken` on the identity server. It should also\n   * contain `id_server` and `id_access_token` fields as well.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  bindThreePid(data) {\n    var _this77 = this;\n    return _asyncToGenerator(function* () {\n      var path = \"/account/3pid/bind\";\n      return _this77.http.authedRequest(Method.Post, path, undefined, data);\n    })();\n  }\n\n  /**\n   * Unbind a 3PID for discovery on an identity server via the homeserver. The\n   * homeserver removes its record of the binding to keep an updated record of\n   * where all 3PIDs for the account are bound.\n   *\n   * @param medium - The threepid medium (eg. 'email')\n   * @param address - The threepid address (eg. 'bob\\@example.com')\n   *        this must be as returned by getThreePids.\n   * @returns Promise which resolves: on success\n   * @returns Rejects: with an error response.\n   */\n  unbindThreePid(medium, address\n  // eslint-disable-next-line camelcase\n  ) {\n    var _this78 = this;\n    return _asyncToGenerator(function* () {\n      var path = \"/account/3pid/unbind\";\n      var data = {\n        medium,\n        address,\n        id_server: _this78.getIdentityServerUrl(true)\n      };\n      return _this78.http.authedRequest(Method.Post, path, undefined, data);\n    })();\n  }\n\n  /**\n   * @param medium - The threepid medium (eg. 'email')\n   * @param address - The threepid address (eg. 'bob\\@example.com')\n   *        this must be as returned by getThreePids.\n   * @returns Promise which resolves: The server response on success\n   *     (generally the empty JSON object)\n   * @returns Rejects: with an error response.\n   */\n  deleteThreePid(medium, address\n  // eslint-disable-next-line camelcase\n  ) {\n    var path = \"/account/3pid/delete\";\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      medium,\n      address\n    });\n  }\n\n  /**\n   * Make a request to change your password.\n   * @param newPassword - The new desired password.\n   * @param logoutDevices - Should all sessions be logged out after the password change. Defaults to true.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setPassword(authDict, newPassword, logoutDevices) {\n    var path = \"/account/password\";\n    var data = {\n      auth: authDict,\n      new_password: newPassword,\n      logout_devices: logoutDevices\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, data);\n  }\n\n  /**\n   * Gets all devices recorded for the logged-in user\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  getDevices() {\n    return this.http.authedRequest(Method.Get, \"/devices\");\n  }\n\n  /**\n   * Gets specific device details for the logged-in user\n   * @param deviceId -  device to query\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  getDevice(deviceId) {\n    var path = utils.encodeUri(\"/devices/$device_id\", {\n      $device_id: deviceId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Update the given device\n   *\n   * @param deviceId -  device to update\n   * @param body -       body of request\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  // eslint-disable-next-line camelcase\n  setDeviceDetails(deviceId, body) {\n    var path = utils.encodeUri(\"/devices/$device_id\", {\n      $device_id: deviceId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, body);\n  }\n\n  /**\n   * Delete the given device\n   *\n   * @param deviceId -  device to delete\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  deleteDevice(deviceId, auth) {\n    var path = utils.encodeUri(\"/devices/$device_id\", {\n      $device_id: deviceId\n    });\n    var body = {};\n    if (auth) {\n      body.auth = auth;\n    }\n    return this.http.authedRequest(Method.Delete, path, undefined, body);\n  }\n\n  /**\n   * Delete multiple device\n   *\n   * @param devices - IDs of the devices to delete\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  deleteMultipleDevices(devices, auth) {\n    var body = {\n      devices\n    };\n    if (auth) {\n      body.auth = auth;\n    }\n    var path = \"/delete_devices\";\n    return this.http.authedRequest(Method.Post, path, undefined, body);\n  }\n\n  /**\n   * Gets all pushers registered for the logged-in user\n   *\n   * @returns Promise which resolves: Array of objects representing pushers\n   * @returns Rejects: with an error response.\n   */\n  getPushers() {\n    var _this79 = this;\n    return _asyncToGenerator(function* () {\n      var response = yield _this79.http.authedRequest(Method.Get, \"/pushers\");\n\n      // Migration path for clients that connect to a homeserver that does not support\n      // MSC3881 yet, see https://github.com/matrix-org/matrix-spec-proposals/blob/kerry/remote-push-toggle/proposals/3881-remote-push-notification-toggling.md#migration\n      if (!(yield _this79.doesServerSupportUnstableFeature(\"org.matrix.msc3881\"))) {\n        response.pushers = response.pushers.map(pusher => {\n          if (!pusher.hasOwnProperty(PUSHER_ENABLED.name)) {\n            pusher[PUSHER_ENABLED.name] = true;\n          }\n          return pusher;\n        });\n      }\n      return response;\n    })();\n  }\n\n  /**\n   * Adds a new pusher or updates an existing pusher\n   *\n   * @param pusher - Object representing a pusher\n   * @returns Promise which resolves: Empty json object on success\n   * @returns Rejects: with an error response.\n   */\n  setPusher(pusher) {\n    var path = \"/pushers/set\";\n    return this.http.authedRequest(Method.Post, path, undefined, pusher);\n  }\n\n  /**\n   * Removes an existing pusher\n   * @param pushKey - pushkey of pusher to remove\n   * @param appId - app_id of pusher to remove\n   * @returns Promise which resolves: Empty json object on success\n   * @returns Rejects: with an error response.\n   */\n  removePusher(pushKey, appId) {\n    var path = \"/pushers/set\";\n    var body = {\n      pushkey: pushKey,\n      app_id: appId,\n      kind: null // marks pusher for removal\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, body);\n  }\n\n  /**\n   * Persists local notification settings\n   * @returns Promise which resolves: an empty object\n   * @returns Rejects: with an error response.\n   */\n  setLocalNotificationSettings(deviceId, notificationSettings) {\n    var key = \"\".concat(LOCAL_NOTIFICATION_SETTINGS_PREFIX.name, \".\").concat(deviceId);\n    return this.setAccountData(key, notificationSettings);\n  }\n\n  /**\n   * Get the push rules for the account from the server.\n   * @returns Promise which resolves to the push rules.\n   * @returns Rejects: with an error response.\n   */\n  getPushRules() {\n    return this.http.authedRequest(Method.Get, \"/pushrules/\").then(rules => {\n      this.setPushRules(rules);\n      return this.pushRules;\n    });\n  }\n\n  /**\n   * Update the push rules for the account. This should be called whenever\n   * updated push rules are available.\n   */\n  setPushRules(rules) {\n    // Fix-up defaults, if applicable.\n    this.pushRules = PushProcessor.rewriteDefaultRules(rules, this.getUserId());\n    // Pre-calculate any necessary caches.\n    this.pushProcessor.updateCachedPushRuleKeys(this.pushRules);\n  }\n\n  /**\n   * @returns Promise which resolves: an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  addPushRule(scope, kind, ruleId, body) {\n    // NB. Scope not uri encoded because devices need the '/'\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, body);\n  }\n\n  /**\n   * @returns Promise which resolves: an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  deletePushRule(scope, kind, ruleId) {\n    // NB. Scope not uri encoded because devices need the '/'\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Delete, path);\n  }\n\n  /**\n   * Enable or disable a push notification rule.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setPushRuleEnabled(scope, kind, ruleId, enabled) {\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId/enabled\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, {\n      enabled: enabled\n    });\n  }\n\n  /**\n   * Set the actions for a push notification rule.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setPushRuleActions(scope, kind, ruleId, actions) {\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId/actions\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, {\n      actions: actions\n    });\n  }\n\n  /**\n   * Perform a server-side search.\n   * @param params\n   * @param params.next_batch - the batch token to pass in the query string\n   * @param params.body - the JSON object to pass to the request body.\n   * @param abortSignal - optional signal used to cancel the http request.\n   * @returns Promise which resolves to the search response object.\n   * @returns Rejects: with an error response.\n   */\n  search(_ref12, abortSignal) {\n    var {\n      body,\n      next_batch: nextBatch\n    } = _ref12;\n    var queryParams = {};\n    if (nextBatch) {\n      queryParams.next_batch = nextBatch;\n    }\n    return this.http.authedRequest(Method.Post, \"/search\", queryParams, body, {\n      abortSignal\n    });\n  }\n\n  /**\n   * Upload keys\n   *\n   * @param content -  body of upload request\n   *\n   * @param opts - this method no longer takes any opts,\n   *  used to take opts.device_id but this was not removed from the spec as a redundant parameter\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  uploadKeysRequest(content, opts) {\n    return this.http.authedRequest(Method.Post, \"/keys/upload\", undefined, content);\n  }\n  uploadKeySignatures(content) {\n    return this.http.authedRequest(Method.Post, \"/keys/signatures/upload\", undefined, content);\n  }\n\n  /**\n   * Download device keys\n   *\n   * @param userIds -  list of users to get keys for\n   *\n   * @param token - sync token to pass in the query request, to help\n   *   the HS give the most recent results\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  downloadKeysForUsers(userIds) {\n    var {\n      token\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var content = {\n      device_keys: {}\n    };\n    if (token !== undefined) {\n      content.token = token;\n    }\n    userIds.forEach(u => {\n      content.device_keys[u] = [];\n    });\n    return this.http.authedRequest(Method.Post, \"/keys/query\", undefined, content);\n  }\n\n  /**\n   * Claim one-time keys\n   *\n   * @param devices -  a list of [userId, deviceId] pairs\n   *\n   * @param keyAlgorithm -  desired key type\n   *\n   * @param timeout - the time (in milliseconds) to wait for keys from remote\n   *     servers\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  claimOneTimeKeys(devices) {\n    var keyAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"signed_curve25519\";\n    var timeout = arguments.length > 2 ? arguments[2] : undefined;\n    var queries = {};\n    if (keyAlgorithm === undefined) {\n      keyAlgorithm = \"signed_curve25519\";\n    }\n    for (var [userId, _deviceId] of devices) {\n      var query = queries[userId] || {};\n      safeSet(queries, userId, query);\n      safeSet(query, _deviceId, keyAlgorithm);\n    }\n    var content = {\n      one_time_keys: queries\n    };\n    if (timeout) {\n      content.timeout = timeout;\n    }\n    var path = \"/keys/claim\";\n    return this.http.authedRequest(Method.Post, path, undefined, content);\n  }\n\n  /**\n   * Ask the server for a list of users who have changed their device lists\n   * between a pair of sync tokens\n   *\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  getKeyChanges(oldToken, newToken) {\n    var qps = {\n      from: oldToken,\n      to: newToken\n    };\n    return this.http.authedRequest(Method.Get, \"/keys/changes\", qps);\n  }\n  uploadDeviceSigningKeys(auth, keys) {\n    // API returns empty object\n    var data = Object.assign({}, keys);\n    if (auth) Object.assign(data, {\n      auth\n    });\n    return this.http.authedRequest(Method.Post, \"/keys/device_signing/upload\", undefined, data, {\n      prefix: ClientPrefix.Unstable\n    });\n  }\n\n  /**\n   * Register with an identity server using the OpenID token from the user's\n   * Homeserver, which can be retrieved via\n   * {@link MatrixClient#getOpenIdToken}.\n   *\n   * Note that the `/account/register` endpoint (as well as IS authentication in\n   * general) was added as part of the v2 API version.\n   *\n   * @returns Promise which resolves: with object containing an Identity\n   * Server access token.\n   * @returns Rejects: with an error response.\n   */\n  registerWithIdentityServer(hsOpenIdToken) {\n    if (!this.idBaseUrl) {\n      throw new Error(\"No identity server base URL set\");\n    }\n    var uri = this.http.getUrl(\"/account/register\", undefined, IdentityPrefix.V2, this.idBaseUrl);\n    return this.http.requestOtherUrl(Method.Post, uri, hsOpenIdToken);\n  }\n\n  /**\n   * Requests an email verification token directly from an identity server.\n   *\n   * This API is used as part of binding an email for discovery on an identity\n   * server. The validation data that results should be passed to the\n   * `bindThreePid` method to complete the binding process.\n   *\n   * @param email - The email address to request a token for\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 It is recommended this be around 16 ASCII characters.\n   * @param sendAttempt - If an identity server sees a duplicate request\n   *                 with the same sendAttempt, it will not send another email.\n   *                 To request another email to be sent, use a larger value for\n   *                 the sendAttempt param as was used in the previous request.\n   * @param nextLink - Optional If specified, the client will be redirected\n   *                 to this link after validation.\n   * @param identityAccessToken - The `access_token` field of the identity\n   * server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   * @throws Error if no identity server is set\n   */\n  requestEmailToken(email, clientSecret, sendAttempt, nextLink, identityAccessToken) {\n    var params = {\n      client_secret: clientSecret,\n      email: email,\n      send_attempt: sendAttempt === null || sendAttempt === void 0 ? void 0 : sendAttempt.toString()\n    };\n    if (nextLink) {\n      params.next_link = nextLink;\n    }\n    return this.http.idServerRequest(Method.Post, \"/validate/email/requestToken\", params, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Requests a MSISDN verification token directly from an identity server.\n   *\n   * This API is used as part of binding a MSISDN for discovery on an identity\n   * server. The validation data that results should be passed to the\n   * `bindThreePid` method to complete the binding process.\n   *\n   * @param phoneCountry - The ISO 3166-1 alpha-2 code for the country in\n   *                 which phoneNumber should be parsed relative to.\n   * @param phoneNumber - The phone number, in national or international\n   *                 format\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 It is recommended this be around 16 ASCII characters.\n   * @param sendAttempt - If an identity server sees a duplicate request\n   *                 with the same sendAttempt, it will not send another SMS.\n   *                 To request another SMS to be sent, use a larger value for\n   *                 the sendAttempt param as was used in the previous request.\n   * @param nextLink - Optional If specified, the client will be redirected\n   *                 to this link after validation.\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves to an object with a sid string\n   * @returns Rejects: with an error response.\n   * @throws Error if no identity server is set\n   */\n  requestMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink, identityAccessToken) {\n    var params = {\n      client_secret: clientSecret,\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      send_attempt: sendAttempt === null || sendAttempt === void 0 ? void 0 : sendAttempt.toString()\n    };\n    if (nextLink) {\n      params.next_link = nextLink;\n    }\n    return this.http.idServerRequest(Method.Post, \"/validate/msisdn/requestToken\", params, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Submits a MSISDN token to the identity server\n   *\n   * This is used when submitting the code sent by SMS to a phone number.\n   * The identity server has an equivalent API for email but the js-sdk does\n   * not expose this, since email is normally validated by the user clicking\n   * a link rather than entering a code.\n   *\n   * @param sid - The sid given in the response to requestToken\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 This must be the same value submitted in the requestToken call.\n   * @param msisdnToken - The MSISDN token, as enetered by the user.\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   * Some legacy identity servers had no authentication here.\n   *\n   * @returns Promise which resolves: Object, containing success boolean.\n   * @returns Rejects: with an error response.\n   * @throws Error if No identity server is set\n   */\n  submitMsisdnToken(sid, clientSecret, msisdnToken, identityAccessToken) {\n    var params = {\n      sid: sid,\n      client_secret: clientSecret,\n      token: msisdnToken\n    };\n    return this.http.idServerRequest(Method.Post, \"/validate/msisdn/submitToken\", params, IdentityPrefix.V2, identityAccessToken !== null && identityAccessToken !== void 0 ? identityAccessToken : undefined);\n  }\n\n  /**\n   * Submits a MSISDN token to an arbitrary URL.\n   *\n   * This is used when submitting the code sent by SMS to a phone number in the\n   * newer 3PID flow where the homeserver validates 3PID ownership (as part of\n   * `requestAdd3pidMsisdnToken`). The homeserver response may include a\n   * `submit_url` to specify where the token should be sent, and this helper can\n   * be used to pass the token to this URL.\n   *\n   * @param url - The URL to submit the token to\n   * @param sid - The sid given in the response to requestToken\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 This must be the same value submitted in the requestToken call.\n   * @param msisdnToken - The MSISDN token, as enetered by the user.\n   *\n   * @returns Promise which resolves: Object, containing success boolean.\n   * @returns Rejects: with an error response.\n   */\n  submitMsisdnTokenOtherUrl(url, sid, clientSecret, msisdnToken) {\n    var params = {\n      sid: sid,\n      client_secret: clientSecret,\n      token: msisdnToken\n    };\n    return this.http.requestOtherUrl(Method.Post, url, params);\n  }\n\n  /**\n   * Gets the V2 hashing information from the identity server. Primarily useful for\n   * lookups.\n   * @param identityAccessToken - The access token for the identity server.\n   * @returns The hashing information for the identity server.\n   */\n  getIdentityHashDetails(identityAccessToken) {\n    return this.http.idServerRequest(Method.Get, \"/hash_details\", undefined, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Performs a hashed lookup of addresses against the identity server. This is\n   * only supported on identity servers which have at least the version 2 API.\n   * @param addressPairs - An array of 2 element arrays.\n   * The first element of each pair is the address, the second is the 3PID medium.\n   * Eg: `[\"email@example.org\", \"email\"]`\n   * @param identityAccessToken - The access token for the identity server.\n   * @returns A collection of address mappings to\n   * found MXIDs. Results where no user could be found will not be listed.\n   */\n  identityHashedLookup(addressPairs, identityAccessToken) {\n    var _this80 = this;\n    return _asyncToGenerator(function* () {\n      var params = {\n        // addresses: [\"email@example.org\", \"10005550000\"],\n        // algorithm: \"sha256\",\n        // pepper: \"abc123\"\n      };\n\n      // Get hash information first before trying to do a lookup\n      var hashes = yield _this80.getIdentityHashDetails(identityAccessToken);\n      if (!hashes || !hashes[\"lookup_pepper\"] || !hashes[\"algorithms\"]) {\n        throw new Error(\"Unsupported identity server: bad response\");\n      }\n      params[\"pepper\"] = hashes[\"lookup_pepper\"];\n      var localMapping = {\n        // hashed identifier => plain text address\n        // For use in this function's return format\n      };\n\n      // When picking an algorithm, we pick the hashed over no hashes\n      if (hashes[\"algorithms\"].includes(\"sha256\")) {\n        params[\"addresses\"] = yield Promise.all(addressPairs.map(/*#__PURE__*/function () {\n          var _ref13 = _asyncToGenerator(function* (p) {\n            var addr = p[0].toLowerCase(); // lowercase to get consistent hashes\n            var med = p[1].toLowerCase();\n            var hashBuffer = yield sha256(\"\".concat(addr, \" \").concat(med, \" \").concat(params[\"pepper\"]));\n            var hashed = encodeUnpaddedBase64Url(hashBuffer);\n\n            // Map the hash to a known (case-sensitive) address. We use the case\n            // sensitive version because the caller might be expecting that.\n            localMapping[hashed] = p[0];\n            return hashed;\n          });\n          return function (_x6) {\n            return _ref13.apply(this, arguments);\n          };\n        }()));\n        params[\"algorithm\"] = \"sha256\";\n      } else if (hashes[\"algorithms\"].includes(\"none\")) {\n        params[\"addresses\"] = addressPairs.map(p => {\n          var addr = p[0].toLowerCase(); // lowercase to get consistent hashes\n          var med = p[1].toLowerCase();\n          var unhashed = \"\".concat(addr, \" \").concat(med);\n          // Map the unhashed values to a known (case-sensitive) address. We use\n          // the case-sensitive version because the caller might be expecting that.\n          localMapping[unhashed] = p[0];\n          return unhashed;\n        });\n        params[\"algorithm\"] = \"none\";\n      } else {\n        throw new Error(\"Unsupported identity server: unknown hash algorithm\");\n      }\n      var response = yield _this80.http.idServerRequest(Method.Post, \"/lookup\", params, IdentityPrefix.V2, identityAccessToken);\n      if (!(response !== null && response !== void 0 && response[\"mappings\"])) return []; // no results\n\n      var foundAddresses = [];\n      for (var hashed of Object.keys(response[\"mappings\"])) {\n        var mxid = response[\"mappings\"][hashed];\n        var plainAddress = localMapping[hashed];\n        if (!plainAddress) {\n          throw new Error(\"Identity server returned more results than expected\");\n        }\n        foundAddresses.push({\n          address: plainAddress,\n          mxid\n        });\n      }\n      return foundAddresses;\n    })();\n  }\n\n  /**\n   * Looks up the public Matrix ID mapping for a given 3rd party\n   * identifier from the identity server\n   *\n   * @param medium - The medium of the threepid, eg. 'email'\n   * @param address - The textual address of the threepid\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: A threepid mapping\n   *                                 object or the empty object if no mapping\n   *                                 exists\n   * @returns Rejects: with an error response.\n   */\n  lookupThreePid(medium, address, identityAccessToken) {\n    var _this81 = this;\n    return _asyncToGenerator(function* () {\n      // Note: we're using the V2 API by calling this function, but our\n      // function contract requires a V1 response. We therefore have to\n      // convert it manually.\n      var response = yield _this81.identityHashedLookup([[address, medium]], identityAccessToken);\n      var result = response.find(p => p.address === address);\n      if (!result) {\n        return {};\n      }\n      var mapping = {\n        address,\n        medium,\n        mxid: result.mxid\n\n        // We can't reasonably fill these parameters:\n        // not_before\n        // not_after\n        // ts\n        // signatures\n      };\n      return mapping;\n    })();\n  }\n\n  /**\n   * Looks up the public Matrix ID mappings for multiple 3PIDs.\n   *\n   * @param query - Array of arrays containing\n   * [medium, address]\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: Lookup results from IS.\n   * @returns Rejects: with an error response.\n   */\n  bulkLookupThreePids(query, identityAccessToken) {\n    var _this82 = this;\n    return _asyncToGenerator(function* () {\n      // Note: we're using the V2 API by calling this function, but our\n      // function contract requires a V1 response. We therefore have to\n      // convert it manually.\n      var response = yield _this82.identityHashedLookup(\n      // We have to reverse the query order to get [address, medium] pairs\n      query.map(p => [p[1], p[0]]), identityAccessToken);\n      var v1results = [];\n      var _loop2 = function* _loop2(mapping) {\n        var originalQuery = query.find(p => p[1] === mapping.address);\n        if (!originalQuery) {\n          throw new Error(\"Identity sever returned unexpected results\");\n        }\n        v1results.push([originalQuery[0],\n        // medium\n        mapping.address, mapping.mxid]);\n      };\n      for (var mapping of response) {\n        yield* _loop2(mapping);\n      }\n      return {\n        threepids: v1results\n      };\n    })();\n  }\n\n  /**\n   * Get account info from the identity server. This is useful as a neutral check\n   * to verify that other APIs are likely to approve access by testing that the\n   * token is valid, terms have been agreed, etc.\n   *\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: an object with account info.\n   * @returns Rejects: with an error response.\n   */\n  getIdentityAccount(identityAccessToken) {\n    return this.http.idServerRequest(Method.Get, \"/account\", undefined, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Send an event to a specific list of devices.\n   * This is a low-level API that simply wraps the HTTP API\n   * call to send to-device messages. We recommend using\n   * queueToDevice() which is a higher level API.\n   *\n   * @param eventType -  type of event to send\n   *    content to send. Map from user_id to device_id to content object.\n   * @param txnId -     transaction id. One will be made up if not\n   *    supplied.\n   * @returns Promise which resolves: to an empty object `{}`\n   */\n  sendToDevice(eventType, contentMap, txnId) {\n    var path = utils.encodeUri(\"/sendToDevice/$eventType/$txnId\", {\n      $eventType: eventType,\n      $txnId: txnId ? txnId : this.makeTxnId()\n    });\n    var body = {\n      messages: utils.recursiveMapToObject(contentMap)\n    };\n    var targets = new Map();\n    for (var [userId, deviceMessages] of contentMap) {\n      targets.set(userId, Array.from(deviceMessages.keys()));\n    }\n    this.logger.debug(\"PUT \".concat(path), targets);\n    return this.http.authedRequest(Method.Put, path, undefined, body);\n  }\n\n  /**\n   * Sends events directly to specific devices using Matrix's to-device\n   * messaging system. The batch will be split up into appropriately sized\n   * batches for sending and stored in the store so they can be retried\n   * later if they fail to send. Retries will happen automatically.\n   * @param batch - The to-device messages to send\n   */\n  queueToDevice(batch) {\n    return this.toDeviceMessageQueue.queueBatch(batch);\n  }\n\n  /**\n   * Get the third party protocols that can be reached using\n   * this HS\n   * @returns Promise which resolves to the result object\n   */\n  getThirdpartyProtocols() {\n    return this.http.authedRequest(Method.Get, \"/thirdparty/protocols\").then(response => {\n      // sanity check\n      if (!response || typeof response !== \"object\") {\n        throw new Error(\"/thirdparty/protocols did not return an object: \".concat(response));\n      }\n      return response;\n    });\n  }\n\n  /**\n   * Get information on how a specific place on a third party protocol\n   * may be reached.\n   * @param protocol - The protocol given in getThirdpartyProtocols()\n   * @param params - Protocol-specific parameters, as given in the\n   *                        response to getThirdpartyProtocols()\n   * @returns Promise which resolves to the result object\n   */\n  getThirdpartyLocation(protocol, params) {\n    var path = utils.encodeUri(\"/thirdparty/location/$protocol\", {\n      $protocol: protocol\n    });\n    return this.http.authedRequest(Method.Get, path, params);\n  }\n\n  /**\n   * Get information on how a specific user on a third party protocol\n   * may be reached.\n   * @param protocol - The protocol given in getThirdpartyProtocols()\n   * @param params - Protocol-specific parameters, as given in the\n   *                        response to getThirdpartyProtocols()\n   * @returns Promise which resolves to the result object\n   */\n  getThirdpartyUser(protocol, params) {\n    var path = utils.encodeUri(\"/thirdparty/user/$protocol\", {\n      $protocol: protocol\n    });\n    return this.http.authedRequest(Method.Get, path, params);\n  }\n  getTerms(serviceType, baseUrl) {\n    // TODO: Types\n    var url = this.termsUrlForService(serviceType, baseUrl);\n    return this.http.requestOtherUrl(Method.Get, url);\n  }\n  agreeToTerms(serviceType, baseUrl, accessToken, termsUrls) {\n    var url = this.termsUrlForService(serviceType, baseUrl);\n    var headers = {\n      Authorization: \"Bearer \" + accessToken\n    };\n    return this.http.requestOtherUrl(Method.Post, url, {\n      user_accepts: termsUrls\n    }, {\n      headers\n    });\n  }\n\n  /**\n   * Reports an event as inappropriate to the server, which may then notify the appropriate people.\n   * @param roomId - The room in which the event being reported is located.\n   * @param eventId - The event to report.\n   * @param score - The score to rate this content as where -100 is most offensive and 0 is inoffensive.\n   * @param reason - The reason the content is being reported. May be blank.\n   * @returns Promise which resolves to an empty object if successful\n   */\n  reportEvent(roomId, eventId, score, reason) {\n    var path = utils.encodeUri(\"/rooms/$roomId/report/$eventId\", {\n      $roomId: roomId,\n      $eventId: eventId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      score,\n      reason\n    });\n  }\n\n  /**\n   * Fetches or paginates a room hierarchy as defined by MSC2946.\n   * Falls back gracefully to sourcing its data from `getSpaceSummary` if this API is not yet supported by the server.\n   * @param roomId - The ID of the space-room to use as the root of the summary.\n   * @param limit - The maximum number of rooms to return per page.\n   * @param maxDepth - The maximum depth in the tree from the root room to return.\n   * @param suggestedOnly - Whether to only return rooms with suggested=true.\n   * @param fromToken - The opaque token to paginate a previous request.\n   * @returns the response, with next_batch & rooms fields.\n   */\n  getRoomHierarchy(roomId, limit, maxDepth) {\n    var suggestedOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var fromToken = arguments.length > 4 ? arguments[4] : undefined;\n    var path = utils.encodeUri(\"/rooms/$roomId/hierarchy\", {\n      $roomId: roomId\n    });\n    var queryParams = {\n      suggested_only: String(suggestedOnly),\n      max_depth: maxDepth === null || maxDepth === void 0 ? void 0 : maxDepth.toString(),\n      from: fromToken,\n      limit: limit === null || limit === void 0 ? void 0 : limit.toString()\n    };\n    return this.http.authedRequest(Method.Get, path, queryParams, undefined, {\n      prefix: ClientPrefix.V1\n    }).catch(e => {\n      if (e.errcode === \"M_UNRECOGNIZED\") {\n        // fall back to the prefixed hierarchy API.\n        return this.http.authedRequest(Method.Get, path, queryParams, undefined, {\n          prefix: \"/_matrix/client/unstable/org.matrix.msc2946\"\n        });\n      }\n      throw e;\n    });\n  }\n\n  /**\n   * Creates a new file tree space with the given name. The client will pick\n   * defaults for how it expects to be able to support the remaining API offered\n   * by the returned class.\n   *\n   * Note that this is UNSTABLE and may have breaking changes without notice.\n   * @param name - The name of the tree space.\n   * @returns Promise which resolves to the created space.\n   */\n  unstableCreateFileTree(name) {\n    var _this83 = this;\n    return _asyncToGenerator(function* () {\n      var {\n        room_id: roomId\n      } = yield _this83.createRoom({\n        name: name,\n        preset: Preset.PrivateChat,\n        power_level_content_override: _objectSpread(_objectSpread({}, DEFAULT_TREE_POWER_LEVELS_TEMPLATE), {}, {\n          users: {\n            [_this83.getUserId()]: 100\n          }\n        }),\n        creation_content: {\n          [RoomCreateTypeField]: RoomType.Space\n        },\n        initial_state: [{\n          type: UNSTABLE_MSC3088_PURPOSE.name,\n          state_key: UNSTABLE_MSC3089_TREE_SUBTYPE.name,\n          content: {\n            [UNSTABLE_MSC3088_ENABLED.name]: true\n          }\n        }, {\n          type: EventType.RoomEncryption,\n          state_key: \"\",\n          content: {\n            algorithm: olmlib.MEGOLM_ALGORITHM\n          }\n        }]\n      });\n      return new MSC3089TreeSpace(_this83, roomId);\n    })();\n  }\n\n  /**\n   * Gets a reference to a tree space, if the room ID given is a tree space. If the room\n   * does not appear to be a tree space then null is returned.\n   *\n   * Note that this is UNSTABLE and may have breaking changes without notice.\n   * @param roomId - The room ID to get a tree space reference for.\n   * @returns The tree space, or null if not a tree space.\n   */\n  unstableGetFileTreeSpace(roomId) {\n    var _purposeEvent$getCont, _createEvent$getConte;\n    var room = this.getRoom(roomId);\n    if ((room === null || room === void 0 ? void 0 : room.getMyMembership()) !== KnownMembership.Join) return null;\n    var createEvent = room.currentState.getStateEvents(EventType.RoomCreate, \"\");\n    var purposeEvent = room.currentState.getStateEvents(UNSTABLE_MSC3088_PURPOSE.name, UNSTABLE_MSC3089_TREE_SUBTYPE.name);\n    if (!createEvent) throw new Error(\"Expected single room create event\");\n    if (!(purposeEvent !== null && purposeEvent !== void 0 && (_purposeEvent$getCont = purposeEvent.getContent()) !== null && _purposeEvent$getCont !== void 0 && _purposeEvent$getCont[UNSTABLE_MSC3088_ENABLED.name])) return null;\n    if (((_createEvent$getConte = createEvent.getContent()) === null || _createEvent$getConte === void 0 ? void 0 : _createEvent$getConte[RoomCreateTypeField]) !== RoomType.Space) return null;\n    return new MSC3089TreeSpace(this, roomId);\n  }\n\n  /**\n   * Perform a single MSC3575 sliding sync request.\n   * @param req - The request to make.\n   * @param proxyBaseUrl - The base URL for the sliding sync proxy.\n   * @param abortSignal - Optional signal to abort request mid-flight.\n   * @returns The sliding sync response, or a standard error.\n   * @throws on non 2xx status codes with an object with a field \"httpStatus\":number.\n   */\n  slidingSync(req, proxyBaseUrl, abortSignal) {\n    var qps = {};\n    if (req.pos) {\n      qps.pos = req.pos;\n      delete req.pos;\n    }\n    if (req.timeout) {\n      qps.timeout = req.timeout;\n      delete req.timeout;\n    }\n    var clientTimeout = req.clientTimeout;\n    delete req.clientTimeout;\n    return this.http.authedRequest(Method.Post, \"/sync\", qps, req, {\n      prefix: \"/_matrix/client/unstable/org.matrix.msc3575\",\n      baseUrl: proxyBaseUrl,\n      localTimeoutMs: clientTimeout,\n      abortSignal\n    });\n  }\n\n  /**\n   * A helper to determine thread support\n   * @returns a boolean to determine if threads are enabled\n   */\n  supportsThreads() {\n    var _this$clientOpts4;\n    return ((_this$clientOpts4 = this.clientOpts) === null || _this$clientOpts4 === void 0 ? void 0 : _this$clientOpts4.threadSupport) || false;\n  }\n\n  /**\n   * A helper to determine intentional mentions support\n   * @returns a boolean to determine if intentional mentions are enabled on the server\n   * @experimental\n   */\n  supportsIntentionalMentions() {\n    return this.canSupport.get(Feature.IntentionalMentions) !== ServerSupport.Unsupported;\n  }\n\n  /**\n   * Fetches the summary of a room as defined by an initial version of MSC3266 and implemented in Synapse\n   * Proposed at https://github.com/matrix-org/matrix-doc/pull/3266\n   * @param roomIdOrAlias - The ID or alias of the room to get the summary of.\n   * @param via - The list of servers which know about the room if only an ID was provided.\n   */\n  getRoomSummary(roomIdOrAlias, via) {\n    var _this84 = this;\n    return _asyncToGenerator(function* () {\n      var paramOpts = {\n        prefix: \"/_matrix/client/unstable/im.nheko.summary\"\n      };\n      try {\n        var path = utils.encodeUri(\"/summary/$roomid\", {\n          $roomid: roomIdOrAlias\n        });\n        return yield _this84.http.authedRequest(Method.Get, path, {\n          via\n        }, undefined, paramOpts);\n      } catch (e) {\n        if (e instanceof MatrixError && e.errcode === \"M_UNRECOGNIZED\") {\n          var _path = utils.encodeUri(\"/rooms/$roomid/summary\", {\n            $roomid: roomIdOrAlias\n          });\n          return yield _this84.http.authedRequest(Method.Get, _path, {\n            via\n          }, undefined, paramOpts);\n        } else {\n          throw e;\n        }\n      }\n    })();\n  }\n\n  /**\n   * Processes a list of threaded events and adds them to their respective timelines\n   * @param room - the room the adds the threaded events\n   * @param threadedEvents - an array of the threaded events\n   * @param toStartOfTimeline - the direction in which we want to add the events\n   */\n  processThreadEvents(room, threadedEvents, toStartOfTimeline) {\n    room.processThreadedEvents(threadedEvents, toStartOfTimeline);\n  }\n\n  /**\n   * Processes a list of thread roots and creates a thread model\n   * @param room - the room to create the threads in\n   * @param threadedEvents - an array of thread roots\n   * @param toStartOfTimeline - the direction\n   */\n  processThreadRoots(room, threadedEvents, toStartOfTimeline) {\n    if (!this.supportsThreads()) return;\n    room.processThreadRoots(threadedEvents, toStartOfTimeline);\n  }\n  processBeaconEvents(room, events) {\n    this.processAggregatedTimelineEvents(room, events);\n  }\n\n  /**\n   * Calls aggregation functions for event types that are aggregated\n   * Polls and location beacons\n   * @param room - room the events belong to\n   * @param events - timeline events to be processed\n   * @returns\n   */\n  processAggregatedTimelineEvents(room, events) {\n    if (!(events !== null && events !== void 0 && events.length)) return;\n    if (!room) return;\n    room.currentState.processBeaconEvents(events, this);\n    room.processPollEvents(events);\n  }\n\n  /**\n   * Fetches information about the user for the configured access token.\n   */\n  whoami() {\n    var _this85 = this;\n    return _asyncToGenerator(function* () {\n      return _this85.http.authedRequest(Method.Get, \"/account/whoami\");\n    })();\n  }\n\n  /**\n   * Find the event_id closest to the given timestamp in the given direction.\n   * @returns Resolves: A promise of an object containing the event_id and\n   *    origin_server_ts of the closest event to the timestamp in the given direction\n   * @returns Rejects: when the request fails (module:http-api.MatrixError)\n   */\n  timestampToEvent(roomId, timestamp, dir) {\n    var _this86 = this;\n    return _asyncToGenerator(function* () {\n      var path = utils.encodeUri(\"/rooms/$roomId/timestamp_to_event\", {\n        $roomId: roomId\n      });\n      var queryParams = {\n        ts: timestamp.toString(),\n        dir: dir\n      };\n      try {\n        return yield _this86.http.authedRequest(Method.Get, path, queryParams, undefined, {\n          prefix: ClientPrefix.V1\n        });\n      } catch (err) {\n        // Fallback to the prefixed unstable endpoint. Since the stable endpoint is\n        // new, we should also try the unstable endpoint before giving up. We can\n        // remove this fallback request in a year (remove after 2023-11-28).\n        if (err.errcode === \"M_UNRECOGNIZED\" && (\n        // XXX: The 400 status code check should be removed in the future\n        // when Synapse is compliant with MSC3743.\n        err.httpStatus === 400 ||\n        // This the correct standard status code for an unsupported\n        // endpoint according to MSC3743. Not Found and Method Not Allowed\n        // both indicate that this endpoint+verb combination is\n        // not supported.\n        err.httpStatus === 404 || err.httpStatus === 405)) {\n          return yield _this86.http.authedRequest(Method.Get, path, queryParams, undefined, {\n            prefix: \"/_matrix/client/unstable/org.matrix.msc3030\"\n          });\n        }\n        throw err;\n      }\n    })();\n  }\n\n  /**\n   * Get the OIDC issuer responsible for authentication on this server, if any\n   * @returns Resolves: A promise of an object containing the OIDC issuer if configured\n   * @returns Rejects: when the request fails (module:http-api.MatrixError)\n   * @experimental - part of MSC2965\n   */\n  getAuthIssuer() {\n    var _this87 = this;\n    return _asyncToGenerator(function* () {\n      return _this87.http.request(Method.Get, \"/auth_issuer\", undefined, undefined, {\n        prefix: ClientPrefix.Unstable + \"/org.matrix.msc2965\"\n      });\n    })();\n  }\n}\n_defineProperty(MatrixClient, \"RESTORE_BACKUP_ERROR_BAD_KEY\", \"RESTORE_BACKUP_ERROR_BAD_KEY\");\nfunction getUnstableDelayQueryOpts(delayOpts) {\n  return Object.fromEntries(Object.entries(delayOpts).map(_ref14 => {\n    var [k, v] = _ref14;\n    return [\"\".concat(UNSTABLE_MSC4140_DELAYED_EVENTS, \".\").concat(k), v];\n  }));\n}\n\n/**\n * recalculates an accurate notifications count on event decryption.\n * Servers do not have enough knowledge about encrypted events to calculate an\n * accurate notification_count\n */\nexport function fixNotificationCountOnDecryption(cli, event) {\n  var _actions$tweaks;\n  var ourUserId = cli.getUserId();\n  var eventId = event.getId();\n  var room = cli.getRoom(event.getRoomId());\n  if (!room || !ourUserId || !eventId) return;\n\n  // Due to threads, we can get relation events (eg. edits & reactions) that never get\n  // added to a timeline and so cannot be found in their own room (their edit / reaction\n  // still applies to the event it needs to, so it doesn't matter too much). However, if\n  // we try to process notification about this event, we'll get very confused because we\n  // won't be able to find the event in the room, so will assume it must be unread, even\n  // if it's actually read. We therefore skip anything that isn't in the room. This isn't\n  // *great*, so if we can fix the homeless events (eg. with MSC4023) then we should probably\n  // remove this workaround.\n  if (!room.findEventById(eventId)) {\n    logger.info(\"Decrypted event \".concat(event.getId(), \" is not in room \").concat(room.roomId, \": ignoring\"));\n    return;\n  }\n  var isThreadEvent = !!event.threadRootId && !event.isThreadRoot;\n  var hasReadEvent;\n  if (isThreadEvent) {\n    var thread = room.getThread(event.threadRootId);\n    hasReadEvent = thread ? thread.hasUserReadEvent(ourUserId, eventId) :\n    // If the thread object does not exist in the room yet, we don't\n    // want to calculate notification for this event yet. We have not\n    // restored the read receipts yet and can't accurately calculate\n    // notifications at this stage.\n    //\n    // This issue can likely go away when MSC3874 is implemented\n    true;\n  } else {\n    hasReadEvent = room.hasUserReadEvent(ourUserId, eventId);\n  }\n  if (hasReadEvent) {\n    // If the event has been read, ignore it.\n    return;\n  }\n  var actions = cli.getPushActionsForEvent(event, true);\n\n  // Ensure the unread counts are kept up to date if the event is encrypted\n  // We also want to make sure that the notification count goes up if we already\n  // have encrypted events to avoid other code from resetting 'highlight' to zero.\n  var newHighlight = !!(actions !== null && actions !== void 0 && (_actions$tweaks = actions.tweaks) !== null && _actions$tweaks !== void 0 && _actions$tweaks.highlight);\n  if (newHighlight) {\n    // TODO: Handle mentions received while the client is offline\n    // See also https://github.com/vector-im/element-web/issues/9069\n    var newCount = room.getUnreadCountForEventContext(NotificationCountType.Highlight, event) + 1;\n    if (isThreadEvent) {\n      room.setThreadUnreadNotificationCount(event.threadRootId, NotificationCountType.Highlight, newCount);\n    } else {\n      room.setUnreadNotificationCount(NotificationCountType.Highlight, newCount);\n    }\n  }\n\n  // `notify` is used in practice for incrementing the total count\n  var newNotify = !!(actions !== null && actions !== void 0 && actions.notify);\n\n  // The room total count is NEVER incremented by the server for encrypted rooms. We basically ignore\n  // the server here as it's always going to tell us to increment for encrypted events.\n  if (newNotify) {\n    // Total count is used to typically increment a room notification counter, but not loudly highlight it.\n    var _newCount = room.getUnreadCountForEventContext(NotificationCountType.Total, event) + 1;\n    if (isThreadEvent) {\n      room.setThreadUnreadNotificationCount(event.threadRootId, NotificationCountType.Total, _newCount);\n    } else {\n      room.setUnreadNotificationCount(NotificationCountType.Total, _newCount);\n    }\n  }\n}\n\n/**\n * Given an event, figure out the thread ID we should use for it in a receipt.\n *\n * This will either be \"main\", or event.threadRootId. For the thread root, or\n * e.g. reactions to the thread root, this will be main. For events inside the\n * thread, or e.g. reactions to them, this will be event.threadRootId.\n *\n * (Exported for test.)\n */\nexport function threadIdForReceipt(event) {\n  return inMainTimelineForReceipt(event) ? MAIN_ROOM_TIMELINE : event.threadRootId;\n}\n\n/**\n * a) True for non-threaded messages, thread roots and non-thread relations to thread roots.\n * b) False for messages with thread relations to the thread root.\n * c) False for messages with any kind of relation to a message from case b.\n *\n * Note: true for redactions of messages that are in threads. Redacted messages\n * are not really in threads (because their relations are gone), so if they look\n * like they are in threads, that is a sign of a bug elsewhere. (At time of\n * writing, this bug definitely exists - messages are not moved to another\n * thread when they are redacted.)\n *\n * @returns true if this event is considered to be in the main timeline as far\n *               as receipts are concerned.\n */\nexport function inMainTimelineForReceipt(event) {\n  if (!event.threadRootId) {\n    // Not in a thread: then it is in the main timeline\n    return true;\n  }\n  if (event.isThreadRoot) {\n    // Thread roots are in the main timeline. Note: the spec is ambiguous (or\n    // wrong) on this - see\n    // https://github.com/matrix-org/matrix-spec-proposals/pull/4037\n    return true;\n  }\n  if (!event.isRelation()) {\n    // If it's not related to anything, it can't be related via a chain of\n    // relations to a thread root.\n    //\n    // Note: this is a bug, because how does it have a threadRootId if it is\n    // neither a thread root, nor related to one?\n    logger.warn(\"Event is not a relation or a thread root, but still has a threadRootId! id=\".concat(event.getId()));\n    return true;\n  }\n  if (event.isRelation(THREAD_RELATION_TYPE.name)) {\n    // It's a message in a thread - definitely not in the main timeline.\n    return false;\n  }\n  var isRelatedToRoot = event.relationEventId === event.threadRootId;\n\n  // If it's related to the thread root (and we already know it's not a thread\n  // relation) then it's in the main timeline. If it's related to something\n  // else, then it's in the thread (because it has a thread ID).\n  return isRelatedToRoot;\n}\n//# sourceMappingURL=client.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WidgetEventCapability = exports.EventKind = exports.EventDirection = void 0;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright 2020 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar EventKind = /*#__PURE__*/function (EventKind) {\n  EventKind[\"Event\"] = \"event\";\n  EventKind[\"State\"] = \"state_event\";\n  EventKind[\"ToDevice\"] = \"to_device\";\n  EventKind[\"RoomAccount\"] = \"room_account\";\n  return EventKind;\n}({});\nexports.EventKind = EventKind;\nvar EventDirection = /*#__PURE__*/function (EventDirection) {\n  EventDirection[\"Send\"] = \"send\";\n  EventDirection[\"Receive\"] = \"receive\";\n  return EventDirection;\n}({});\nexports.EventDirection = EventDirection;\nvar WidgetEventCapability = /*#__PURE__*/function () {\n  function WidgetEventCapability(direction, eventType, kind, keyStr, raw) {\n    _classCallCheck(this, WidgetEventCapability);\n    this.direction = direction;\n    this.eventType = eventType;\n    this.kind = kind;\n    this.keyStr = keyStr;\n    this.raw = raw;\n  }\n  _createClass(WidgetEventCapability, [{\n    key: \"matchesAsStateEvent\",\n    value: function matchesAsStateEvent(direction, eventType, stateKey) {\n      if (this.kind !== EventKind.State) return false; // not a state event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n      if (this.keyStr === null) return true; // all state keys are allowed\n      if (this.keyStr === stateKey) return true; // this state key is allowed\n\n      // Default not allowed\n      return false;\n    }\n  }, {\n    key: \"matchesAsToDeviceEvent\",\n    value: function matchesAsToDeviceEvent(direction, eventType) {\n      if (this.kind !== EventKind.ToDevice) return false; // not a to-device event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      // Checks passed, the event is allowed\n      return true;\n    }\n  }, {\n    key: \"matchesAsRoomEvent\",\n    value: function matchesAsRoomEvent(direction, eventType) {\n      var msgtype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (this.kind !== EventKind.Event) return false; // not a room event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      if (this.eventType === \"m.room.message\") {\n        if (this.keyStr === null) return true; // all message types are allowed\n        if (this.keyStr === msgtype) return true; // this message type is allowed\n      } else {\n        return true; // already passed the check for if the event is allowed\n      }\n\n      // Default not allowed\n      return false;\n    }\n  }, {\n    key: \"matchesAsRoomAccountData\",\n    value: function matchesAsRoomAccountData(direction, eventType) {\n      if (this.kind !== EventKind.RoomAccount) return false; // not room account data\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      // Checks passed, the event is allowed\n      return true;\n    }\n  }], [{\n    key: \"forStateEvent\",\n    value: function forStateEvent(direction, eventType, stateKey) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      eventType = eventType.replace(/#/g, '\\\\#');\n      stateKey = stateKey !== null && stateKey !== undefined ? \"#\".concat(stateKey) : '';\n      var str = \"org.matrix.msc2762.\".concat(direction, \".state_event:\").concat(eventType).concat(stateKey);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forToDeviceEvent\",\n    value: function forToDeviceEvent(direction, eventType) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/56\n      var str = \"org.matrix.msc3819.\".concat(direction, \".to_device:\").concat(eventType);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomEvent\",\n    value: function forRoomEvent(direction, eventType) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      var str = \"org.matrix.msc2762.\".concat(direction, \".event:\").concat(eventType);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomMessageEvent\",\n    value: function forRoomMessageEvent(direction, msgtype) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      msgtype = msgtype === null || msgtype === undefined ? '' : msgtype;\n      var str = \"org.matrix.msc2762.\".concat(direction, \".event:m.room.message#\").concat(msgtype);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomAccountData\",\n    value: function forRoomAccountData(direction, eventType) {\n      var str = \"com.beeper.capabilities.\".concat(direction, \".room_account_data:\").concat(eventType);\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    /**\n     * Parses a capabilities request to find all the event capability requests.\n     * @param {Iterable<Capability>} capabilities The capabilities requested/to parse.\n     * @returns {WidgetEventCapability[]} An array of event capability requests. May be empty, but never null.\n     */\n  }, {\n    key: \"findEventCapabilities\",\n    value: function findEventCapabilities(capabilities) {\n      var parsed = [];\n      var _iterator = _createForOfIteratorHelper(capabilities),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var cap = _step.value;\n          var _direction = null;\n          var eventSegment = void 0;\n          var _kind = null;\n\n          // TODO: Enable support for m.* namespace once the MSCs land.\n          // https://github.com/matrix-org/matrix-widget-api/issues/22\n          // https://github.com/matrix-org/matrix-widget-api/issues/56\n\n          if (cap.startsWith(\"org.matrix.msc2762.send.event:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.Event;\n            eventSegment = cap.substring(\"org.matrix.msc2762.send.event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.send.state_event:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.State;\n            eventSegment = cap.substring(\"org.matrix.msc2762.send.state_event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc3819.send.to_device:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.ToDevice;\n            eventSegment = cap.substring(\"org.matrix.msc3819.send.to_device:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.receive.event:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.Event;\n            eventSegment = cap.substring(\"org.matrix.msc2762.receive.event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.receive.state_event:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.State;\n            eventSegment = cap.substring(\"org.matrix.msc2762.receive.state_event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc3819.receive.to_device:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.ToDevice;\n            eventSegment = cap.substring(\"org.matrix.msc3819.receive.to_device:\".length);\n          } else if (cap.startsWith(\"com.beeper.capabilities.receive.room_account_data:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.RoomAccount;\n            eventSegment = cap.substring(\"com.beeper.capabilities.receive.room_account_data:\".length);\n          }\n          if (_direction === null || _kind === null || eventSegment === undefined) continue;\n\n          // The capability uses `#` as a separator between event type and state key/msgtype,\n          // so we split on that. However, a # is also valid in either one of those so we\n          // join accordingly.\n          // Eg: `m.room.message##m.text` is \"m.room.message\" event with msgtype \"#m.text\".\n          var expectingKeyStr = eventSegment.startsWith(\"m.room.message#\") || _kind === EventKind.State;\n          var _keyStr = null;\n          if (eventSegment.includes('#') && expectingKeyStr) {\n            // Dev note: regex is difficult to write, so instead the rules are manually written\n            // out. This is probably just as understandable as a boring regex though, so win-win?\n\n            // Test cases:\n            // str                      eventSegment        keyStr\n            // -------------------------------------------------------------\n            // m.room.message#          m.room.message      <empty string>\n            // m.room.message#test      m.room.message      test\n            // m.room.message\\#         m.room.message#     test\n            // m.room.message##test     m.room.message      #test\n            // m.room.message\\##test    m.room.message#     test\n            // m.room.message\\\\##test   m.room.message\\#    test\n            // m.room.message\\\\###test  m.room.message\\#    #test\n\n            // First step: explode the string\n            var parts = eventSegment.split('#');\n\n            // To form the eventSegment, we'll keep finding parts of the exploded string until\n            // there's one that doesn't end with the escape character (\\). We'll then join those\n            // segments together with the exploding character. We have to remember to consume the\n            // escape character as well.\n            var idx = parts.findIndex(function (p) {\n              return !p.endsWith(\"\\\\\");\n            });\n            eventSegment = parts.slice(0, idx + 1).map(function (p) {\n              return p.endsWith('\\\\') ? p.substring(0, p.length - 1) : p;\n            }).join('#');\n\n            // The keyStr is whatever is left over.\n            _keyStr = parts.slice(idx + 1).join('#');\n          }\n          parsed.push(new WidgetEventCapability(_direction, eventSegment, _kind, _keyStr, cap));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return parsed;\n    }\n  }]);\n  return WidgetEventCapability;\n}();\nexports.WidgetEventCapability = WidgetEventCapability;\n//# sourceMappingURL=WidgetEventCapability.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleObservable = void 0;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright 2020 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar SimpleObservable = /*#__PURE__*/function () {\n  function SimpleObservable(initialFn) {\n    _classCallCheck(this, SimpleObservable);\n    _defineProperty(this, \"listeners\", []);\n    if (initialFn) this.listeners.push(initialFn);\n  }\n  _createClass(SimpleObservable, [{\n    key: \"onUpdate\",\n    value: function onUpdate(fn) {\n      this.listeners.push(fn);\n    }\n  }, {\n    key: \"update\",\n    value: function update(val) {\n      var _iterator = _createForOfIteratorHelper(this.listeners),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          listener(val);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.listeners = []; // reset\n    }\n  }]);\n  return SimpleObservable;\n}();\nexports.SimpleObservable = SimpleObservable;\n//# sourceMappingURL=SimpleObservable.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientWidgetApi = void 0;\nvar _events = require(\"events\");\nvar _PostmessageTransport = require(\"./transport/PostmessageTransport\");\nvar _WidgetApiDirection = require(\"./interfaces/WidgetApiDirection\");\nvar _WidgetApiAction = require(\"./interfaces/WidgetApiAction\");\nvar _Capabilities = require(\"./interfaces/Capabilities\");\nvar _ApiVersion = require(\"./interfaces/ApiVersion\");\nvar _WidgetEventCapability = require(\"./models/WidgetEventCapability\");\nvar _GetOpenIDAction = require(\"./interfaces/GetOpenIDAction\");\nvar _SimpleObservable = require(\"./util/SimpleObservable\");\nvar _Symbols = require(\"./Symbols\");\nvar _UpdateDelayedEventAction = require(\"./interfaces/UpdateDelayedEventAction\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, \"return\": function _return(value) { var ret = this.s[\"return\"]; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, \"throw\": function _throw(value) { var thr = this.s[\"return\"]; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright 2020 - 2024 The Matrix.org Foundation C.I.C.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Licensed under the Apache License, Version 2.0 (the \"License\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * you may not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *         http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Unless required by applicable law or agreed to in writing, software\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * distributed under the License is distributed on an \"AS IS\" BASIS,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * See the License for the specific language governing permissions and\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * limitations under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */\n/**\n * API handler for the client side of widgets. This raises events\n * for each action received as `action:${action}` (eg: \"action:screenshot\").\n * Default handling can be prevented by using preventDefault() on the\n * raised event. The default handling varies for each action: ones\n * which the SDK can handle safely are acknowledged appropriately and\n * ones which are unhandled (custom or require the client to do something)\n * are rejected with an error.\n *\n * Events which are preventDefault()ed must reply using the transport.\n * The events raised will have a default of an IWidgetApiRequest\n * interface.\n *\n * When the ClientWidgetApi is ready to start sending requests, it will\n * raise a \"ready\" CustomEvent. After the ready event fires, actions can\n * be sent and the transport will be ready.\n *\n * When the widget has indicated it has loaded, this class raises a\n * \"preparing\" CustomEvent. The preparing event does not indicate that\n * the widget is ready to receive communications - that is signified by\n * the ready event exclusively.\n *\n * This class only handles one widget at a time.\n */\nvar ClientWidgetApi = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(ClientWidgetApi, _EventEmitter);\n  var _super = _createSuper(ClientWidgetApi);\n  /**\n   * Creates a new client widget API. This will instantiate the transport\n   * and start everything. When the iframe is loaded under the widget's\n   * conditions, a \"ready\" event will be raised.\n   * @param {Widget} widget The widget to communicate with.\n   * @param {HTMLIFrameElement} iframe The iframe the widget is in.\n   * @param {WidgetDriver} driver The driver for this widget/client.\n   */\n  function ClientWidgetApi(widget, iframe, driver) {\n    var _this;\n    _classCallCheck(this, ClientWidgetApi);\n    _this = _super.call(this);\n    _this.widget = widget;\n    _this.iframe = iframe;\n    _this.driver = driver;\n    _defineProperty(_assertThisInitialized(_this), \"transport\", void 0);\n    // contentLoadedActionSent is used to check that only one ContentLoaded request is send.\n    _defineProperty(_assertThisInitialized(_this), \"contentLoadedActionSent\", false);\n    _defineProperty(_assertThisInitialized(_this), \"allowedCapabilities\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"allowedEvents\", []);\n    _defineProperty(_assertThisInitialized(_this), \"isStopped\", false);\n    _defineProperty(_assertThisInitialized(_this), \"turnServers\", null);\n    _defineProperty(_assertThisInitialized(_this), \"contentLoadedWaitTimer\", void 0);\n    if (!(iframe !== null && iframe !== void 0 && iframe.contentWindow)) {\n      throw new Error(\"No iframe supplied\");\n    }\n    if (!widget) {\n      throw new Error(\"Invalid widget\");\n    }\n    if (!driver) {\n      throw new Error(\"Invalid driver\");\n    }\n    _this.transport = new _PostmessageTransport.PostmessageTransport(_WidgetApiDirection.WidgetApiDirection.ToWidget, widget.id, iframe.contentWindow, window);\n    _this.transport.targetOrigin = widget.origin;\n    _this.transport.on(\"message\", _this.handleMessage.bind(_assertThisInitialized(_this)));\n    iframe.addEventListener(\"load\", _this.onIframeLoad.bind(_assertThisInitialized(_this)));\n    _this.transport.start();\n    return _this;\n  }\n  _createClass(ClientWidgetApi, [{\n    key: \"hasCapability\",\n    value: function hasCapability(capability) {\n      return this.allowedCapabilities.has(capability);\n    }\n  }, {\n    key: \"canUseRoomTimeline\",\n    value: function canUseRoomTimeline(roomId) {\n      return this.hasCapability(\"org.matrix.msc2762.timeline:\".concat(_Symbols.Symbols.AnyRoom)) || this.hasCapability(\"org.matrix.msc2762.timeline:\".concat(roomId));\n    }\n  }, {\n    key: \"canSendRoomEvent\",\n    value: function canSendRoomEvent(eventType) {\n      var msgtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsRoomEvent(_WidgetEventCapability.EventDirection.Send, eventType, msgtype);\n      });\n    }\n  }, {\n    key: \"canSendStateEvent\",\n    value: function canSendStateEvent(eventType, stateKey) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsStateEvent(_WidgetEventCapability.EventDirection.Send, eventType, stateKey);\n      });\n    }\n  }, {\n    key: \"canSendToDeviceEvent\",\n    value: function canSendToDeviceEvent(eventType) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsToDeviceEvent(_WidgetEventCapability.EventDirection.Send, eventType);\n      });\n    }\n  }, {\n    key: \"canReceiveRoomEvent\",\n    value: function canReceiveRoomEvent(eventType) {\n      var msgtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsRoomEvent(_WidgetEventCapability.EventDirection.Receive, eventType, msgtype);\n      });\n    }\n  }, {\n    key: \"canReceiveStateEvent\",\n    value: function canReceiveStateEvent(eventType, stateKey) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsStateEvent(_WidgetEventCapability.EventDirection.Receive, eventType, stateKey);\n      });\n    }\n  }, {\n    key: \"canReceiveToDeviceEvent\",\n    value: function canReceiveToDeviceEvent(eventType) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsToDeviceEvent(_WidgetEventCapability.EventDirection.Receive, eventType);\n      });\n    }\n  }, {\n    key: \"canReceiveRoomAccountData\",\n    value: function canReceiveRoomAccountData(eventType) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsRoomAccountData(_WidgetEventCapability.EventDirection.Receive, eventType);\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.isStopped = true;\n      this.transport.stop();\n    }\n  }, {\n    key: \"beginCapabilities\",\n    value: function beginCapabilities() {\n      var _this2 = this;\n      // widget has loaded - tell all the listeners that\n      this.emit(\"preparing\");\n      var requestedCaps;\n      this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.Capabilities, {}).then(function (caps) {\n        requestedCaps = caps.capabilities;\n        return _this2.driver.validateCapabilities(new Set(caps.capabilities));\n      }).then(function (allowedCaps) {\n        console.log(\"Widget \".concat(_this2.widget.id, \" is allowed capabilities:\"), Array.from(allowedCaps));\n        _this2.allowedCapabilities = allowedCaps;\n        _this2.allowedEvents = _WidgetEventCapability.WidgetEventCapability.findEventCapabilities(allowedCaps);\n        _this2.notifyCapabilities(requestedCaps);\n        _this2.emit(\"ready\");\n      })[\"catch\"](function (e) {\n        _this2.emit(\"error:preparing\", e);\n      });\n    }\n  }, {\n    key: \"notifyCapabilities\",\n    value: function notifyCapabilities(requested) {\n      var _this3 = this;\n      this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.NotifyCapabilities, {\n        requested: requested,\n        approved: Array.from(this.allowedCapabilities)\n      })[\"catch\"](function (e) {\n        console.warn(\"non-fatal error notifying widget of approved capabilities:\", e);\n      }).then(function () {\n        _this3.emit(\"capabilitiesNotified\");\n      });\n    }\n  }, {\n    key: \"onIframeLoad\",\n    value: function onIframeLoad(ev) {\n      if (this.widget.waitForIframeLoad) {\n        // If the widget is set to waitForIframeLoad the capabilities immediatly get setup after load.\n        // The client does not wait for the ContentLoaded action.\n        this.beginCapabilities();\n      } else {\n        // Reaching this means, that the Iframe got reloaded/loaded and\n        // the clientApi is awaiting the FIRST ContentLoaded action.\n        console.log(\"waitForIframeLoad is false: waiting for widget to send contentLoaded\");\n        this.contentLoadedWaitTimer = setTimeout(function () {\n          console.error(\"Widget specified waitForIframeLoad=false but timed out waiting for contentLoaded event!\");\n        }, 10000);\n        this.contentLoadedActionSent = false;\n      }\n    }\n  }, {\n    key: \"handleContentLoadedAction\",\n    value: function handleContentLoadedAction(action) {\n      if (this.contentLoadedWaitTimer !== undefined) {\n        clearTimeout(this.contentLoadedWaitTimer);\n        this.contentLoadedWaitTimer = undefined;\n      }\n      if (this.contentLoadedActionSent) {\n        throw new Error(\"Improper sequence: ContentLoaded Action can only be sent once after the widget loaded \" + \"and should only be used if waitForIframeLoad is false (default=true)\");\n      }\n      if (this.widget.waitForIframeLoad) {\n        this.transport.reply(action, {\n          error: {\n            message: \"Improper sequence: not expecting ContentLoaded event if \" + \"waitForIframeLoad is true (default=true)\"\n          }\n        });\n      } else {\n        this.transport.reply(action, {});\n        this.beginCapabilities();\n      }\n      this.contentLoadedActionSent = true;\n    }\n  }, {\n    key: \"replyVersions\",\n    value: function replyVersions(request) {\n      this.transport.reply(request, {\n        supported_versions: _ApiVersion.CurrentApiVersions\n      });\n    }\n  }, {\n    key: \"handleCapabilitiesRenegotiate\",\n    value: function handleCapabilitiesRenegotiate(request) {\n      var _request$data,\n        _this4 = this;\n      // acknowledge first\n      this.transport.reply(request, {});\n      var requested = ((_request$data = request.data) === null || _request$data === void 0 ? void 0 : _request$data.capabilities) || [];\n      var newlyRequested = new Set(requested.filter(function (r) {\n        return !_this4.hasCapability(r);\n      }));\n      if (newlyRequested.size === 0) {\n        // Nothing to do - notify capabilities\n        return this.notifyCapabilities([]);\n      }\n      this.driver.validateCapabilities(newlyRequested).then(function (allowed) {\n        allowed.forEach(function (c) {\n          return _this4.allowedCapabilities.add(c);\n        });\n        var allowedEvents = _WidgetEventCapability.WidgetEventCapability.findEventCapabilities(allowed);\n        allowedEvents.forEach(function (c) {\n          return _this4.allowedEvents.push(c);\n        });\n        return _this4.notifyCapabilities(Array.from(newlyRequested));\n      });\n    }\n  }, {\n    key: \"handleNavigate\",\n    value: function handleNavigate(request) {\n      var _request$data2,\n        _request$data3,\n        _this5 = this;\n      if (!this.hasCapability(_Capabilities.MatrixCapabilities.MSC2931Navigate)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Missing capability\"\n          }\n        });\n      }\n      if (!((_request$data2 = request.data) !== null && _request$data2 !== void 0 && _request$data2.uri) || !((_request$data3 = request.data) !== null && _request$data3 !== void 0 && _request$data3.uri.toString().startsWith(\"https://matrix.to/#\"))) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid matrix.to URI\"\n          }\n        });\n      }\n      var onErr = function onErr(e) {\n        console.error(\"[ClientWidgetApi] Failed to handle navigation: \", e);\n        return _this5.transport.reply(request, {\n          error: {\n            message: \"Error handling navigation\"\n          }\n        });\n      };\n      try {\n        this.driver.navigate(request.data.uri.toString())[\"catch\"](function (e) {\n          return onErr(e);\n        }).then(function () {\n          return _this5.transport.reply(request, {});\n        });\n      } catch (e) {\n        return onErr(e);\n      }\n    }\n  }, {\n    key: \"handleOIDC\",\n    value: function handleOIDC(request) {\n      var _this6 = this;\n      var phase = 1; // 1 = initial request, 2 = after user manual confirmation\n\n      var replyState = function replyState(state, credential) {\n        credential = credential || {};\n        if (phase > 1) {\n          return _this6.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.OpenIDCredentials, _objectSpread({\n            state: state,\n            original_request_id: request.requestId\n          }, credential));\n        } else {\n          return _this6.transport.reply(request, _objectSpread({\n            state: state\n          }, credential));\n        }\n      };\n      var replyError = function replyError(msg) {\n        console.error(\"[ClientWidgetApi] Failed to handle OIDC: \", msg);\n        if (phase > 1) {\n          // We don't have a way to indicate that a random error happened in this flow, so\n          // just block the attempt.\n          return replyState(_GetOpenIDAction.OpenIDRequestState.Blocked);\n        } else {\n          return _this6.transport.reply(request, {\n            error: {\n              message: msg\n            }\n          });\n        }\n      };\n      var observer = new _SimpleObservable.SimpleObservable(function (update) {\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.PendingUserConfirmation && phase > 1) {\n          observer.close();\n          return replyError(\"client provided out-of-phase response to OIDC flow\");\n        }\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.PendingUserConfirmation) {\n          replyState(update.state);\n          phase++;\n          return;\n        }\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.Allowed && !update.token) {\n          return replyError(\"client provided invalid OIDC token for an allowed request\");\n        }\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.Blocked) {\n          update.token = undefined; // just in case the client did something weird\n        }\n\n        observer.close();\n        return replyState(update.state, update.token);\n      });\n      this.driver.askOpenID(observer);\n    }\n  }, {\n    key: \"handleReadRoomAccountData\",\n    value: function handleReadRoomAccountData(request) {\n      var _this7 = this;\n      var events = Promise.resolve([]);\n      events = this.driver.readRoomAccountData(request.data.type);\n      if (!this.canReceiveRoomAccountData(request.data.type)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Cannot read room account data of this type\"\n          }\n        });\n      }\n      return events.then(function (evs) {\n        _this7.transport.reply(request, {\n          events: evs\n        });\n      });\n    }\n  }, {\n    key: \"handleReadEvents\",\n    value: function handleReadEvents(request) {\n      var _this8 = this;\n      if (!request.data.type) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid request - missing event type\"\n          }\n        });\n      }\n      if (request.data.limit !== undefined && (!request.data.limit || request.data.limit < 0)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid request - limit out of range\"\n          }\n        });\n      }\n      var askRoomIds = null; // null denotes current room only\n      if (request.data.room_ids) {\n        askRoomIds = request.data.room_ids;\n        if (!Array.isArray(askRoomIds)) {\n          askRoomIds = [askRoomIds];\n        }\n        var _iterator2 = _createForOfIteratorHelper(askRoomIds),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var roomId = _step2.value;\n            if (!this.canUseRoomTimeline(roomId)) {\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Unable to access room timeline: \".concat(roomId)\n                }\n              });\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      var limit = request.data.limit || 0;\n      var since = request.data.since;\n      var events = Promise.resolve([]);\n      if (request.data.state_key !== undefined) {\n        var stateKey = request.data.state_key === true ? undefined : request.data.state_key.toString();\n        if (!this.canReceiveStateEvent(request.data.type, stateKey !== null && stateKey !== void 0 ? stateKey : null)) {\n          return this.transport.reply(request, {\n            error: {\n              message: \"Cannot read state events of this type\"\n            }\n          });\n        }\n        events = this.driver.readStateEvents(request.data.type, stateKey, limit, askRoomIds);\n      } else {\n        if (!this.canReceiveRoomEvent(request.data.type, request.data.msgtype)) {\n          return this.transport.reply(request, {\n            error: {\n              message: \"Cannot read room events of this type\"\n            }\n          });\n        }\n        events = this.driver.readRoomEvents(request.data.type, request.data.msgtype, limit, askRoomIds, since);\n      }\n      return events.then(function (evs) {\n        return _this8.transport.reply(request, {\n          events: evs\n        });\n      });\n    }\n  }, {\n    key: \"handleSendEvent\",\n    value: function handleSendEvent(request) {\n      var _this9 = this;\n      if (!request.data.type) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid request - missing event type\"\n          }\n        });\n      }\n      if (!!request.data.room_id && !this.canUseRoomTimeline(request.data.room_id)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Unable to access room timeline: \".concat(request.data.room_id)\n          }\n        });\n      }\n      var isDelayedEvent = request.data.delay !== undefined || request.data.parent_delay_id !== undefined;\n      if (isDelayedEvent && !this.hasCapability(_Capabilities.MatrixCapabilities.MSC4157SendDelayedEvent)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Missing capability\"\n          }\n        });\n      }\n      var sendEventPromise;\n      if (request.data.state_key !== undefined) {\n        if (!this.canSendStateEvent(request.data.type, request.data.state_key)) {\n          return this.transport.reply(request, {\n            error: {\n              message: \"Cannot send state events of this type\"\n            }\n          });\n        }\n        if (!isDelayedEvent) {\n          sendEventPromise = this.driver.sendEvent(request.data.type, request.data.content || {}, request.data.state_key, request.data.room_id);\n        } else {\n          var _request$data$delay, _request$data$parent_;\n          sendEventPromise = this.driver.sendDelayedEvent((_request$data$delay = request.data.delay) !== null && _request$data$delay !== void 0 ? _request$data$delay : null, (_request$data$parent_ = request.data.parent_delay_id) !== null && _request$data$parent_ !== void 0 ? _request$data$parent_ : null, request.data.type, request.data.content || {}, request.data.state_key, request.data.room_id);\n        }\n      } else {\n        var content = request.data.content || {};\n        var msgtype = content['msgtype'];\n        if (!this.canSendRoomEvent(request.data.type, msgtype)) {\n          return this.transport.reply(request, {\n            error: {\n              message: \"Cannot send room events of this type\"\n            }\n          });\n        }\n        if (!isDelayedEvent) {\n          sendEventPromise = this.driver.sendEvent(request.data.type, content, null,\n          // not sending a state event\n          request.data.room_id);\n        } else {\n          var _request$data$delay2, _request$data$parent_2;\n          sendEventPromise = this.driver.sendDelayedEvent((_request$data$delay2 = request.data.delay) !== null && _request$data$delay2 !== void 0 ? _request$data$delay2 : null, (_request$data$parent_2 = request.data.parent_delay_id) !== null && _request$data$parent_2 !== void 0 ? _request$data$parent_2 : null, request.data.type, content, null,\n          // not sending a state event\n          request.data.room_id);\n        }\n      }\n      sendEventPromise.then(function (sentEvent) {\n        return _this9.transport.reply(request, _objectSpread({\n          room_id: sentEvent.roomId\n        }, \"eventId\" in sentEvent ? {\n          event_id: sentEvent.eventId\n        } : {\n          delay_id: sentEvent.delayId\n        }));\n      })[\"catch\"](function (e) {\n        console.error(\"error sending event: \", e);\n        return _this9.transport.reply(request, {\n          error: {\n            message: \"Error sending event\"\n          }\n        });\n      });\n    }\n  }, {\n    key: \"handleUpdateDelayedEvent\",\n    value: function handleUpdateDelayedEvent(request) {\n      var _this10 = this;\n      if (!request.data.delay_id) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid request - missing delay_id\"\n          }\n        });\n      }\n      if (!this.hasCapability(_Capabilities.MatrixCapabilities.MSC4157UpdateDelayedEvent)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Missing capability\"\n          }\n        });\n      }\n      switch (request.data.action) {\n        case _UpdateDelayedEventAction.UpdateDelayedEventAction.Cancel:\n        case _UpdateDelayedEventAction.UpdateDelayedEventAction.Restart:\n        case _UpdateDelayedEventAction.UpdateDelayedEventAction.Send:\n          this.driver.updateDelayedEvent(request.data.delay_id, request.data.action).then(function () {\n            return _this10.transport.reply(request, {});\n          })[\"catch\"](function (e) {\n            console.error(\"error updating delayed event: \", e);\n            return _this10.transport.reply(request, {\n              error: {\n                message: \"Error updating delayed event\"\n              }\n            });\n          });\n          break;\n        default:\n          return this.transport.reply(request, {\n            error: {\n              message: \"Invalid request - unsupported action\"\n            }\n          });\n      }\n    }\n  }, {\n    key: \"handleSendToDevice\",\n    value: function () {\n      var _handleSendToDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (request.data.type) {\n                _context.next = 5;\n                break;\n              }\n              _context.next = 3;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing event type\"\n                }\n              });\n            case 3:\n              _context.next = 32;\n              break;\n            case 5:\n              if (request.data.messages) {\n                _context.next = 10;\n                break;\n              }\n              _context.next = 8;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing event contents\"\n                }\n              });\n            case 8:\n              _context.next = 32;\n              break;\n            case 10:\n              if (!(typeof request.data.encrypted !== \"boolean\")) {\n                _context.next = 15;\n                break;\n              }\n              _context.next = 13;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing encryption flag\"\n                }\n              });\n            case 13:\n              _context.next = 32;\n              break;\n            case 15:\n              if (this.canSendToDeviceEvent(request.data.type)) {\n                _context.next = 20;\n                break;\n              }\n              _context.next = 18;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Cannot send to-device events of this type\"\n                }\n              });\n            case 18:\n              _context.next = 32;\n              break;\n            case 20:\n              _context.prev = 20;\n              _context.next = 23;\n              return this.driver.sendToDevice(request.data.type, request.data.encrypted, request.data.messages);\n            case 23:\n              _context.next = 25;\n              return this.transport.reply(request, {});\n            case 25:\n              _context.next = 32;\n              break;\n            case 27:\n              _context.prev = 27;\n              _context.t0 = _context[\"catch\"](20);\n              console.error(\"error sending to-device event\", _context.t0);\n              _context.next = 32;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Error sending event\"\n                }\n              });\n            case 32:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[20, 27]]);\n      }));\n      function handleSendToDevice(_x) {\n        return _handleSendToDevice.apply(this, arguments);\n      }\n      return handleSendToDevice;\n    }()\n  }, {\n    key: \"pollTurnServers\",\n    value: function () {\n      var _pollTurnServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(turnServers, initialServer) {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, server;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateTurnServers, initialServer // it's compatible, but missing the index signature\n              );\n            case 3:\n              // Pick the generator up where we left off\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context2.prev = 5;\n              _iterator = _asyncIterator(turnServers);\n            case 7:\n              _context2.next = 9;\n              return _iterator.next();\n            case 9:\n              if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n                _context2.next = 16;\n                break;\n              }\n              server = _step.value;\n              _context2.next = 13;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateTurnServers, server // it's compatible, but missing the index signature\n              );\n            case 13:\n              _iteratorAbruptCompletion = false;\n              _context2.next = 7;\n              break;\n            case 16:\n              _context2.next = 22;\n              break;\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](5);\n              _didIteratorError = true;\n              _iteratorError = _context2.t0;\n            case 22:\n              _context2.prev = 22;\n              _context2.prev = 23;\n              if (!(_iteratorAbruptCompletion && _iterator[\"return\"] != null)) {\n                _context2.next = 27;\n                break;\n              }\n              _context2.next = 27;\n              return _iterator[\"return\"]();\n            case 27:\n              _context2.prev = 27;\n              if (!_didIteratorError) {\n                _context2.next = 30;\n                break;\n              }\n              throw _iteratorError;\n            case 30:\n              return _context2.finish(27);\n            case 31:\n              return _context2.finish(22);\n            case 32:\n              _context2.next = 37;\n              break;\n            case 34:\n              _context2.prev = 34;\n              _context2.t1 = _context2[\"catch\"](0);\n              console.error(\"error polling for TURN servers\", _context2.t1);\n            case 37:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[0, 34], [5, 18, 22, 32], [23,, 27, 31]]);\n      }));\n      function pollTurnServers(_x2, _x3) {\n        return _pollTurnServers.apply(this, arguments);\n      }\n      return pollTurnServers;\n    }()\n  }, {\n    key: \"handleWatchTurnServers\",\n    value: function () {\n      var _handleWatchTurnServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {\n        var turnServers, _yield$turnServers$ne, done, value;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC3846TurnServers)) {\n                _context3.next = 5;\n                break;\n              }\n              _context3.next = 3;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              });\n            case 3:\n              _context3.next = 30;\n              break;\n            case 5:\n              if (!this.turnServers) {\n                _context3.next = 10;\n                break;\n              }\n              _context3.next = 8;\n              return this.transport.reply(request, {});\n            case 8:\n              _context3.next = 30;\n              break;\n            case 10:\n              _context3.prev = 10;\n              turnServers = this.driver.getTurnServers(); // Peek at the first result, so we can at least verify that the\n              // client isn't banned from getting TURN servers entirely\n              _context3.next = 14;\n              return turnServers.next();\n            case 14:\n              _yield$turnServers$ne = _context3.sent;\n              done = _yield$turnServers$ne.done;\n              value = _yield$turnServers$ne.value;\n              if (!done) {\n                _context3.next = 19;\n                break;\n              }\n              throw new Error(\"Client refuses to provide any TURN servers\");\n            case 19:\n              _context3.next = 21;\n              return this.transport.reply(request, {});\n            case 21:\n              // Start the poll loop, sending the widget the initial result\n              this.pollTurnServers(turnServers, value);\n              this.turnServers = turnServers;\n              _context3.next = 30;\n              break;\n            case 25:\n              _context3.prev = 25;\n              _context3.t0 = _context3[\"catch\"](10);\n              console.error(\"error getting first TURN server results\", _context3.t0);\n              _context3.next = 30;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"TURN servers not available\"\n                }\n              });\n            case 30:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[10, 25]]);\n      }));\n      function handleWatchTurnServers(_x4) {\n        return _handleWatchTurnServers.apply(this, arguments);\n      }\n      return handleWatchTurnServers;\n    }()\n  }, {\n    key: \"handleUnwatchTurnServers\",\n    value: function () {\n      var _handleUnwatchTurnServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC3846TurnServers)) {\n                _context4.next = 5;\n                break;\n              }\n              _context4.next = 3;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              });\n            case 3:\n              _context4.next = 15;\n              break;\n            case 5:\n              if (this.turnServers) {\n                _context4.next = 10;\n                break;\n              }\n              _context4.next = 8;\n              return this.transport.reply(request, {});\n            case 8:\n              _context4.next = 15;\n              break;\n            case 10:\n              _context4.next = 12;\n              return this.turnServers[\"return\"](undefined);\n            case 12:\n              this.turnServers = null;\n              _context4.next = 15;\n              return this.transport.reply(request, {});\n            case 15:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function handleUnwatchTurnServers(_x5) {\n        return _handleUnwatchTurnServers.apply(this, arguments);\n      }\n      return handleUnwatchTurnServers;\n    }()\n  }, {\n    key: \"handleReadRelations\",\n    value: function () {\n      var _handleReadRelations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {\n        var _this11 = this;\n        var result, chunk;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (request.data.event_id) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing event ID\"\n                }\n              }));\n            case 2:\n              if (!(request.data.limit !== undefined && request.data.limit < 0)) {\n                _context5.next = 4;\n                break;\n              }\n              return _context5.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - limit out of range\"\n                }\n              }));\n            case 4:\n              if (!(request.data.room_id !== undefined && !this.canUseRoomTimeline(request.data.room_id))) {\n                _context5.next = 6;\n                break;\n              }\n              return _context5.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Unable to access room timeline: \".concat(request.data.room_id)\n                }\n              }));\n            case 6:\n              _context5.prev = 6;\n              _context5.next = 9;\n              return this.driver.readEventRelations(request.data.event_id, request.data.room_id, request.data.rel_type, request.data.event_type, request.data.from, request.data.to, request.data.limit, request.data.direction);\n            case 9:\n              result = _context5.sent;\n              // only return events that the user has the permission to receive\n              chunk = result.chunk.filter(function (e) {\n                if (e.state_key !== undefined) {\n                  return _this11.canReceiveStateEvent(e.type, e.state_key);\n                } else {\n                  return _this11.canReceiveRoomEvent(e.type, e.content['msgtype']);\n                }\n              });\n              return _context5.abrupt(\"return\", this.transport.reply(request, {\n                chunk: chunk,\n                prev_batch: result.prevBatch,\n                next_batch: result.nextBatch\n              }));\n            case 14:\n              _context5.prev = 14;\n              _context5.t0 = _context5[\"catch\"](6);\n              console.error(\"error getting the relations\", _context5.t0);\n              _context5.next = 19;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Unexpected error while reading relations\"\n                }\n              });\n            case 19:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[6, 14]]);\n      }));\n      function handleReadRelations(_x6) {\n        return _handleReadRelations.apply(this, arguments);\n      }\n      return handleReadRelations;\n    }()\n  }, {\n    key: \"handleUserDirectorySearch\",\n    value: function () {\n      var _handleUserDirectorySearch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC3973UserDirectorySearch)) {\n                _context6.next = 2;\n                break;\n              }\n              return _context6.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              if (!(typeof request.data.search_term !== 'string')) {\n                _context6.next = 4;\n                break;\n              }\n              return _context6.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing search term\"\n                }\n              }));\n            case 4:\n              if (!(request.data.limit !== undefined && request.data.limit < 0)) {\n                _context6.next = 6;\n                break;\n              }\n              return _context6.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - limit out of range\"\n                }\n              }));\n            case 6:\n              _context6.prev = 6;\n              _context6.next = 9;\n              return this.driver.searchUserDirectory(request.data.search_term, request.data.limit);\n            case 9:\n              result = _context6.sent;\n              return _context6.abrupt(\"return\", this.transport.reply(request, {\n                limited: result.limited,\n                results: result.results.map(function (r) {\n                  return {\n                    user_id: r.userId,\n                    display_name: r.displayName,\n                    avatar_url: r.avatarUrl\n                  };\n                })\n              }));\n            case 13:\n              _context6.prev = 13;\n              _context6.t0 = _context6[\"catch\"](6);\n              console.error(\"error searching in the user directory\", _context6.t0);\n              _context6.next = 18;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Unexpected error while searching in the user directory\"\n                }\n              });\n            case 18:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[6, 13]]);\n      }));\n      function handleUserDirectorySearch(_x7) {\n        return _handleUserDirectorySearch.apply(this, arguments);\n      }\n      return handleUserDirectorySearch;\n    }()\n  }, {\n    key: \"handleGetMediaConfig\",\n    value: function () {\n      var _handleGetMediaConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC4039UploadFile)) {\n                _context7.next = 2;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              _context7.prev = 2;\n              _context7.next = 5;\n              return this.driver.getMediaConfig();\n            case 5:\n              result = _context7.sent;\n              return _context7.abrupt(\"return\", this.transport.reply(request, result));\n            case 9:\n              _context7.prev = 9;\n              _context7.t0 = _context7[\"catch\"](2);\n              console.error(\"error while getting the media configuration\", _context7.t0);\n              _context7.next = 14;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Unexpected error while getting the media configuration\"\n                }\n              });\n            case 14:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[2, 9]]);\n      }));\n      function handleGetMediaConfig(_x8) {\n        return _handleGetMediaConfig.apply(this, arguments);\n      }\n      return handleGetMediaConfig;\n    }()\n  }, {\n    key: \"handleUploadFile\",\n    value: function () {\n      var _handleUploadFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC4039UploadFile)) {\n                _context8.next = 2;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              _context8.prev = 2;\n              _context8.next = 5;\n              return this.driver.uploadFile(request.data.file);\n            case 5:\n              result = _context8.sent;\n              return _context8.abrupt(\"return\", this.transport.reply(request, {\n                content_uri: result.contentUri\n              }));\n            case 9:\n              _context8.prev = 9;\n              _context8.t0 = _context8[\"catch\"](2);\n              console.error(\"error while uploading a file\", _context8.t0);\n              _context8.next = 14;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Unexpected error while uploading a file\"\n                }\n              });\n            case 14:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 9]]);\n      }));\n      function handleUploadFile(_x9) {\n        return _handleUploadFile.apply(this, arguments);\n      }\n      return handleUploadFile;\n    }()\n  }, {\n    key: \"handleDownloadFile\",\n    value: function () {\n      var _handleDownloadFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC4039DownloadFile)) {\n                _context9.next = 2;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              _context9.prev = 2;\n              _context9.next = 5;\n              return this.driver.downloadFile(request.data.content_uri);\n            case 5:\n              result = _context9.sent;\n              return _context9.abrupt(\"return\", this.transport.reply(request, {\n                file: result.file\n              }));\n            case 9:\n              _context9.prev = 9;\n              _context9.t0 = _context9[\"catch\"](2);\n              console.error(\"error while downloading a file\", _context9.t0);\n              this.transport.reply(request, {\n                error: {\n                  message: \"Unexpected error while downloading a file\"\n                }\n              });\n            case 13:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[2, 9]]);\n      }));\n      function handleDownloadFile(_x10) {\n        return _handleDownloadFile.apply(this, arguments);\n      }\n      return handleDownloadFile;\n    }()\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage(ev) {\n      if (this.isStopped) return;\n      var actionEv = new CustomEvent(\"action:\".concat(ev.detail.action), {\n        detail: ev.detail,\n        cancelable: true\n      });\n      this.emit(\"action:\".concat(ev.detail.action), actionEv);\n      if (!actionEv.defaultPrevented) {\n        switch (ev.detail.action) {\n          case _WidgetApiAction.WidgetApiFromWidgetAction.ContentLoaded:\n            return this.handleContentLoadedAction(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.SupportedApiVersions:\n            return this.replyVersions(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.SendEvent:\n            return this.handleSendEvent(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.SendToDevice:\n            return this.handleSendToDevice(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.GetOpenIDCredentials:\n            return this.handleOIDC(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC2931Navigate:\n            return this.handleNavigate(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC2974RenegotiateCapabilities:\n            return this.handleCapabilitiesRenegotiate(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC2876ReadEvents:\n            return this.handleReadEvents(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.WatchTurnServers:\n            return this.handleWatchTurnServers(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.UnwatchTurnServers:\n            return this.handleUnwatchTurnServers(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC3869ReadRelations:\n            return this.handleReadRelations(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC3973UserDirectorySearch:\n            return this.handleUserDirectorySearch(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.BeeperReadRoomAccountData:\n            return this.handleReadRoomAccountData(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4039GetMediaConfigAction:\n            return this.handleGetMediaConfig(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4039UploadFileAction:\n            return this.handleUploadFile(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4039DownloadFileAction:\n            return this.handleDownloadFile(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4157UpdateDelayedEvent:\n            return this.handleUpdateDelayedEvent(ev.detail);\n          default:\n            return this.transport.reply(ev.detail, {\n              error: {\n                message: \"Unknown or unsupported action: \" + ev.detail.action\n              }\n            });\n        }\n      }\n    }\n\n    /**\n     * Takes a screenshot of the widget.\n     * @returns Resolves to the widget's screenshot.\n     * @throws Throws if there is a problem.\n     */\n  }, {\n    key: \"takeScreenshot\",\n    value: function takeScreenshot() {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.TakeScreenshot, {});\n    }\n\n    /**\n     * Alerts the widget to whether or not it is currently visible.\n     * @param {boolean} isVisible Whether the widget is visible or not.\n     * @returns {Promise<IWidgetApiResponseData>} Resolves when the widget acknowledges the update.\n     */\n  }, {\n    key: \"updateVisibility\",\n    value: function updateVisibility(isVisible) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateVisibility, {\n        visible: isVisible\n      });\n    }\n  }, {\n    key: \"sendWidgetConfig\",\n    value: function sendWidgetConfig(data) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.WidgetConfig, data).then();\n    }\n  }, {\n    key: \"notifyModalWidgetButtonClicked\",\n    value: function notifyModalWidgetButtonClicked(id) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.ButtonClicked, {\n        id: id\n      }).then();\n    }\n  }, {\n    key: \"notifyModalWidgetClose\",\n    value: function notifyModalWidgetClose(data) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.CloseModalWidget, data).then();\n    }\n\n    /**\n     * Feeds an event to the widget. If the widget is not able to accept the event due to\n     * permissions, this will no-op and return calmly. If the widget failed to handle the\n     * event, this will raise an error.\n     * @param {IRoomEvent} rawEvent The event to (try to) send to the widget.\n     * @param {string} currentViewedRoomId The room ID the user is currently interacting with.\n     * Not the room ID of the event.\n     * @returns {Promise<void>} Resolves when complete, rejects if there was an error sending.\n     */\n  }, {\n    key: \"feedEvent\",\n    value: function () {\n      var _feedEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(rawEvent, currentViewedRoomId) {\n        var _rawEvent$content;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (!(rawEvent.room_id !== currentViewedRoomId && !this.canUseRoomTimeline(rawEvent.room_id))) {\n                _context10.next = 2;\n                break;\n              }\n              return _context10.abrupt(\"return\");\n            case 2:\n              if (!(rawEvent.state_key !== undefined && rawEvent.state_key !== null)) {\n                _context10.next = 7;\n                break;\n              }\n              if (this.canReceiveStateEvent(rawEvent.type, rawEvent.state_key)) {\n                _context10.next = 5;\n                break;\n              }\n              return _context10.abrupt(\"return\");\n            case 5:\n              _context10.next = 9;\n              break;\n            case 7:\n              if (this.canReceiveRoomEvent(rawEvent.type, (_rawEvent$content = rawEvent.content) === null || _rawEvent$content === void 0 ? void 0 : _rawEvent$content[\"msgtype\"])) {\n                _context10.next = 9;\n                break;\n              }\n              return _context10.abrupt(\"return\");\n            case 9:\n              _context10.next = 11;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.SendEvent, rawEvent // it's compatible, but missing the index signature\n              );\n            case 11:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function feedEvent(_x11, _x12) {\n        return _feedEvent.apply(this, arguments);\n      }\n      return feedEvent;\n    }()\n    /**\n     * Feeds a to-device event to the widget. If the widget is not able to accept the\n     * event due to permissions, this will no-op and return calmly. If the widget failed\n     * to handle the event, this will raise an error.\n     * @param {IRoomEvent} rawEvent The event to (try to) send to the widget.\n     * @param {boolean} encrypted Whether the event contents were encrypted.\n     * @returns {Promise<void>} Resolves when complete, rejects if there was an error sending.\n     */\n  }, {\n    key: \"feedToDevice\",\n    value: function () {\n      var _feedToDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(rawEvent, encrypted) {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (!this.canReceiveToDeviceEvent(rawEvent.type)) {\n                _context11.next = 3;\n                break;\n              }\n              _context11.next = 3;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.SendToDevice, // it's compatible, but missing the index signature\n              _objectSpread(_objectSpread({}, rawEvent), {}, {\n                encrypted: encrypted\n              }));\n            case 3:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function feedToDevice(_x13, _x14) {\n        return _feedToDevice.apply(this, arguments);\n      }\n      return feedToDevice;\n    }()\n  }]);\n  return ClientWidgetApi;\n}(_events.EventEmitter);\nexports.ClientWidgetApi = ClientWidgetApi;\n//# sourceMappingURL=ClientWidgetApi.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WidgetParser = void 0;\nvar _Widget = require(\"./Widget\");\nvar _url = require(\"./validation/url\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); } /*\n                                                                                                                                                                                                                                                                                                                                                                                               * Copyright 2020 The Matrix.org Foundation C.I.C.\n                                                                                                                                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                                                                                                                                               * Licensed under the Apache License, Version 2.0 (the \"License\");\n                                                                                                                                                                                                                                                                                                                                                                                               * you may not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                               * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                                                                                                                                               *         http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                                                                                                                                               * Unless required by applicable law or agreed to in writing, software\n                                                                                                                                                                                                                                                                                                                                                                                               * distributed under the License is distributed on an \"AS IS\" BASIS,\n                                                                                                                                                                                                                                                                                                                                                                                               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                                                                                                                                                                                                                                                                                                                                                                                               * See the License for the specific language governing permissions and\n                                                                                                                                                                                                                                                                                                                                                                                               * limitations under the License.\n                                                                                                                                                                                                                                                                                                                                                                                               */\nvar WidgetParser = /*#__PURE__*/function () {\n  function WidgetParser() {\n    _classCallCheck(this, WidgetParser);\n  } // private constructor because this is a util class\n\n  /**\n   * Parses widgets from the \"m.widgets\" account data event. This will always\n   * return an array, though may be empty if no valid widgets were found.\n   * @param {IAccountDataWidgets} content The content of the \"m.widgets\" account data.\n   * @returns {Widget[]} The widgets in account data, or an empty array.\n   */\n  _createClass(WidgetParser, null, [{\n    key: \"parseAccountData\",\n    value: function parseAccountData(content) {\n      if (!content) return [];\n      var result = [];\n      for (var _i = 0, _Object$keys = Object.keys(content); _i < _Object$keys.length; _i++) {\n        var _widgetId = _Object$keys[_i];\n        var roughWidget = content[_widgetId];\n        if (!roughWidget) continue;\n        if (roughWidget.type !== \"m.widget\" && roughWidget.type !== \"im.vector.modular.widgets\") continue;\n        if (!roughWidget.sender) continue;\n        var probableWidgetId = roughWidget.state_key || roughWidget.id;\n        if (probableWidgetId !== _widgetId) continue;\n        var asStateEvent = {\n          content: roughWidget.content,\n          sender: roughWidget.sender,\n          type: \"m.widget\",\n          state_key: _widgetId,\n          event_id: \"$example\",\n          room_id: \"!example\",\n          origin_server_ts: 1\n        };\n        var widget = WidgetParser.parseRoomWidget(asStateEvent);\n        if (widget) result.push(widget);\n      }\n      return result;\n    }\n\n    /**\n     * Parses all the widgets possible in the given array. This will always return\n     * an array, though may be empty if no widgets could be parsed.\n     * @param {IStateEvent[]} currentState The room state to parse.\n     * @returns {Widget[]} The widgets in the state, or an empty array.\n     */\n  }, {\n    key: \"parseWidgetsFromRoomState\",\n    value: function parseWidgetsFromRoomState(currentState) {\n      if (!currentState) return [];\n      var result = [];\n      var _iterator = _createForOfIteratorHelper(currentState),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var state = _step.value;\n          var widget = WidgetParser.parseRoomWidget(state);\n          if (widget) result.push(widget);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n\n    /**\n     * Parses a state event into a widget. If the state event does not represent\n     * a widget (wrong event type, invalid widget, etc) then null is returned.\n     * @param {IStateEvent} stateEvent The state event.\n     * @returns {Widget|null} The widget, or null if invalid\n     */\n  }, {\n    key: \"parseRoomWidget\",\n    value: function parseRoomWidget(stateEvent) {\n      if (!stateEvent) return null;\n\n      // TODO: [Legacy] Remove legacy support\n      if (stateEvent.type !== \"m.widget\" && stateEvent.type !== \"im.vector.modular.widgets\") {\n        return null;\n      }\n\n      // Dev note: Throughout this function we have null safety to ensure that\n      // if the caller did not supply something useful that we don't error. This\n      // is done against the requirements of the interface because not everyone\n      // will have an interface to validate against.\n\n      var content = stateEvent.content || {};\n\n      // Form our best approximation of a widget with the information we have\n      var estimatedWidget = {\n        id: stateEvent.state_key,\n        creatorUserId: content['creatorUserId'] || stateEvent.sender,\n        name: content['name'],\n        type: content['type'],\n        url: content['url'],\n        waitForIframeLoad: content['waitForIframeLoad'],\n        data: content['data']\n      };\n\n      // Finally, process that widget\n      return WidgetParser.processEstimatedWidget(estimatedWidget);\n    }\n  }, {\n    key: \"processEstimatedWidget\",\n    value: function processEstimatedWidget(widget) {\n      // Validate that the widget has the best chance of passing as a widget\n      if (!widget.id || !widget.creatorUserId || !widget.type) {\n        return null;\n      }\n      if (!(0, _url.isValidUrl)(widget.url)) {\n        return null;\n      }\n      // TODO: Validate data for known widget types\n      return new _Widget.Widget(widget);\n    }\n  }]);\n  return WidgetParser;\n}();\nexports.WidgetParser = WidgetParser;\n//# sourceMappingURL=WidgetParser.js.map","import { IconName, IconSrc } from 'folds';\n\nimport {\n  EventTimeline,\n  EventTimelineSet,\n  EventType,\n  IPushRule,\n  IPushRules,\n  JoinRule,\n  MatrixClient,\n  MatrixEvent,\n  MsgType,\n  NotificationCountType,\n  RelationType,\n  Room,\n  RoomMember,\n} from 'matrix-js-sdk';\nimport { CryptoBackend } from 'matrix-js-sdk/lib/common-crypto/CryptoBackend';\nimport { AccountDataEvent } from '../../types/matrix/accountData';\nimport {\n  MessageEvent,\n  NotificationType,\n  RoomToParents,\n  RoomType,\n  StateEvent,\n  UnreadInfo,\n} from '../../types/matrix/room';\n\nexport const getStateEvent = (\n  room: Room,\n  eventType: StateEvent,\n  stateKey = ''\n): MatrixEvent | undefined => room.currentState.getStateEvents(eventType, stateKey) ?? undefined;\n\nexport const getStateEvents = (room: Room, eventType: StateEvent): MatrixEvent[] =>\n  room.currentState.getStateEvents(eventType);\n\nexport const getAccountData = (\n  mx: MatrixClient,\n  eventType: AccountDataEvent\n): MatrixEvent | undefined => mx.getAccountData(eventType);\n\nexport const getMDirects = (mDirectEvent: MatrixEvent): Set<string> => {\n  const roomIds = new Set<string>();\n  const userIdToDirects = mDirectEvent?.getContent();\n\n  if (userIdToDirects === undefined) return roomIds;\n\n  Object.keys(userIdToDirects).forEach((userId) => {\n    const directs = userIdToDirects[userId];\n    if (Array.isArray(directs)) {\n      directs.forEach((id) => {\n        if (typeof id === 'string') roomIds.add(id);\n      });\n    }\n  });\n\n  return roomIds;\n};\n\nexport const isDirectInvite = (room: Room | null, myUserId: string | null): boolean => {\n  if (!room || !myUserId) return false;\n  const me = room.getMember(myUserId);\n  const memberEvent = me?.events?.member;\n  const content = memberEvent?.getContent();\n  return content?.is_direct === true;\n};\n\nexport const isSpace = (room: Room | null): boolean => {\n  if (!room) return false;\n  const event = getStateEvent(room, StateEvent.RoomCreate);\n  if (!event) return false;\n  return event.getContent().type === RoomType.Space;\n};\n\nexport const isRoom = (room: Room | null): boolean => {\n  if (!room) return false;\n  const event = getStateEvent(room, StateEvent.RoomCreate);\n  if (!event) return true;\n  return event.getContent().type !== RoomType.Space;\n};\n\nexport const isUnsupportedRoom = (room: Room | null): boolean => {\n  if (!room) return false;\n  const event = getStateEvent(room, StateEvent.RoomCreate);\n  if (!event) return true; // Consider room unsupported if m.room.create event doesn't exist\n  return event.getContent().type !== undefined && event.getContent().type !== RoomType.Space;\n};\n\nexport function isValidChild(mEvent: MatrixEvent): boolean {\n  return (\n    mEvent.getType() === StateEvent.SpaceChild &&\n    Array.isArray(mEvent.getContent<{ via: string[] }>().via)\n  );\n}\n\nexport const getAllParents = (roomToParents: RoomToParents, roomId: string): Set<string> => {\n  const allParents = new Set<string>();\n\n  const addAllParentIds = (rId: string) => {\n    if (allParents.has(rId)) return;\n    allParents.add(rId);\n\n    const parents = roomToParents.get(rId);\n    parents?.forEach((id) => addAllParentIds(id));\n  };\n  addAllParentIds(roomId);\n  allParents.delete(roomId);\n  return allParents;\n};\n\nexport const getSpaceChildren = (room: Room) =>\n  getStateEvents(room, StateEvent.SpaceChild).reduce<string[]>((filtered, mEvent) => {\n    const stateKey = mEvent.getStateKey();\n    if (isValidChild(mEvent) && stateKey) {\n      filtered.push(stateKey);\n    }\n    return filtered;\n  }, []);\n\nexport const mapParentWithChildren = (\n  roomToParents: RoomToParents,\n  roomId: string,\n  children: string[]\n) => {\n  const allParents = getAllParents(roomToParents, roomId);\n  children.forEach((childId) => {\n    if (allParents.has(childId)) {\n      // Space cycle detected.\n      return;\n    }\n    const parents = roomToParents.get(childId) ?? new Set<string>();\n    parents.add(roomId);\n    roomToParents.set(childId, parents);\n  });\n};\n\nexport const getRoomToParents = (mx: MatrixClient): RoomToParents => {\n  const map: RoomToParents = new Map();\n  mx.getRooms()\n    .filter((room) => isSpace(room))\n    .forEach((room) => mapParentWithChildren(map, room.roomId, getSpaceChildren(room)));\n\n  return map;\n};\n\nexport const getOrphanParents = (roomToParents: RoomToParents, roomId: string): string[] => {\n  const parents = getAllParents(roomToParents, roomId);\n  const orphanParents = Array.from(parents).filter(\n    (parentRoomId) => !roomToParents.has(parentRoomId)\n  );\n\n  return orphanParents;\n};\n\nexport const isMutedRule = (rule: IPushRule) =>\n  rule.actions[0] === 'dont_notify' && rule.conditions?.[0]?.kind === 'event_match';\n\nexport const findMutedRule = (overrideRules: IPushRule[], roomId: string) =>\n  overrideRules.find((rule) => rule.rule_id === roomId && isMutedRule(rule));\n\nexport const getNotificationType = (mx: MatrixClient, roomId: string): NotificationType => {\n  let roomPushRule: IPushRule | undefined;\n  try {\n    roomPushRule = mx.getRoomPushRule('global', roomId);\n  } catch {\n    roomPushRule = undefined;\n  }\n\n  if (!roomPushRule) {\n    const overrideRules = mx.getAccountData('m.push_rules')?.getContent<IPushRules>()\n      ?.global?.override;\n    if (!overrideRules) return NotificationType.Default;\n\n    return findMutedRule(overrideRules, roomId) ? NotificationType.Mute : NotificationType.Default;\n  }\n\n  if (roomPushRule.actions[0] === 'notify') return NotificationType.AllMessages;\n  return NotificationType.MentionsAndKeywords;\n};\n\nconst NOTIFICATION_EVENT_TYPES = [\n  'm.room.create',\n  'm.room.message',\n  'm.room.encrypted',\n  'm.room.member',\n  'm.sticker',\n];\nexport const isNotificationEvent = (mEvent: MatrixEvent) => {\n  const eType = mEvent.getType();\n  if (!NOTIFICATION_EVENT_TYPES.includes(eType)) {\n    return false;\n  }\n  if (eType === 'm.room.member') return false;\n\n  if (mEvent.isRedacted()) return false;\n  if (mEvent.getRelation()?.rel_type === 'm.replace') return false;\n\n  return true;\n};\n\nexport const roomHaveNotification = (room: Room): boolean => {\n  const total = room.getUnreadNotificationCount(NotificationCountType.Total);\n  const highlight = room.getUnreadNotificationCount(NotificationCountType.Highlight);\n\n  return total > 0 || highlight > 0;\n};\n\nexport const roomHaveUnread = (mx: MatrixClient, room: Room) => {\n  const userId = mx.getUserId();\n  if (!userId) return false;\n  const readUpToId = room.getEventReadUpTo(userId);\n  const liveEvents = room.getLiveTimeline().getEvents();\n\n  if (liveEvents[liveEvents.length - 1]?.getSender() === userId) {\n    return false;\n  }\n\n  for (let i = liveEvents.length - 1; i >= 0; i -= 1) {\n    const event = liveEvents[i];\n    if (!event) return false;\n    if (event.getId() === readUpToId) return false;\n    if (isNotificationEvent(event)) return true;\n  }\n  return true;\n};\n\nexport const getUnreadInfo = (room: Room): UnreadInfo => {\n  const total = room.getUnreadNotificationCount(NotificationCountType.Total);\n  const highlight = room.getUnreadNotificationCount(NotificationCountType.Highlight);\n  return {\n    roomId: room.roomId,\n    highlight,\n    total: highlight > total ? highlight : total,\n  };\n};\n\nexport const getUnreadInfos = (mx: MatrixClient): UnreadInfo[] => {\n  const unreadInfos = mx.getRooms().reduce<UnreadInfo[]>((unread, room) => {\n    if (room.isSpaceRoom()) return unread;\n    if (room.getMyMembership() !== 'join') return unread;\n    if (getNotificationType(mx, room.roomId) === NotificationType.Mute) return unread;\n\n    if (roomHaveNotification(room) || roomHaveUnread(mx, room)) {\n      unread.push(getUnreadInfo(room));\n    }\n\n    return unread;\n  }, []);\n  return unreadInfos;\n};\n\nexport const joinRuleToIconSrc = (\n  icons: Record<IconName, IconSrc>,\n  joinRule: JoinRule,\n  space: boolean\n): IconSrc | undefined => {\n  if (joinRule === JoinRule.Restricted) {\n    return space ? icons.Space : icons.Hash;\n  }\n  if (joinRule === JoinRule.Knock) {\n    return space ? icons.SpaceLock : icons.HashLock;\n  }\n  if (joinRule === JoinRule.Invite) {\n    return space ? icons.SpaceLock : icons.HashLock;\n  }\n  if (joinRule === JoinRule.Public) {\n    return space ? icons.SpaceGlobe : icons.HashGlobe;\n  }\n  return undefined;\n};\n\nexport const getRoomAvatarUrl = (\n  mx: MatrixClient,\n  room: Room,\n  size: 32 | 96 = 32,\n  useAuthentication = false\n): string | undefined => {\n  const mxcUrl = room.getMxcAvatarUrl();\n  return mxcUrl\n    ? mx.mxcUrlToHttp(mxcUrl, size, size, 'crop', undefined, false, useAuthentication) ?? undefined\n    : undefined;\n};\n\nexport const getDirectRoomAvatarUrl = (\n  mx: MatrixClient,\n  room: Room,\n  size: 32 | 96 = 32,\n  useAuthentication = false\n): string | undefined => {\n  const mxcUrl = room.getAvatarFallbackMember()?.getMxcAvatarUrl();\n  return mxcUrl\n    ? mx.mxcUrlToHttp(mxcUrl, size, size, 'crop', undefined, false, useAuthentication) ?? undefined\n    : undefined;\n};\n\nexport const trimReplyFromBody = (body: string): string => {\n  const match = body.match(/^> <.+?> .+\\n(>.*\\n)*?\\n/m);\n  if (!match) return body;\n  return body.slice(match[0].length);\n};\n\nexport const trimReplyFromFormattedBody = (formattedBody: string): string => {\n  const suffix = '</mx-reply>';\n  const i = formattedBody.lastIndexOf(suffix);\n  if (i < 0) {\n    return formattedBody;\n  }\n  return formattedBody.slice(i + suffix.length);\n};\n\nexport const parseReplyBody = (userId: string, body: string) =>\n  `> <${userId}> ${body.replace(/\\n/g, '\\n> ')}\\n\\n`;\n\nexport const parseReplyFormattedBody = (\n  roomId: string,\n  userId: string,\n  eventId: string,\n  formattedBody: string\n): string => {\n  const replyToLink = `<a href=\"https://matrix.to/#/${encodeURIComponent(\n    roomId\n  )}/${encodeURIComponent(eventId)}\">In reply to</a>`;\n  const userLink = `<a href=\"https://matrix.to/#/${encodeURIComponent(userId)}\">${userId}</a>`;\n\n  return `<mx-reply><blockquote>${replyToLink}${userLink}<br />${formattedBody}</blockquote></mx-reply>`;\n};\n\nexport const getMemberDisplayName = (room: Room, userId: string): string | undefined => {\n  const member = room.getMember(userId);\n  const name = member?.rawDisplayName;\n  if (name === userId) return undefined;\n  return name;\n};\n\nexport const getMemberSearchStr = (\n  member: RoomMember,\n  query: string,\n  mxIdToName: (mxId: string) => string\n): string[] => [\n  member.rawDisplayName === member.userId ? mxIdToName(member.userId) : member.rawDisplayName,\n  query.startsWith('@') || query.indexOf(':') > -1 ? member.userId : mxIdToName(member.userId),\n];\n\nexport const getMemberAvatarMxc = (room: Room, userId: string): string | undefined => {\n  const member = room.getMember(userId);\n  return member?.getMxcAvatarUrl();\n};\n\nexport const isMembershipChanged = (mEvent: MatrixEvent): boolean =>\n  mEvent.getContent().membership !== mEvent.getPrevContent().membership ||\n  mEvent.getContent().reason !== mEvent.getPrevContent().reason;\n\nexport const decryptAllTimelineEvent = async (mx: MatrixClient, timeline: EventTimeline) => {\n  const crypto = mx.getCrypto();\n  if (!crypto) return;\n  const decryptionPromises = timeline\n    .getEvents()\n    .filter((event) => event.isEncrypted())\n    .reverse()\n    .map((event) => event.attemptDecryption(crypto as CryptoBackend, { isRetry: true }));\n  await Promise.allSettled(decryptionPromises);\n};\n\nexport const getReactionContent = (eventId: string, key: string, shortcode?: string) => ({\n  'm.relates_to': {\n    event_id: eventId,\n    key,\n    rel_type: 'm.annotation',\n  },\n  shortcode,\n});\n\nexport const getEventReactions = (timelineSet: EventTimelineSet, eventId: string) =>\n  timelineSet.relations.getChildEventsForEvent(\n    eventId,\n    RelationType.Annotation,\n    EventType.Reaction\n  );\n\nexport const getEventEdits = (timelineSet: EventTimelineSet, eventId: string, eventType: string) =>\n  timelineSet.relations.getChildEventsForEvent(eventId, RelationType.Replace, eventType);\n\nexport const getLatestEdit = (\n  targetEvent: MatrixEvent,\n  editEvents: MatrixEvent[]\n): MatrixEvent | undefined => {\n  const eventByTargetSender = (rEvent: MatrixEvent) =>\n    rEvent.getSender() === targetEvent.getSender();\n  return editEvents.sort((m1, m2) => m2.getTs() - m1.getTs()).find(eventByTargetSender);\n};\n\nexport const getEditedEvent = (\n  mEventId: string,\n  mEvent: MatrixEvent,\n  timelineSet: EventTimelineSet\n): MatrixEvent | undefined => {\n  const edits = getEventEdits(timelineSet, mEventId, mEvent.getType());\n  return edits && getLatestEdit(mEvent, edits.getRelations());\n};\n\nexport const canEditEvent = (mx: MatrixClient, mEvent: MatrixEvent) => {\n  const content = mEvent.getContent();\n  const relationType = content['m.relates_to']?.rel_type;\n  return (\n    mEvent.getSender() === mx.getUserId() &&\n    (!relationType || relationType === RelationType.Thread) &&\n    mEvent.getType() === MessageEvent.RoomMessage &&\n    (content.msgtype === MsgType.Text ||\n      content.msgtype === MsgType.Emote ||\n      content.msgtype === MsgType.Notice)\n  );\n};\n\nexport const getLatestEditableEvt = (\n  timeline: EventTimeline,\n  canEdit: (mEvent: MatrixEvent) => boolean\n): MatrixEvent | undefined => {\n  const events = timeline.getEvents();\n\n  for (let i = events.length - 1; i >= 0; i -= 1) {\n    const evt = events[i];\n    if (canEdit(evt)) return evt;\n  }\n  return undefined;\n};\n\nexport const reactionOrEditEvent = (mEvent: MatrixEvent) =>\n  mEvent.getRelation()?.rel_type === RelationType.Annotation ||\n  mEvent.getRelation()?.rel_type === RelationType.Replace;\n","import {\n  EncryptedAttachmentInfo,\n  decryptAttachment,\n  encryptAttachment,\n} from 'browser-encrypt-attachment';\nimport {\n  MatrixClient,\n  MatrixError,\n  MatrixEvent,\n  Room,\n  RoomMember,\n  UploadProgress,\n  UploadResponse,\n} from 'matrix-js-sdk';\nimport { IImageInfo, IThumbnailContent, IVideoInfo } from '../../types/matrix/common';\nimport { AccountDataEvent } from '../../types/matrix/accountData';\nimport { getStateEvent } from './room';\nimport { StateEvent } from '../../types/matrix/room';\n\nexport const matchMxId = (id: string): RegExpMatchArray | null =>\n  id.match(/^([@!$+#])(\\S+):(\\S+)$/);\n\nexport const validMxId = (id: string): boolean => !!matchMxId(id);\n\nexport const getMxIdServer = (userId: string): string | undefined => matchMxId(userId)?.[3];\n\nexport const getMxIdLocalPart = (userId: string): string | undefined => matchMxId(userId)?.[2];\n\nexport const isUserId = (id: string): boolean => validMxId(id) && id.startsWith('@');\n\nexport const isRoomId = (id: string): boolean => validMxId(id) && id.startsWith('!');\n\nexport const isRoomAlias = (id: string): boolean => validMxId(id) && id.startsWith('#');\n\nexport const getCanonicalAliasRoomId = (mx: MatrixClient, alias: string): string | undefined =>\n  mx\n    .getRooms()\n    ?.find(\n      (room) =>\n        room.getCanonicalAlias() === alias &&\n        getStateEvent(room, StateEvent.RoomTombstone) === undefined\n    )?.roomId;\n\nexport const getCanonicalAliasOrRoomId = (mx: MatrixClient, roomId: string): string => {\n  const room = mx.getRoom(roomId);\n  if (!room) return roomId;\n  if (getStateEvent(room, StateEvent.RoomTombstone) !== undefined) return roomId;\n  return room.getCanonicalAlias() || roomId;\n};\n\nexport const getImageInfo = (img: HTMLImageElement, fileOrBlob: File | Blob): IImageInfo => {\n  const info: IImageInfo = {};\n  info.w = img.width;\n  info.h = img.height;\n  info.mimetype = fileOrBlob.type;\n  info.size = fileOrBlob.size;\n  return info;\n};\n\nexport const getVideoInfo = (video: HTMLVideoElement, fileOrBlob: File | Blob): IVideoInfo => {\n  const info: IVideoInfo = {};\n  info.duration = Number.isNaN(video.duration) ? undefined : Math.floor(video.duration * 1000);\n  info.w = video.videoWidth;\n  info.h = video.videoHeight;\n  info.mimetype = fileOrBlob.type;\n  info.size = fileOrBlob.size;\n  return info;\n};\n\nexport const getThumbnailContent = (thumbnailInfo: {\n  thumbnail: File | Blob;\n  encInfo: EncryptedAttachmentInfo | undefined;\n  mxc: string;\n  width: number;\n  height: number;\n}): IThumbnailContent => {\n  const { thumbnail, encInfo, mxc, width, height } = thumbnailInfo;\n\n  const content: IThumbnailContent = {\n    thumbnail_info: {\n      mimetype: thumbnail.type,\n      size: thumbnail.size,\n      w: width,\n      h: height,\n    },\n  };\n  if (encInfo) {\n    content.thumbnail_file = {\n      ...encInfo,\n      url: mxc,\n    };\n  } else {\n    content.thumbnail_url = mxc;\n  }\n  return content;\n};\n\nexport const encryptFile = async (\n  file: File | Blob\n): Promise<{\n  encInfo: EncryptedAttachmentInfo;\n  file: File;\n  originalFile: File | Blob;\n}> => {\n  const dataBuffer = await file.arrayBuffer();\n  const encryptedAttachment = await encryptAttachment(dataBuffer);\n  const encFile = new File([encryptedAttachment.data], file.name, {\n    type: file.type,\n  });\n  return {\n    encInfo: encryptedAttachment.info,\n    file: encFile,\n    originalFile: file,\n  };\n};\n\nexport const decryptFile = async (\n  dataBuffer: ArrayBuffer,\n  type: string,\n  encInfo: EncryptedAttachmentInfo\n): Promise<Blob> => {\n  const dataArray = await decryptAttachment(dataBuffer, encInfo);\n  const blob = new Blob([dataArray], { type });\n  return blob;\n};\n\nexport type TUploadContent = File | Blob;\n\nexport type ContentUploadOptions = {\n  name?: string;\n  fileType?: string;\n  hideFilename?: boolean;\n  onPromise?: (promise: Promise<UploadResponse>) => void;\n  onProgress?: (progress: UploadProgress) => void;\n  onSuccess: (mxc: string) => void;\n  onError: (error: MatrixError) => void;\n};\n\nexport const uploadContent = async (\n  mx: MatrixClient,\n  file: TUploadContent,\n  options: ContentUploadOptions\n) => {\n  const { name, fileType, hideFilename, onProgress, onPromise, onSuccess, onError } = options;\n\n  const uploadPromise = mx.uploadContent(file, {\n    name,\n    type: fileType,\n    includeFilename: !hideFilename,\n    progressHandler: onProgress,\n  });\n  onPromise?.(uploadPromise);\n  try {\n    const data = await uploadPromise;\n    const mxc = data.content_uri;\n    if (mxc) onSuccess(mxc);\n    else onError(new MatrixError(data));\n  } catch (e: any) {\n    const error = typeof e?.message === 'string' ? e.message : undefined;\n    const errcode = typeof e?.name === 'string' ? e.message : undefined;\n    onError(new MatrixError({ error, errcode }));\n  }\n};\n\nexport const matrixEventByRecency = (m1: MatrixEvent, m2: MatrixEvent) => m2.getTs() - m1.getTs();\n\nexport const factoryEventSentBy = (senderId: string) => (ev: MatrixEvent) =>\n  ev.getSender() === senderId;\n\nexport const eventWithShortcode = (ev: MatrixEvent) =>\n  typeof ev.getContent().shortcode === 'string';\n\nexport const getDMRoomFor = (mx: MatrixClient, userId: string): Room | undefined => {\n  const dmLikeRooms = mx\n    .getRooms()\n    .filter((room) => mx.isRoomEncrypted(room.roomId) && room.getMembers().length <= 2);\n\n  return dmLikeRooms.find((room) => room.getMember(userId));\n};\n\nexport const guessDmRoomUserId = (room: Room, myUserId: string): string => {\n  const getOldestMember = (members: RoomMember[]): RoomMember | undefined => {\n    let oldestMemberTs: number | undefined;\n    let oldestMember: RoomMember | undefined;\n\n    const pickOldestMember = (member: RoomMember) => {\n      if (member.userId === myUserId) return;\n\n      if (\n        oldestMemberTs === undefined ||\n        (member.events.member && member.events.member.getTs() < oldestMemberTs)\n      ) {\n        oldestMember = member;\n        oldestMemberTs = member.events.member?.getTs();\n      }\n    };\n\n    members.forEach(pickOldestMember);\n\n    return oldestMember;\n  };\n\n  // Pick the joined user who's been here longest (and isn't us),\n  const member = getOldestMember(room.getJoinedMembers());\n  if (member) return member.userId;\n\n  // if there are no joined members other than us, use the oldest member\n  const member1 = getOldestMember(room.currentState.getMembers());\n  return member1?.userId ?? myUserId;\n};\n\nexport const addRoomIdToMDirect = async (\n  mx: MatrixClient,\n  roomId: string,\n  userId: string\n): Promise<void> => {\n  const mDirectsEvent = mx.getAccountData(AccountDataEvent.Direct);\n  const userIdToRoomIds: Record<string, string[]> = mDirectsEvent?.getContent() ?? {};\n\n  // remove it from the lists of any others users\n  // (it can only be a DM room for one person)\n  Object.keys(userIdToRoomIds).forEach((targetUserId) => {\n    const roomIds = userIdToRoomIds[targetUserId];\n\n    if (targetUserId !== userId) {\n      const indexOfRoomId = roomIds.indexOf(roomId);\n      if (indexOfRoomId > -1) {\n        roomIds.splice(indexOfRoomId, 1);\n      }\n    }\n  });\n\n  const roomIds = userIdToRoomIds[userId] || [];\n  if (roomIds.indexOf(roomId) === -1) {\n    roomIds.push(roomId);\n  }\n  userIdToRoomIds[userId] = roomIds;\n\n  await mx.setAccountData(AccountDataEvent.Direct, userIdToRoomIds);\n};\n\nexport const removeRoomIdFromMDirect = async (mx: MatrixClient, roomId: string): Promise<void> => {\n  const mDirectsEvent = mx.getAccountData(AccountDataEvent.Direct);\n  const userIdToRoomIds: Record<string, string[]> = mDirectsEvent?.getContent() ?? {};\n\n  Object.keys(userIdToRoomIds).forEach((targetUserId) => {\n    const roomIds = userIdToRoomIds[targetUserId];\n    const indexOfRoomId = roomIds.indexOf(roomId);\n    if (indexOfRoomId > -1) {\n      roomIds.splice(indexOfRoomId, 1);\n    }\n  });\n\n  await mx.setAccountData(AccountDataEvent.Direct, userIdToRoomIds);\n};\n\nexport const mxcUrlToHttp = (\n  mx: MatrixClient,\n  mxcUrl: string,\n  useAuthentication?: boolean,\n  width?: number,\n  height?: number,\n  resizeMethod?: string,\n  allowDirectLinks?: boolean,\n  allowRedirects?: boolean\n): string | null =>\n  mx.mxcUrlToHttp(\n    mxcUrl,\n    width,\n    height,\n    resizeMethod,\n    allowDirectLinks,\n    allowRedirects,\n    useAuthentication\n  );\n\nexport const downloadMedia = async (src: string): Promise<Blob> => {\n  // this request is authenticated by service worker\n  const res = await fetch(src, { method: 'GET' });\n  const blob = await res.blob();\n  return blob;\n};\n\nexport const downloadEncryptedMedia = async (\n  src: string,\n  decryptContent: (buf: ArrayBuffer) => Promise<Blob>\n): Promise<Blob> => {\n  const encryptedContent = await downloadMedia(src);\n  const decryptedContent = await decryptContent(await encryptedContent.arrayBuffer());\n\n  return decryptedContent;\n};\n","export const HTTP_URL_PATTERN = `https?:\\\\/\\\\/(?:www\\\\.)?(?:[^\\\\s)]*)(?<![.,:;!/?()[\\\\]\\\\s]+)`;\n\nexport const URL_REG = new RegExp(HTTP_URL_PATTERN, 'g');\n\nexport const EMAIL_REGEX =\n  /^(([^<>()[\\]\\\\.,;:\\s@\\\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\\\"]+)*)|(\\\\\".+\\\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\nexport const URL_NEG_LB = '(?<!(https?|ftp|mailto|magnet):\\\\/\\\\/\\\\S*)';\n\n// https://en.wikipedia.org/wiki/Variation_Selectors_(Unicode_block)\nexport const VARIATION_SELECTOR_PATTERN = '[\\uFE00-\\uFE0F]';\n\n// https://github.com/mathiasbynens/emoji-regex\nexport const EMOJI_PATTERN = `[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26D3\\uFE0F?(?:\\u200D\\uD83D\\uDCA5)?|\\u26F9(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF43\\uDF45-\\uDF4A\\uDF4C-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDF44(?:\\u200D\\uD83D\\uDFEB)?|\\uDF4B(?:\\u200D\\uD83D\\uDFE9)?|\\uDFC3(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4\\uDEB5](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE41\\uDE43\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC08(?:\\u200D\\u2B1B)?|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC26(?:\\u200D(?:\\u2B1B|\\uD83D\\uDD25))?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC6F(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDD75(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?|\\uDE42(?:\\u200D[\\u2194\\u2195]\\uFE0F?)?|\\uDEB6(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE88\\uDE90-\\uDEBD\\uDEBF-\\uDEC2\\uDECE-\\uDEDB\\uDEE0-\\uDEE8]|\\uDD3C(?:\\u200D[\\u2640\\u2642]\\uFE0F?|\\uD83C[\\uDFFB-\\uDFFF])?|\\uDDCE(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1|\\uDDD1\\u200D\\uD83E\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?|\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)`;\n\n// Thumbs up emoji found to have Variation Selector 16 at the end\n// so included variation selector pattern in regex\nexport const JUMBO_EMOJI_REG = new RegExp(\n  `^(((${EMOJI_PATTERN})|(:.+?:))(${VARIATION_SELECTOR_PATTERN}|\\\\s)*){1,10}$`\n);\n","import cons from '../state/cons';\n\nexport function updateLocalStore(\n  accessToken: string,\n  deviceId: string,\n  userId: string,\n  baseUrl: string\n) {\n  localStorage.setItem(cons.secretKey.ACCESS_TOKEN, accessToken);\n  localStorage.setItem(cons.secretKey.DEVICE_ID, deviceId);\n  localStorage.setItem(cons.secretKey.USER_ID, userId);\n  localStorage.setItem(cons.secretKey.BASE_URL, baseUrl);\n}\n","export enum ErrorCode {\n  M_FORBIDDEN = 'M_FORBIDDEN',\n  M_UNKNOWN_TOKEN = 'M_UNKNOWN_TOKEN',\n  M_MISSING_TOKEN = 'M_MISSING_TOKEN',\n  M_BAD_JSON = 'M_BAD_JSON',\n  M_NOT_JSON = 'M_NOT_JSON',\n  M_NOT_FOUND = 'M_NOT_FOUND',\n  M_LIMIT_EXCEEDED = 'M_LIMIT_EXCEEDED',\n  M_UNRECOGNIZED = 'M_UNRECOGNIZED',\n  M_UNKNOWN = 'M_UNKNOWN',\n\n  M_UNAUTHORIZED = 'M_UNAUTHORIZED',\n  M_USER_DEACTIVATED = 'M_USER_DEACTIVATED',\n  M_USER_IN_USE = 'M_USER_IN_USE',\n  M_INVALID_USERNAME = 'M_INVALID_USERNAME',\n  M_WEAK_PASSWORD = 'M_WEAK_PASSWORD',\n  M_PASSWORD_TOO_SHORT = 'M_PASSWORD_TOO_SHORT',\n  M_ROOM_IN_USE = 'M_ROOM_IN_USE',\n  M_INVALID_ROOM_STATE = 'M_INVALID_ROOM_STATE',\n  M_THREEPID_IN_USE = 'M_THREEPID_IN_USE',\n  M_THREEPID_NOT_FOUND = 'M_THREEPID_NOT_FOUND',\n  M_THREEPID_AUTH_FAILED = 'M_THREEPID_AUTH_FAILED',\n  M_THREEPID_DENIED = 'M_THREEPID_DENIED',\n  M_SERVER_NOT_TRUSTED = 'M_SERVER_NOT_TRUSTED',\n  M_UNSUPPORTED_ROOM_VERSION = 'M_UNSUPPORTED_ROOM_VERSION',\n  M_INCOMPATIBLE_ROOM_VERSION = 'M_INCOMPATIBLE_ROOM_VERSION',\n  M_BAD_STATE = 'M_BAD_STATE',\n  M_GUEST_ACCESS_FORBIDDEN = 'M_GUEST_ACCESS_FORBIDDEN',\n  M_CAPTCHA_NEEDED = 'M_CAPTCHA_NEEDED',\n  M_CAPTCHA_INVALID = 'M_CAPTCHA_INVALID',\n  M_MISSING_PARAM = 'M_MISSING_PARAM',\n  M_INVALID_PARAM = 'M_INVALID_PARAM',\n  M_TOO_LARGE = 'M_TOO_LARGE',\n  M_EXCLUSIVE = 'M_EXCLUSIVE',\n  M_RESOURCE_LIMIT_EXCEEDED = 'M_RESOURCE_LIMIT_EXCEEDED',\n  M_CANNOT_LEAVE_SERVER_NOTICE_ROOM = 'M_CANNOT_LEAVE_SERVER_NOTICE_ROOM',\n}\n","const AFTER_LOGIN_REDIRECT_PATH_KEY = 'after_login_redirect_url';\n\nexport const setAfterLoginRedirectPath = (url: string): void => {\n  localStorage.setItem(AFTER_LOGIN_REDIRECT_PATH_KEY, url);\n};\nexport const getAfterLoginRedirectPath = (): string | undefined => {\n  const url = localStorage.getItem(AFTER_LOGIN_REDIRECT_PATH_KEY);\n  return url ?? undefined;\n};\nexport const deleteAfterLoginRedirectPath = (): void => {\n  localStorage.removeItem(AFTER_LOGIN_REDIRECT_PATH_KEY);\n};\n","import { generatePath, Path } from 'react-router-dom';\nimport {\n  DIRECT_CREATE_PATH,\n  DIRECT_PATH,\n  DIRECT_ROOM_PATH,\n  EXPLORE_FEATURED_PATH,\n  EXPLORE_PATH,\n  EXPLORE_SERVER_PATH,\n  HOME_CREATE_PATH,\n  HOME_JOIN_PATH,\n  HOME_PATH,\n  HOME_ROOM_PATH,\n  HOME_SEARCH_PATH,\n  LOGIN_PATH,\n  INBOX_INVITES_PATH,\n  INBOX_NOTIFICATIONS_PATH,\n  INBOX_PATH,\n  REGISTER_PATH,\n  RESET_PASSWORD_PATH,\n  ROOT_PATH,\n  SPACE_LOBBY_PATH,\n  SPACE_PATH,\n  SPACE_ROOM_PATH,\n  SPACE_SEARCH_PATH,\n} from './paths';\nimport { trimLeadingSlash, trimTrailingSlash } from '../utils/common';\nimport { HashRouterConfig } from '../hooks/useClientConfig';\n\nexport const joinPathComponent = (path: Path): string => path.pathname + path.search + path.hash;\n\nexport const withSearchParam = <T extends Record<string, string>>(\n  path: string,\n  searchParam: T\n): string => {\n  const params = new URLSearchParams(searchParam);\n\n  return `${path}?${params}`;\n};\nexport const encodeSearchParamValueArray = (ids: string[]): string => ids.join(',');\nexport const decodeSearchParamValueArray = (idsParam: string): string[] => idsParam.split(',');\n\nexport const getOriginBaseUrl = (hashRouterConfig?: HashRouterConfig): string => {\n  const baseUrl = `${trimTrailingSlash(window.location.origin)}${import.meta.env.BASE_URL}`;\n\n  if (hashRouterConfig?.enabled) {\n    return `${trimTrailingSlash(baseUrl)}/#${hashRouterConfig.basename}`;\n  }\n\n  return baseUrl;\n};\n\nexport const withOriginBaseUrl = (baseUrl: string, path: string): string =>\n  `${trimTrailingSlash(baseUrl)}${path}`;\n\nexport const getAppPathFromHref = (baseUrl: string, href: string): string => {\n  // if hash is in baseUrl means we are using hashRouter\n  const baseHashIndex = baseUrl.indexOf('#');\n  if (baseHashIndex > -1) {\n    const hrefHashIndex = href.indexOf('#');\n    // href may/not have \"/\" around \"#\"\n    // we need to take care of this when extracting app path\n    const trimmedBaseUrl = trimLeadingSlash(baseUrl.slice(baseHashIndex + 1));\n    const trimmedHref = trimLeadingSlash(href.slice(hrefHashIndex + 1));\n\n    const appPath = trimmedHref.slice(trimmedBaseUrl.length);\n    return `/${trimLeadingSlash(appPath)}`;\n  }\n\n  return href.slice(trimTrailingSlash(baseUrl).length);\n};\n\nexport const getRootPath = (): string => ROOT_PATH;\n\nexport const getLoginPath = (server?: string): string => {\n  const params = server ? { server: encodeURIComponent(server) } : undefined;\n  return generatePath(LOGIN_PATH, params);\n};\n\nexport const getRegisterPath = (server?: string): string => {\n  const params = server ? { server: encodeURIComponent(server) } : undefined;\n  return generatePath(REGISTER_PATH, params);\n};\n\nexport const getResetPasswordPath = (server?: string): string => {\n  const params = server ? { server: encodeURIComponent(server) } : undefined;\n  return generatePath(RESET_PASSWORD_PATH, params);\n};\n\nexport const getHomePath = (): string => HOME_PATH;\nexport const getHomeCreatePath = (): string => HOME_CREATE_PATH;\nexport const getHomeJoinPath = (): string => HOME_JOIN_PATH;\nexport const getHomeSearchPath = (): string => HOME_SEARCH_PATH;\nexport const getHomeRoomPath = (roomIdOrAlias: string, eventId?: string): string => {\n  const params = {\n    roomIdOrAlias: encodeURIComponent(roomIdOrAlias),\n    eventId: eventId ? encodeURIComponent(eventId) : null,\n  };\n\n  return generatePath(HOME_ROOM_PATH, params);\n};\n\nexport const getDirectPath = (): string => DIRECT_PATH;\nexport const getDirectCreatePath = (): string => DIRECT_CREATE_PATH;\nexport const getDirectRoomPath = (roomIdOrAlias: string, eventId?: string): string => {\n  const params = {\n    roomIdOrAlias: encodeURIComponent(roomIdOrAlias),\n    eventId: eventId ? encodeURIComponent(eventId) : null,\n  };\n\n  return generatePath(DIRECT_ROOM_PATH, params);\n};\n\nexport const getSpacePath = (spaceIdOrAlias: string): string => {\n  const params = {\n    spaceIdOrAlias: encodeURIComponent(spaceIdOrAlias),\n  };\n\n  return generatePath(SPACE_PATH, params);\n};\nexport const getSpaceLobbyPath = (spaceIdOrAlias: string): string => {\n  const params = {\n    spaceIdOrAlias: encodeURIComponent(spaceIdOrAlias),\n  };\n  return generatePath(SPACE_LOBBY_PATH, params);\n};\nexport const getSpaceSearchPath = (spaceIdOrAlias: string): string => {\n  const params = {\n    spaceIdOrAlias: encodeURIComponent(spaceIdOrAlias),\n  };\n  return generatePath(SPACE_SEARCH_PATH, params);\n};\nexport const getSpaceRoomPath = (\n  spaceIdOrAlias: string,\n  roomIdOrAlias: string,\n  eventId?: string\n): string => {\n  const params = {\n    spaceIdOrAlias: encodeURIComponent(spaceIdOrAlias),\n    roomIdOrAlias: encodeURIComponent(roomIdOrAlias),\n    eventId: eventId ? encodeURIComponent(eventId) : null,\n  };\n\n  return generatePath(SPACE_ROOM_PATH, params);\n};\n\nexport const getExplorePath = (): string => EXPLORE_PATH;\nexport const getExploreFeaturedPath = (): string => EXPLORE_FEATURED_PATH;\nexport const getExploreServerPath = (server: string): string => {\n  const params = {\n    server: encodeURIComponent(server),\n  };\n  return generatePath(EXPLORE_SERVER_PATH, params);\n};\n\nexport const getInboxPath = (): string => INBOX_PATH;\nexport const getInboxNotificationsPath = (): string => INBOX_NOTIFICATIONS_PATH;\nexport const getInboxInvitesPath = (): string => INBOX_INVITES_PATH;\n","import to from 'await-to-js';\nimport { LoginRequest, LoginResponse, MatrixError, createClient } from 'matrix-js-sdk';\nimport { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { ClientConfig, clientAllowedServer } from '../../../hooks/useClientConfig';\nimport { autoDiscovery, specVersions } from '../../../cs-api';\nimport { updateLocalStore } from '../../../../client/action/auth';\nimport { ErrorCode } from '../../../cs-errorcode';\nimport {\n  deleteAfterLoginRedirectPath,\n  getAfterLoginRedirectPath,\n} from '../../afterLoginRedirectPath';\nimport { getHomePath } from '../../pathUtils';\n\nexport enum GetBaseUrlError {\n  NotAllow = 'NotAllow',\n  NotFound = 'NotFound',\n}\nexport const factoryGetBaseUrl = (clientConfig: ClientConfig, server: string) => {\n  const getBaseUrl = async (): Promise<string> => {\n    if (!clientAllowedServer(clientConfig, server)) {\n      throw new Error(GetBaseUrlError.NotAllow);\n    }\n\n    const [, discovery] = await to(autoDiscovery(fetch, server));\n\n    let mxIdBaseUrl: string | undefined;\n    const [, discoveryInfo] = discovery ?? [];\n\n    if (discoveryInfo) {\n      mxIdBaseUrl = discoveryInfo['m.homeserver'].base_url;\n    }\n\n    if (!mxIdBaseUrl) {\n      throw new Error(GetBaseUrlError.NotFound);\n    }\n    const [, versions] = await to(specVersions(fetch, mxIdBaseUrl));\n    if (!versions) {\n      throw new Error(GetBaseUrlError.NotFound);\n    }\n    return mxIdBaseUrl;\n  };\n  return getBaseUrl;\n};\n\nexport enum LoginError {\n  ServerNotAllowed = 'ServerNotAllowed',\n  InvalidServer = 'InvalidServer',\n  Forbidden = 'Forbidden',\n  UserDeactivated = 'UserDeactivated',\n  InvalidRequest = 'InvalidRequest',\n  RateLimited = 'RateLimited',\n  Unknown = 'Unknown',\n}\n\nexport type CustomLoginResponse = {\n  baseUrl: string;\n  response: LoginResponse;\n};\nexport const login = async (\n  serverBaseUrl: string | (() => Promise<string>),\n  data: LoginRequest\n): Promise<CustomLoginResponse> => {\n  const [urlError, url] =\n    typeof serverBaseUrl === 'function' ? await to(serverBaseUrl()) : [undefined, serverBaseUrl];\n  if (urlError) {\n    throw new MatrixError({\n      errcode:\n        urlError.message === GetBaseUrlError.NotAllow\n          ? LoginError.ServerNotAllowed\n          : LoginError.InvalidServer,\n    });\n  }\n\n  const mx = createClient({ baseUrl: url });\n  const [err, res] = await to<LoginResponse, MatrixError>(mx.login(data.type, data));\n\n  if (err) {\n    if (err.httpStatus === 400) {\n      throw new MatrixError({\n        errcode: LoginError.InvalidRequest,\n      });\n    }\n    if (err.httpStatus === 429) {\n      throw new MatrixError({\n        errcode: LoginError.RateLimited,\n      });\n    }\n    if (err.errcode === ErrorCode.M_USER_DEACTIVATED) {\n      throw new MatrixError({\n        errcode: LoginError.UserDeactivated,\n      });\n    }\n\n    if (err.httpStatus === 403) {\n      throw new MatrixError({\n        errcode: LoginError.Forbidden,\n      });\n    }\n\n    throw new MatrixError({\n      errcode: LoginError.Unknown,\n    });\n  }\n  return {\n    baseUrl: url,\n    response: res,\n  };\n};\n\nexport const useLoginComplete = (data?: CustomLoginResponse) => {\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    if (data) {\n      const { response: loginRes, baseUrl: loginBaseUrl } = data;\n      updateLocalStore(loginRes.access_token, loginRes.device_id, loginRes.user_id, loginBaseUrl);\n      const afterLoginRedirectUrl = getAfterLoginRedirectPath();\n      deleteAfterLoginRedirectPath();\n      navigate(afterLoginRedirectUrl ?? getHomePath(), { replace: true });\n    }\n  }, [data, navigate]);\n};\n","import { Dispatch, ReactElement, SetStateAction, useState } from 'react';\n\ntype UseStateProviderProps<T> = {\n  initial: T | (() => T);\n  children: (value: T, setter: Dispatch<SetStateAction<T>>) => ReactElement;\n};\nexport function UseStateProvider<T>({ initial, children }: UseStateProviderProps<T>) {\n  return children(...useState(initial));\n}\n","import React, { ComponentProps, forwardRef } from 'react';\nimport { Icon, IconButton, Input, config, Icons } from 'folds';\nimport { UseStateProvider } from '../UseStateProvider';\n\ntype PasswordInputProps = Omit<ComponentProps<typeof Input>, 'type' | 'size'> & {\n  size: '400' | '500';\n};\nexport const PasswordInput = forwardRef<HTMLInputElement, PasswordInputProps>(\n  ({ variant, size, style, after, ...props }, ref) => {\n    const paddingRight: string = size === '500' ? config.space.S300 : config.space.S200;\n\n    return (\n      <UseStateProvider initial={false}>\n        {(visible, setVisible) => (\n          <Input\n            {...props}\n            ref={ref}\n            style={{ paddingRight, ...style }}\n            type={visible ? 'text' : 'password'}\n            size={size}\n            variant={variant}\n            after={\n              <>\n                {after}\n                <IconButton\n                  onClick={() => setVisible(!visible)}\n                  type=\"button\"\n                  variant={visible ? 'Warning' : variant}\n                  size=\"300\"\n                  radii=\"300\"\n                >\n                  <Icon\n                    style={{ opacity: config.opacity.P300 }}\n                    size=\"100\"\n                    src={visible ? Icons.Eye : Icons.EyeBlind}\n                  />\n                </IconButton>\n              </>\n            }\n          />\n        )}\n      </UseStateProvider>\n    );\n  }\n);\n","import React from 'react';\nimport { Box, Icon, Icons, color, Text } from 'folds';\n\nexport function FieldError({ message }: { message: string }) {\n  return (\n    <Box style={{ color: color.Critical.Main }} alignItems=\"Center\" gap=\"100\">\n      <Icon size=\"50\" filled src={Icons.Warning} />\n      <Text size=\"T200\">\n        <b>{message}</b>\n      </Text>\n    </Box>\n  );\n}\n","import React, { FormEventHandler, MouseEventHandler, useCallback, useState } from 'react';\nimport {\n  Box,\n  Button,\n  Header,\n  Icon,\n  IconButton,\n  Icons,\n  Input,\n  Menu,\n  Overlay,\n  OverlayBackdrop,\n  OverlayCenter,\n  PopOut,\n  RectCords,\n  Spinner,\n  Text,\n  config,\n} from 'folds';\nimport FocusTrap from 'focus-trap-react';\nimport { Link } from 'react-router-dom';\nimport { MatrixError } from 'matrix-js-sdk';\nimport { getMxIdLocalPart, getMxIdServer, isUserId } from '../../../utils/matrix';\nimport { EMAIL_REGEX } from '../../../utils/regex';\nimport { useAutoDiscoveryInfo } from '../../../hooks/useAutoDiscoveryInfo';\nimport { AsyncStatus, useAsyncCallback } from '../../../hooks/useAsyncCallback';\nimport { useAuthServer } from '../../../hooks/useAuthServer';\nimport { useClientConfig } from '../../../hooks/useClientConfig';\nimport {\n  CustomLoginResponse,\n  LoginError,\n  factoryGetBaseUrl,\n  login,\n  useLoginComplete,\n} from './loginUtil';\nimport { PasswordInput } from '../../../components/password-input/PasswordInput';\nimport { FieldError } from '../FiledError';\nimport { getResetPasswordPath } from '../../pathUtils';\nimport { stopPropagation } from '../../../utils/keyboard';\n\nfunction UsernameHint({ server }: { server: string }) {\n  const [anchor, setAnchor] = useState<RectCords>();\n\n  const handleOpenMenu: MouseEventHandler<HTMLElement> = (evt) => {\n    setAnchor(evt.currentTarget.getBoundingClientRect());\n  };\n  return (\n    <PopOut\n      anchor={anchor}\n      position=\"Top\"\n      align=\"End\"\n      content={\n        <FocusTrap\n          focusTrapOptions={{\n            initialFocus: false,\n            onDeactivate: () => setAnchor(undefined),\n            clickOutsideDeactivates: true,\n            escapeDeactivates: stopPropagation,\n          }}\n        >\n          <Menu>\n            <Header size=\"300\" style={{ padding: `0 ${config.space.S200}` }}>\n              <Text size=\"L400\">Hint</Text>\n            </Header>\n            <Box\n              style={{ padding: config.space.S200, paddingTop: 0 }}\n              direction=\"Column\"\n              tabIndex={0}\n              gap=\"100\"\n            >\n              <Text size=\"T300\">\n                <Text as=\"span\" size=\"Inherit\" priority=\"300\">\n                  Username:\n                </Text>{' '}\n                johndoe\n              </Text>\n              <Text size=\"T300\">\n                <Text as=\"span\" size=\"Inherit\" priority=\"300\">\n                  Matrix ID:\n                </Text>\n                {` @johndoe:${server}`}\n              </Text>\n              <Text size=\"T300\">\n                <Text as=\"span\" size=\"Inherit\" priority=\"300\">\n                  Email:\n                </Text>\n                {` johndoe@${server}`}\n              </Text>\n            </Box>\n          </Menu>\n        </FocusTrap>\n      }\n    >\n      <IconButton\n        tabIndex={-1}\n        onClick={handleOpenMenu}\n        type=\"button\"\n        variant=\"Background\"\n        size=\"300\"\n        radii=\"300\"\n        aria-pressed={!!anchor}\n      >\n        <Icon style={{ opacity: config.opacity.P300 }} size=\"100\" src={Icons.Info} />\n      </IconButton>\n    </PopOut>\n  );\n}\n\ntype PasswordLoginFormProps = {\n  defaultUsername?: string;\n  defaultEmail?: string;\n};\nexport function PasswordLoginForm({ defaultUsername, defaultEmail }: PasswordLoginFormProps) {\n  const server = useAuthServer();\n  const clientConfig = useClientConfig();\n\n  const serverDiscovery = useAutoDiscoveryInfo();\n  const baseUrl = serverDiscovery['m.homeserver'].base_url;\n\n  const [loginState, startLogin] = useAsyncCallback<\n    CustomLoginResponse,\n    MatrixError,\n    Parameters<typeof login>\n  >(useCallback(login, []));\n\n  useLoginComplete(loginState.status === AsyncStatus.Success ? loginState.data : undefined);\n\n  const handleUsernameLogin = (username: string, password: string) => {\n    startLogin(baseUrl, {\n      type: 'm.login.password',\n      identifier: {\n        type: 'm.id.user',\n        user: username,\n      },\n      password,\n      initial_device_display_name: 'Cinny Web',\n    });\n  };\n\n  const handleMxIdLogin = async (mxId: string, password: string) => {\n    const mxIdServer = getMxIdServer(mxId);\n    const mxIdUsername = getMxIdLocalPart(mxId);\n    if (!mxIdServer || !mxIdUsername) return;\n\n    const getBaseUrl = factoryGetBaseUrl(clientConfig, mxIdServer);\n\n    startLogin(getBaseUrl, {\n      type: 'm.login.password',\n      identifier: {\n        type: 'm.id.user',\n        user: mxIdUsername,\n      },\n      password,\n      initial_device_display_name: 'Cinny Web',\n    });\n  };\n  const handleEmailLogin = (email: string, password: string) => {\n    startLogin(baseUrl, {\n      type: 'm.login.password',\n      identifier: {\n        type: 'm.id.thirdparty',\n        medium: 'email',\n        address: email,\n      },\n      password,\n      initial_device_display_name: 'Cinny Web',\n    });\n  };\n\n  const handleSubmit: FormEventHandler<HTMLFormElement> = (evt) => {\n    evt.preventDefault();\n    const { usernameInput, passwordInput } = evt.target as HTMLFormElement & {\n      usernameInput: HTMLInputElement;\n      passwordInput: HTMLInputElement;\n    };\n\n    const username = usernameInput.value.trim();\n    const password = passwordInput.value;\n    if (!username) {\n      usernameInput.focus();\n      return;\n    }\n    if (!password) {\n      passwordInput.focus();\n      return;\n    }\n\n    if (isUserId(username)) {\n      handleMxIdLogin(username, password);\n      return;\n    }\n    if (EMAIL_REGEX.test(username)) {\n      handleEmailLogin(username, password);\n      return;\n    }\n    handleUsernameLogin(username, password);\n  };\n\n  return (\n    <Box as=\"form\" onSubmit={handleSubmit} direction=\"Inherit\" gap=\"400\">\n      <Box direction=\"Column\" gap=\"100\">\n        <Text as=\"label\" size=\"L400\" priority=\"300\">\n          Username\n        </Text>\n        <Input\n          defaultValue={defaultUsername ?? defaultEmail}\n          style={{ paddingRight: config.space.S300 }}\n          name=\"usernameInput\"\n          variant=\"Background\"\n          size=\"500\"\n          required\n          outlined\n          after={<UsernameHint server={server} />}\n        />\n        {loginState.status === AsyncStatus.Error && (\n          <>\n            {loginState.error.errcode === LoginError.ServerNotAllowed && (\n              <FieldError message=\"Login with custom server not allowed by your client instance.\" />\n            )}\n            {loginState.error.errcode === LoginError.InvalidServer && (\n              <FieldError message=\"Failed to find your Matrix ID server.\" />\n            )}\n          </>\n        )}\n      </Box>\n      <Box direction=\"Column\" gap=\"100\">\n        <Text as=\"label\" size=\"L400\" priority=\"300\">\n          Password\n        </Text>\n        <PasswordInput name=\"passwordInput\" variant=\"Background\" size=\"500\" outlined required />\n        <Box alignItems=\"Start\" justifyContent=\"SpaceBetween\" gap=\"200\">\n          {loginState.status === AsyncStatus.Error && (\n            <>\n              {loginState.error.errcode === LoginError.Forbidden && (\n                <FieldError message=\"Invalid Username or Password.\" />\n              )}\n              {loginState.error.errcode === LoginError.UserDeactivated && (\n                <FieldError message=\"This account has been deactivated.\" />\n              )}\n              {loginState.error.errcode === LoginError.InvalidRequest && (\n                <FieldError message=\"Failed to login. Part of your request data is invalid.\" />\n              )}\n              {loginState.error.errcode === LoginError.RateLimited && (\n                <FieldError message=\"Failed to login. Your login request has been rate-limited by server, Please try after some time.\" />\n              )}\n              {loginState.error.errcode === LoginError.Unknown && (\n                <FieldError message=\"Failed to login. Unknown reason.\" />\n              )}\n            </>\n          )}\n          <Box grow=\"Yes\" shrink=\"No\" justifyContent=\"End\">\n            <Text as=\"span\" size=\"T200\" priority=\"400\" align=\"Right\">\n              <Link to={getResetPasswordPath(server)}>Forget Password?</Link>\n            </Text>\n          </Box>\n        </Box>\n      </Box>\n      <Button type=\"submit\" variant=\"Primary\" size=\"500\">\n        <Text as=\"span\" size=\"B500\">\n          Login\n        </Text>\n      </Button>\n\n      <Overlay\n        open={\n          loginState.status === AsyncStatus.Loading || loginState.status === AsyncStatus.Success\n        }\n        backdrop={<OverlayBackdrop />}\n      >\n        <OverlayCenter>\n          <Spinner variant=\"Secondary\" size=\"600\" />\n        </OverlayCenter>\n      </Overlay>\n    </Box>\n  );\n}\n","import { Avatar, AvatarImage, Box, Button, Text } from 'folds';\nimport { IIdentityProvider, createClient } from 'matrix-js-sdk';\nimport React, { useMemo } from 'react';\nimport { useAutoDiscoveryInfo } from '../../hooks/useAutoDiscoveryInfo';\n\ntype SSOLoginProps = {\n  providers?: IIdentityProvider[];\n  redirectUrl: string;\n  saveScreenSpace?: boolean;\n};\nexport function SSOLogin({ providers, redirectUrl, saveScreenSpace }: SSOLoginProps) {\n  const discovery = useAutoDiscoveryInfo();\n  const baseUrl = discovery['m.homeserver'].base_url;\n  const mx = useMemo(() => createClient({ baseUrl }), [baseUrl]);\n\n  const getSSOIdUrl = (ssoId?: string): string => mx.getSsoLoginUrl(redirectUrl, 'sso', ssoId);\n\n  const withoutIcon = providers\n    ? providers.find(\n        (provider) => !provider.icon || !mx.mxcUrlToHttp(provider.icon, 96, 96, 'crop', false)\n      )\n    : true;\n\n  const renderAsIcons = withoutIcon ? false : saveScreenSpace && providers && providers.length > 2;\n\n  return (\n    <Box justifyContent=\"Center\" gap=\"600\" wrap=\"Wrap\">\n      {providers ? (\n        providers.map((provider) => {\n          const { id, name, icon } = provider;\n          const iconUrl = icon && mx.mxcUrlToHttp(icon, 96, 96, 'crop', false);\n\n          const buttonTitle = `Continue with ${name}`;\n\n          if (renderAsIcons) {\n            return (\n              <Avatar\n                style={{ cursor: 'pointer' }}\n                key={id}\n                as=\"a\"\n                href={getSSOIdUrl(id)}\n                aria-label={buttonTitle}\n                size=\"300\"\n                radii=\"300\"\n              >\n                <AvatarImage src={iconUrl!} alt={name} title={buttonTitle} />\n              </Avatar>\n            );\n          }\n\n          return (\n            <Button\n              style={{ width: '100%' }}\n              key={id}\n              as=\"a\"\n              href={getSSOIdUrl(id)}\n              size=\"500\"\n              variant=\"Secondary\"\n              fill=\"Soft\"\n              outlined\n              before={\n                iconUrl && (\n                  <Avatar size=\"200\" radii=\"300\">\n                    <AvatarImage src={iconUrl} alt={name} />\n                  </Avatar>\n                )\n              }\n            >\n              <Text align=\"Center\" size=\"B500\" truncate>\n                {buttonTitle}\n              </Text>\n            </Button>\n          );\n        })\n      ) : (\n        <Button\n          style={{ width: '100%' }}\n          as=\"a\"\n          href={getSSOIdUrl()}\n          size=\"500\"\n          variant=\"Secondary\"\n          fill=\"Soft\"\n          outlined\n        >\n          <Text align=\"Center\" size=\"B500\" truncate>\n            Continue with SSO\n          </Text>\n        </Button>\n      )}\n    </Box>\n  );\n}\n","import {\n  Box,\n  Icon,\n  Icons,\n  Overlay,\n  OverlayBackdrop,\n  OverlayCenter,\n  Spinner,\n  Text,\n  color,\n  config,\n} from 'folds';\nimport React, { useCallback, useEffect } from 'react';\nimport { MatrixError } from 'matrix-js-sdk';\nimport { useAutoDiscoveryInfo } from '../../../hooks/useAutoDiscoveryInfo';\nimport { AsyncStatus, useAsyncCallback } from '../../../hooks/useAsyncCallback';\nimport { CustomLoginResponse, LoginError, login, useLoginComplete } from './loginUtil';\n\nfunction LoginTokenError({ message }: { message: string }) {\n  return (\n    <Box\n      style={{\n        backgroundColor: color.Critical.Container,\n        color: color.Critical.OnContainer,\n        padding: config.space.S300,\n        borderRadius: config.radii.R400,\n      }}\n      justifyContent=\"Start\"\n      alignItems=\"Start\"\n      gap=\"300\"\n    >\n      <Icon size=\"300\" filled src={Icons.Warning} />\n      <Box direction=\"Column\" gap=\"100\">\n        <Text size=\"L400\">Token Login</Text>\n        <Text size=\"T300\">\n          <b>{message}</b>\n        </Text>\n      </Box>\n    </Box>\n  );\n}\n\ntype TokenLoginProps = {\n  token: string;\n};\nexport function TokenLogin({ token }: TokenLoginProps) {\n  const discovery = useAutoDiscoveryInfo();\n  const baseUrl = discovery['m.homeserver'].base_url;\n\n  const [loginState, startLogin] = useAsyncCallback<\n    CustomLoginResponse,\n    MatrixError,\n    Parameters<typeof login>\n  >(useCallback(login, []));\n\n  useEffect(() => {\n    startLogin(baseUrl, {\n      type: 'm.login.token',\n      token,\n      initial_device_display_name: 'Cinny Web',\n    });\n  }, [baseUrl, token, startLogin]);\n\n  useLoginComplete(loginState.status === AsyncStatus.Success ? loginState.data : undefined);\n\n  return (\n    <>\n      {loginState.status === AsyncStatus.Error && (\n        <>\n          {loginState.error.errcode === LoginError.Forbidden && (\n            <LoginTokenError message=\"Invalid login token.\" />\n          )}\n          {loginState.error.errcode === LoginError.UserDeactivated && (\n            <LoginTokenError message=\"This account has been deactivated.\" />\n          )}\n          {loginState.error.errcode === LoginError.InvalidRequest && (\n            <LoginTokenError message=\"Failed to login. Part of your request data is invalid.\" />\n          )}\n          {loginState.error.errcode === LoginError.RateLimited && (\n            <LoginTokenError message=\"Failed to login. Your login request has been rate-limited by server, Please try after some time.\" />\n          )}\n          {loginState.error.errcode === LoginError.Unknown && (\n            <LoginTokenError message=\"Failed to login. Unknown reason.\" />\n          )}\n        </>\n      )}\n      <Overlay open={loginState.status !== AsyncStatus.Error} backdrop={<OverlayBackdrop />}>\n        <OverlayCenter>\n          <Spinner size=\"600\" variant=\"Secondary\" />\n        </OverlayCenter>\n      </Overlay>\n    </>\n  );\n}\n","import React from 'react';\nimport { Box, Line, Text } from 'folds';\n\nexport function OrDivider() {\n  return (\n    <Box gap=\"400\" alignItems=\"Center\">\n      <Line style={{ flexGrow: 1 }} direction=\"Horizontal\" size=\"300\" variant=\"Surface\" />\n      <Text>OR</Text>\n      <Line style={{ flexGrow: 1 }} direction=\"Horizontal\" size=\"300\" variant=\"Surface\" />\n    </Box>\n  );\n}\n","import { useMemo } from 'react';\nimport { useClientConfig } from './useClientConfig';\nimport { trimLeadingSlash, trimSlash, trimTrailingSlash } from '../utils/common';\n\nexport const usePathWithOrigin = (path: string): string => {\n  const { hashRouter } = useClientConfig();\n  const { origin } = window.location;\n\n  const pathWithOrigin = useMemo(() => {\n    let url: string = trimSlash(origin);\n\n    url += `/${trimSlash(import.meta.env.BASE_URL ?? '')}`;\n    url = trimTrailingSlash(url);\n\n    if (hashRouter?.enabled) {\n      url += `/#/${trimSlash(hashRouter.basename ?? '')}`;\n      url = trimTrailingSlash(url);\n    }\n\n    url += `/${trimLeadingSlash(path)}`;\n\n    return url;\n  }, [path, hashRouter, origin]);\n\n  return pathWithOrigin;\n};\n","import React, { useMemo } from 'react';\nimport { Box, Text, color } from 'folds';\nimport { Link, useSearchParams } from 'react-router-dom';\nimport { useAuthFlows } from '../../../hooks/useAuthFlows';\nimport { useAuthServer } from '../../../hooks/useAuthServer';\nimport { useParsedLoginFlows } from '../../../hooks/useParsedLoginFlows';\nimport { PasswordLoginForm } from './PasswordLoginForm';\nimport { SSOLogin } from '../SSOLogin';\nimport { TokenLogin } from './TokenLogin';\nimport { OrDivider } from '../OrDivider';\nimport { getLoginPath, getRegisterPath, withSearchParam } from '../../pathUtils';\nimport { usePathWithOrigin } from '../../../hooks/usePathWithOrigin';\nimport { LoginPathSearchParams } from '../../paths';\nimport { useClientConfig } from '../../../hooks/useClientConfig';\n\nconst getLoginTokenSearchParam = () => {\n  // when using hasRouter query params in existing route\n  // gets ignored by react-router, so we need to read it ourself\n  // we only need to read loginToken as it's the only param that\n  // is provided by external entity. example: SSO login\n  const parmas = new URLSearchParams(window.location.search);\n  const loginToken = parmas.get('loginToken');\n  return loginToken ?? undefined;\n};\n\nconst useLoginSearchParams = (searchParams: URLSearchParams): LoginPathSearchParams =>\n  useMemo(\n    () => ({\n      username: searchParams.get('username') ?? undefined,\n      email: searchParams.get('email') ?? undefined,\n      loginToken: searchParams.get('loginToken') ?? undefined,\n    }),\n    [searchParams]\n  );\n\nexport function Login() {\n  const server = useAuthServer();\n  const { hashRouter } = useClientConfig();\n  const { loginFlows } = useAuthFlows();\n  const [searchParams] = useSearchParams();\n  const loginSearchParams = useLoginSearchParams(searchParams);\n  const ssoRedirectUrl = usePathWithOrigin(getLoginPath(server));\n  const loginTokenForHashRouter = getLoginTokenSearchParam();\n  const absoluteLoginPath = usePathWithOrigin(getLoginPath(server));\n\n  if (hashRouter?.enabled && loginTokenForHashRouter) {\n    window.location.replace(\n      withSearchParam(absoluteLoginPath, {\n        loginToken: loginTokenForHashRouter,\n      })\n    );\n  }\n\n  const parsedFlows = useParsedLoginFlows(loginFlows.flows);\n\n  return (\n    <Box direction=\"Column\" gap=\"500\">\n      <Text size=\"H2\" priority=\"400\">\n        Login\n      </Text>\n      {parsedFlows.token && loginSearchParams.loginToken && (\n        <TokenLogin token={loginSearchParams.loginToken} />\n      )}\n      {parsedFlows.password && (\n        <>\n          <PasswordLoginForm\n            defaultUsername={loginSearchParams.username}\n            defaultEmail={loginSearchParams.email}\n          />\n          <span data-spacing-node />\n          {parsedFlows.sso && <OrDivider />}\n        </>\n      )}\n      {parsedFlows.sso && (\n        <>\n          <SSOLogin\n            providers={parsedFlows.sso.identity_providers}\n            redirectUrl={ssoRedirectUrl}\n            saveScreenSpace={parsedFlows.password !== undefined}\n          />\n          <span data-spacing-node />\n        </>\n      )}\n      {!parsedFlows.password && !parsedFlows.sso && (\n        <>\n          <Text style={{ color: color.Critical.Main }}>\n            {`This client does not support login on \"${server}\" homeserver. Password and SSO based login method not found.`}\n          </Text>\n          <span data-spacing-node />\n        </>\n      )}\n      <Text align=\"Center\">\n        Do not have an account? <Link to={getRegisterPath(server)}>Register</Link>\n      </Text>\n    </Box>\n  );\n}\n","import { AuthType, IAuthData, UIAFlow } from 'matrix-js-sdk';\n\nexport const getSupportedUIAFlows = (uiaFlows: UIAFlow[], supportedStages: string[]): UIAFlow[] => {\n  const supportedUIAFlows = uiaFlows.filter((flow) =>\n    flow.stages.every((stage) => supportedStages.includes(stage))\n  );\n\n  return supportedUIAFlows;\n};\n\nexport const getUIACompleted = (authData: IAuthData): string[] => {\n  const completed = authData.completed ?? [];\n  return completed;\n};\n\nexport type UIAParams = Record<string, Record<string, unknown>>;\nexport const getUIAParams = (authData: IAuthData): UIAParams => {\n  const params = authData.params ?? {};\n  return params;\n};\n\nexport const getUIASession = (authData: IAuthData): string | undefined => {\n  const session = authData.session ?? undefined;\n  return session;\n};\n\nexport const getUIAErrorCode = (authData: IAuthData): string | undefined => {\n  const errorCode =\n    'errcode' in authData && typeof authData.errcode === 'string' ? authData.errcode : undefined;\n\n  return errorCode;\n};\n\nexport const getUIAError = (authData: IAuthData): string | undefined => {\n  const errorCode =\n    'error' in authData && typeof authData.error === 'string' ? authData.error : undefined;\n\n  return errorCode;\n};\n\nexport const getUIAFlowForStages = (uiaFlows: UIAFlow[], stages: string[]): UIAFlow | undefined => {\n  const matchedFlows = uiaFlows\n    .filter((flow) => {\n      if (flow.stages.length < stages.length) return false;\n      if (flow.stages.length > stages.length) {\n        // As a valid flow can also have m.login.dummy type,\n        // we will pick one extra length flow only if it has dummy\n        if (flow.stages.length > stages.length + 1) return false;\n        if (stages.includes(AuthType.Dummy)) return false;\n        if (flow.stages.includes(AuthType.Dummy)) return true;\n        return false;\n      }\n      return true;\n    })\n    .filter((flow) => stages.every((stage) => flow.stages.includes(stage)));\n\n  if (matchedFlows.length === 0) return undefined;\n\n  matchedFlows.sort((a, b) => a.stages.length - b.stages.length);\n  return matchedFlows[0];\n};\n\nexport const hasStageInFlows = (uiaFlows: UIAFlow[], stage: string) =>\n  uiaFlows.some((flow) => flow.stages.includes(stage));\n\nexport const requiredStageInFlows = (uiaFlows: UIAFlow[], stage: string) =>\n  uiaFlows.every((flow) => flow.stages.includes(stage));\n\nexport const getLoginTermUrl = (params: UIAParams): string | undefined => {\n  const terms = params[AuthType.Terms];\n  if (terms && 'policies' in terms && typeof terms.policies === 'object') {\n    if (terms.policies === null) return undefined;\n    if ('privacy_policy' in terms.policies && typeof terms.policies.privacy_policy === 'object') {\n      if (terms.policies.privacy_policy === null) return undefined;\n      const langToPolicy = terms.policies.privacy_policy as Record<string, any>;\n      const url = langToPolicy.en?.url;\n      if (typeof url === 'string') return url;\n\n      const firstKey = Object.keys(langToPolicy)[0];\n      return langToPolicy[firstKey]?.url;\n    }\n  }\n  return undefined;\n};\n","import { AuthType, IAuthData, UIAFlow } from 'matrix-js-sdk';\nimport { useCallback, useMemo } from 'react';\nimport {\n  getSupportedUIAFlows,\n  getUIACompleted,\n  getUIAError,\n  getUIAErrorCode,\n  getUIAParams,\n  getUIASession,\n} from '../utils/matrix-uia';\n\nexport const SUPPORTED_FLOW_TYPES = [\n  AuthType.Dummy,\n  AuthType.Password,\n  AuthType.Email,\n  AuthType.Terms,\n  AuthType.Recaptcha,\n  AuthType.RegistrationToken,\n] as const;\n\nexport const useSupportedUIAFlows = (uiaFlows: UIAFlow[], supportedStages: string[]): UIAFlow[] =>\n  useMemo(() => getSupportedUIAFlows(uiaFlows, supportedStages), [uiaFlows, supportedStages]);\n\nexport const useUIACompleted = (authData: IAuthData): string[] =>\n  useMemo(() => getUIACompleted(authData), [authData]);\n\nexport const useUIAParams = (authData: IAuthData) =>\n  useMemo(() => getUIAParams(authData), [authData]);\n\nexport const useUIASession = (authData: IAuthData) =>\n  useMemo(() => getUIASession(authData), [authData]);\n\nexport const useUIAErrorCode = (authData: IAuthData) =>\n  useMemo(() => getUIAErrorCode(authData), [authData]);\n\nexport const useUIAError = (authData: IAuthData) =>\n  useMemo(() => getUIAError(authData), [authData]);\n\nexport type StageInfo = Record<string, unknown>;\nexport type AuthStageData = {\n  type: string;\n  info?: StageInfo;\n  session?: string;\n  errorCode?: string;\n  error?: string;\n};\nexport type AuthStageDataGetter = () => AuthStageData | undefined;\n\nexport type UIAFlowInterface = {\n  getStageToComplete: AuthStageDataGetter;\n  hasStage: (stageType: string) => boolean;\n  getStageInfo: (stageType: string) => StageInfo | undefined;\n};\nexport const useUIAFlow = (authData: IAuthData, uiaFlow: UIAFlow): UIAFlowInterface => {\n  const completed = useUIACompleted(authData);\n  const params = useUIAParams(authData);\n  const session = useUIASession(authData);\n  const errorCode = useUIAErrorCode(authData);\n  const error = useUIAError(authData);\n\n  const getStageToComplete: AuthStageDataGetter = useCallback(() => {\n    const { stages } = uiaFlow;\n    const nextStage = stages.find((stage) => !completed.includes(stage));\n    if (!nextStage) return undefined;\n\n    const info = params[nextStage];\n\n    return {\n      type: nextStage,\n      info,\n      session,\n      errorCode,\n      error,\n    };\n  }, [uiaFlow, completed, params, errorCode, error, session]);\n\n  const hasStage = useCallback(\n    (stageType: string): boolean => uiaFlow.stages.includes(stageType),\n    [uiaFlow]\n  );\n\n  const getStageInfo = useCallback(\n    (stageType: string): StageInfo | undefined => {\n      if (!hasStage(stageType)) return undefined;\n\n      return params[stageType];\n    },\n    [hasStage, params]\n  );\n\n  return {\n    getStageToComplete,\n    hasStage,\n    getStageInfo,\n  };\n};\n","import to from 'await-to-js';\nimport {\n  IAuthData,\n  MatrixClient,\n  MatrixError,\n  RegisterRequest,\n  RegisterResponse,\n} from 'matrix-js-sdk';\nimport { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { updateLocalStore } from '../../../../client/action/auth';\nimport { LoginPathSearchParams } from '../../paths';\nimport { ErrorCode } from '../../../cs-errorcode';\nimport {\n  deleteAfterLoginRedirectPath,\n  getAfterLoginRedirectPath,\n} from '../../afterLoginRedirectPath';\nimport { getHomePath, getLoginPath, withSearchParam } from '../../pathUtils';\nimport { getMxIdLocalPart, getMxIdServer } from '../../../utils/matrix';\n\nexport enum RegisterError {\n  UserTaken = 'UserTaken',\n  UserInvalid = 'UserInvalid',\n  UserExclusive = 'UserExclusive',\n  PasswordWeak = 'PasswordWeak',\n  PasswordShort = 'PasswordShort',\n  InvalidRequest = 'InvalidRequest',\n  Forbidden = 'Forbidden',\n  RateLimited = 'RateLimited',\n  Unknown = 'Unknown',\n}\n\nexport type CustomRegisterResponse = {\n  baseUrl: string;\n  response: RegisterResponse;\n};\nexport type RegisterResult = [IAuthData, undefined] | [undefined, CustomRegisterResponse];\nexport const register = async (\n  mx: MatrixClient,\n  requestData: RegisterRequest\n): Promise<RegisterResult> => {\n  const [err, res] = await to<RegisterResponse, MatrixError>(mx.registerRequest(requestData));\n\n  if (err) {\n    if (err.httpStatus === 401) {\n      const authData = err.data as IAuthData;\n      return [authData, undefined];\n    }\n\n    if (err.errcode === ErrorCode.M_USER_IN_USE) {\n      throw new MatrixError({\n        errcode: RegisterError.UserTaken,\n      });\n    }\n    if (err.errcode === ErrorCode.M_INVALID_USERNAME) {\n      throw new MatrixError({\n        errcode: RegisterError.UserInvalid,\n      });\n    }\n    if (err.errcode === ErrorCode.M_EXCLUSIVE) {\n      throw new MatrixError({\n        errcode: RegisterError.UserExclusive,\n      });\n    }\n    if (err.errcode === ErrorCode.M_WEAK_PASSWORD) {\n      throw new MatrixError({\n        errcode: RegisterError.PasswordWeak,\n        error: err.data.error,\n      });\n    }\n    if (err.errcode === ErrorCode.M_PASSWORD_TOO_SHORT) {\n      throw new MatrixError({\n        errcode: RegisterError.PasswordShort,\n        error: err.data.error,\n      });\n    }\n\n    if (err.httpStatus === 429) {\n      throw new MatrixError({\n        errcode: RegisterError.RateLimited,\n      });\n    }\n\n    if (err.httpStatus === 400) {\n      throw new MatrixError({\n        errcode: RegisterError.InvalidRequest,\n      });\n    }\n\n    if (err.httpStatus === 403) {\n      throw new MatrixError({\n        errcode: RegisterError.Forbidden,\n      });\n    }\n\n    throw new MatrixError({\n      errcode: RegisterError.Unknown,\n      error: err.data.error,\n    });\n  }\n  return [\n    undefined,\n    {\n      baseUrl: mx.baseUrl,\n      response: res,\n    },\n  ];\n};\n\nexport const useRegisterComplete = (data?: CustomRegisterResponse) => {\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    if (data) {\n      const { response, baseUrl } = data;\n\n      const userId = response.user_id;\n      const accessToken = response.access_token;\n      const deviceId = response.device_id;\n\n      if (accessToken && deviceId) {\n        updateLocalStore(accessToken, deviceId, userId, baseUrl);\n        const afterLoginRedirectPath = getAfterLoginRedirectPath();\n        deleteAfterLoginRedirectPath();\n        navigate(afterLoginRedirectPath ?? getHomePath(), { replace: true });\n      } else {\n        const username = getMxIdLocalPart(userId);\n        const userServer = getMxIdServer(userId);\n        navigate(\n          withSearchParam<LoginPathSearchParams>(getLoginPath(userServer), {\n            username,\n          }),\n          { replace: true }\n        );\n      }\n    }\n  }, [data, navigate]);\n};\n","import React, { useEffect, useCallback } from 'react';\nimport { Dialog, Text, Box, Button, config } from 'folds';\nimport { AuthType } from 'matrix-js-sdk';\nimport { StageComponentProps } from './types';\n\nfunction DummyErrorDialog({\n  title,\n  message,\n  onRetry,\n  onCancel,\n}: {\n  title: string;\n  message: string;\n  onRetry: () => void;\n  onCancel: () => void;\n}) {\n  return (\n    <Dialog>\n      <Box style={{ padding: config.space.S400 }} direction=\"Column\" gap=\"400\">\n        <Box direction=\"Column\" gap=\"100\">\n          <Text size=\"H4\">{title}</Text>\n          <Text>{message}</Text>\n        </Box>\n        <Button variant=\"Critical\" onClick={onRetry}>\n          <Text as=\"span\" size=\"B400\">\n            Retry\n          </Text>\n        </Button>\n        <Button variant=\"Critical\" fill=\"None\" outlined onClick={onCancel}>\n          <Text as=\"span\" size=\"B400\">\n            Cancel\n          </Text>\n        </Button>\n      </Box>\n    </Dialog>\n  );\n}\n\nexport function AutoDummyStageDialog({ stageData, submitAuthDict, onCancel }: StageComponentProps) {\n  const { errorCode, error, session } = stageData;\n\n  const handleSubmit = useCallback(() => {\n    submitAuthDict({\n      type: AuthType.Dummy,\n      session,\n    });\n  }, [session, submitAuthDict]);\n\n  useEffect(() => {\n    if (!errorCode) handleSubmit();\n  }, [handleSubmit, errorCode]);\n\n  if (errorCode) {\n    return (\n      <DummyErrorDialog\n        title={errorCode}\n        message={error ?? 'Failed to register.'}\n        onRetry={handleSubmit}\n        onCancel={onCancel}\n      />\n    );\n  }\n\n  return null;\n}\n","import React, { useEffect, useCallback, FormEventHandler } from 'react';\nimport { Dialog, Text, Box, Button, config, Input, color, Spinner } from 'folds';\nimport { AuthType, MatrixError } from 'matrix-js-sdk';\nimport { StageComponentProps } from './types';\nimport { AsyncState, AsyncStatus } from '../../hooks/useAsyncCallback';\nimport { RequestEmailTokenCallback, RequestEmailTokenResponse } from '../../hooks/types';\n\nfunction EmailErrorDialog({\n  title,\n  message,\n  defaultEmail,\n  onRetry,\n  onCancel,\n}: {\n  title: string;\n  message: string;\n  defaultEmail?: string;\n  onRetry: (email: string) => void;\n  onCancel: () => void;\n}) {\n  const handleFormSubmit: FormEventHandler<HTMLFormElement> = (evt) => {\n    evt.preventDefault();\n    const { retryEmailInput } = evt.target as HTMLFormElement & {\n      retryEmailInput: HTMLInputElement;\n    };\n    const t = retryEmailInput.value;\n    onRetry(t);\n  };\n\n  return (\n    <Dialog>\n      <Box\n        as=\"form\"\n        onSubmit={handleFormSubmit}\n        style={{ padding: config.space.S400 }}\n        direction=\"Column\"\n        gap=\"400\"\n      >\n        <Box direction=\"Column\" gap=\"100\">\n          <Text size=\"H4\">{title}</Text>\n          <Text>{message}</Text>\n          <Text as=\"label\" size=\"L400\" style={{ paddingTop: config.space.S400 }}>\n            Email\n          </Text>\n          <Input\n            name=\"retryEmailInput\"\n            variant=\"Background\"\n            size=\"500\"\n            outlined\n            defaultValue={defaultEmail}\n            required\n          />\n        </Box>\n        <Button variant=\"Primary\" type=\"submit\">\n          <Text as=\"span\" size=\"B400\">\n            Send Verification Email\n          </Text>\n        </Button>\n        <Button variant=\"Critical\" fill=\"None\" outlined type=\"button\" onClick={onCancel}>\n          <Text as=\"span\" size=\"B400\">\n            Cancel\n          </Text>\n        </Button>\n      </Box>\n    </Dialog>\n  );\n}\n\nexport function EmailStageDialog({\n  email,\n  clientSecret,\n  stageData,\n  emailTokenState,\n  requestEmailToken,\n  submitAuthDict,\n  onCancel,\n}: StageComponentProps & {\n  email?: string;\n  clientSecret: string;\n  emailTokenState: AsyncState<RequestEmailTokenResponse, MatrixError>;\n  requestEmailToken: RequestEmailTokenCallback;\n}) {\n  const { errorCode, error, session } = stageData;\n\n  const handleSubmit = useCallback(\n    (sessionId: string) => {\n      const threepIDCreds = {\n        sid: sessionId,\n        client_secret: clientSecret,\n      };\n      submitAuthDict({\n        type: AuthType.Email,\n        threepid_creds: threepIDCreds,\n        threepidCreds: threepIDCreds,\n        session,\n      });\n    },\n    [submitAuthDict, session, clientSecret]\n  );\n\n  const handleEmailSubmit = useCallback(\n    (userEmail: string) => {\n      requestEmailToken(userEmail, clientSecret);\n    },\n    [clientSecret, requestEmailToken]\n  );\n\n  useEffect(() => {\n    if (email && !errorCode && emailTokenState.status === AsyncStatus.Idle) {\n      requestEmailToken(email, clientSecret);\n    }\n  }, [email, errorCode, clientSecret, emailTokenState, requestEmailToken]);\n\n  if (emailTokenState.status === AsyncStatus.Loading) {\n    return (\n      <Box direction=\"Column\" alignItems=\"Center\" gap=\"400\">\n        <Spinner variant=\"Secondary\" size=\"600\" />\n        <Text style={{ color: color.Secondary.Main }}>Sending verification email...</Text>\n      </Box>\n    );\n  }\n\n  if (emailTokenState.status === AsyncStatus.Error) {\n    return (\n      <EmailErrorDialog\n        title={emailTokenState.error.errcode ?? 'Verify Email'}\n        message={\n          emailTokenState.error?.data?.error ??\n          emailTokenState.error.message ??\n          'Failed to send verification Email request.'\n        }\n        onRetry={handleEmailSubmit}\n        onCancel={onCancel}\n      />\n    );\n  }\n\n  if (emailTokenState.status === AsyncStatus.Success) {\n    return (\n      <Dialog>\n        <Box style={{ padding: config.space.S400 }} direction=\"Column\" gap=\"400\">\n          <Box direction=\"Column\" gap=\"100\">\n            <Text size=\"H4\">Verification Request Sent</Text>\n            <Text>{`Please check your email \"${emailTokenState.data.email}\" and validate before continuing further.`}</Text>\n\n            {errorCode && (\n              <Text style={{ color: color.Critical.Main }}>{`${errorCode}: ${error}`}</Text>\n            )}\n          </Box>\n          <Button variant=\"Primary\" onClick={() => handleSubmit(emailTokenState.data.result.sid)}>\n            <Text as=\"span\" size=\"B400\">\n              Continue\n            </Text>\n          </Button>\n        </Box>\n      </Dialog>\n    );\n  }\n\n  if (!email) {\n    return (\n      <EmailErrorDialog\n        title=\"Provide Email\"\n        message=\"Please provide email to send verification request.\"\n        onRetry={handleEmailSubmit}\n        onCancel={onCancel}\n      />\n    );\n  }\n\n  return null;\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\n\nvar ReCAPTCHA =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(ReCAPTCHA, _React$Component);\n\n  function ReCAPTCHA() {\n    var _this;\n\n    _this = _React$Component.call(this) || this;\n    _this.handleExpired = _this.handleExpired.bind(_assertThisInitialized(_this));\n    _this.handleErrored = _this.handleErrored.bind(_assertThisInitialized(_this));\n    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));\n    _this.handleRecaptchaRef = _this.handleRecaptchaRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = ReCAPTCHA.prototype;\n\n  _proto.getValue = function getValue() {\n    if (this.props.grecaptcha && this._widgetId !== undefined) {\n      return this.props.grecaptcha.getResponse(this._widgetId);\n    }\n\n    return null;\n  };\n\n  _proto.getWidgetId = function getWidgetId() {\n    if (this.props.grecaptcha && this._widgetId !== undefined) {\n      return this._widgetId;\n    }\n\n    return null;\n  };\n\n  _proto.execute = function execute() {\n    var grecaptcha = this.props.grecaptcha;\n\n    if (grecaptcha && this._widgetId !== undefined) {\n      return grecaptcha.execute(this._widgetId);\n    } else {\n      this._executeRequested = true;\n    }\n  };\n\n  _proto.executeAsync = function executeAsync() {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      _this2.executionResolve = resolve;\n      _this2.executionReject = reject;\n\n      _this2.execute();\n    });\n  };\n\n  _proto.reset = function reset() {\n    if (this.props.grecaptcha && this._widgetId !== undefined) {\n      this.props.grecaptcha.reset(this._widgetId);\n    }\n  };\n\n  _proto.handleExpired = function handleExpired() {\n    if (this.props.onExpired) {\n      this.props.onExpired();\n    } else {\n      this.handleChange(null);\n    }\n  };\n\n  _proto.handleErrored = function handleErrored() {\n    if (this.props.onErrored) {\n      this.props.onErrored();\n    }\n\n    if (this.executionReject) {\n      this.executionReject();\n      delete this.executionResolve;\n      delete this.executionReject;\n    }\n  };\n\n  _proto.handleChange = function handleChange(token) {\n    if (this.props.onChange) {\n      this.props.onChange(token);\n    }\n\n    if (this.executionResolve) {\n      this.executionResolve(token);\n      delete this.executionReject;\n      delete this.executionResolve;\n    }\n  };\n\n  _proto.explicitRender = function explicitRender() {\n    if (this.props.grecaptcha && this.props.grecaptcha.render && this._widgetId === undefined) {\n      var wrapper = document.createElement(\"div\");\n      this._widgetId = this.props.grecaptcha.render(wrapper, {\n        sitekey: this.props.sitekey,\n        callback: this.handleChange,\n        theme: this.props.theme,\n        type: this.props.type,\n        tabindex: this.props.tabindex,\n        \"expired-callback\": this.handleExpired,\n        \"error-callback\": this.handleErrored,\n        size: this.props.size,\n        stoken: this.props.stoken,\n        hl: this.props.hl,\n        badge: this.props.badge\n      });\n      this.captcha.appendChild(wrapper);\n    }\n\n    if (this._executeRequested && this.props.grecaptcha && this._widgetId !== undefined) {\n      this._executeRequested = false;\n      this.execute();\n    }\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.explicitRender();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    this.explicitRender();\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this._widgetId !== undefined) {\n      this.delayOfCaptchaIframeRemoving();\n      this.reset();\n    }\n  };\n\n  _proto.delayOfCaptchaIframeRemoving = function delayOfCaptchaIframeRemoving() {\n    var temporaryNode = document.createElement(\"div\");\n    document.body.appendChild(temporaryNode);\n    temporaryNode.style.display = \"none\"; // move of the recaptcha to a temporary node\n\n    while (this.captcha.firstChild) {\n      temporaryNode.appendChild(this.captcha.firstChild);\n    } // delete the temporary node after reset will be done\n\n\n    setTimeout(function () {\n      document.body.removeChild(temporaryNode);\n    }, 5000);\n  };\n\n  _proto.handleRecaptchaRef = function handleRecaptchaRef(elem) {\n    this.captcha = elem;\n  };\n\n  _proto.render = function render() {\n    // consume properties owned by the reCATPCHA, pass the rest to the div so the user can style it.\n\n    /* eslint-disable no-unused-vars */\n    var _this$props = this.props,\n        sitekey = _this$props.sitekey,\n        onChange = _this$props.onChange,\n        theme = _this$props.theme,\n        type = _this$props.type,\n        tabindex = _this$props.tabindex,\n        onExpired = _this$props.onExpired,\n        onErrored = _this$props.onErrored,\n        size = _this$props.size,\n        stoken = _this$props.stoken,\n        grecaptcha = _this$props.grecaptcha,\n        badge = _this$props.badge,\n        hl = _this$props.hl,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"sitekey\", \"onChange\", \"theme\", \"type\", \"tabindex\", \"onExpired\", \"onErrored\", \"size\", \"stoken\", \"grecaptcha\", \"badge\", \"hl\"]);\n    /* eslint-enable no-unused-vars */\n\n\n    return React.createElement(\"div\", _extends({}, childProps, {\n      ref: this.handleRecaptchaRef\n    }));\n  };\n\n  return ReCAPTCHA;\n}(React.Component);\n\nexport { ReCAPTCHA as default };\nReCAPTCHA.displayName = \"ReCAPTCHA\";\nReCAPTCHA.propTypes = {\n  sitekey: PropTypes.string.isRequired,\n  onChange: PropTypes.func,\n  grecaptcha: PropTypes.object,\n  theme: PropTypes.oneOf([\"dark\", \"light\"]),\n  type: PropTypes.oneOf([\"image\", \"audio\"]),\n  tabindex: PropTypes.number,\n  onExpired: PropTypes.func,\n  onErrored: PropTypes.func,\n  size: PropTypes.oneOf([\"compact\", \"normal\", \"invisible\"]),\n  stoken: PropTypes.string,\n  hl: PropTypes.string,\n  badge: PropTypes.oneOf([\"bottomright\", \"bottomleft\", \"inline\"])\n};\nReCAPTCHA.defaultProps = {\n  onChange: function onChange() {},\n  theme: \"light\",\n  type: \"image\",\n  tabindex: 0,\n  size: \"normal\",\n  badge: \"bottomright\"\n};"],"file":"assets/index-J3ZDATS2.js"}